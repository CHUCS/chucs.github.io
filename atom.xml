<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHUCSIE</title>
  
  <subtitle>解題報告</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chucs.github.io/"/>
  <updated>2020-10-16T15:26:49.151Z</updated>
  <id>https://chucs.github.io/</id>
  
  <author>
    <name>CHUCSIE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Codeforces 1426D</title>
    <link href="https://chucs.github.io/Non-zero-Segments/"/>
    <id>https://chucs.github.io/Non-zero-Segments/</id>
    <published>2020-10-03T07:10:30.000Z</published>
    <updated>2020-10-16T15:26:49.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-1426D-Non-zero-Segments"><a href="#Codeforces-1426D-Non-zero-Segments" class="headerlink" title="Codeforces 1426D - Non-zero Segments"></a>Codeforces 1426D - Non-zero Segments</h1><p><a href="https://codeforces.com/problemset/problem/1426/D" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>Kolya有一陣列a，裡面數字有正有負，因為Kolya不喜歡0所以不包含0，Kolya也不喜歡子陣列中的總合為0(子陣列為一個連續的範圍)。<br>你要幫Kolya調整陣列使得任意子陣列總和不為0，你可以在陣列中的任一位置插入任意數字，就算數字超過可顯示範圍也行，請找出「最少」需要插入的數字的次數。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>需要從a<sub>i</sub>加到a<sub>j</sub>, (i &lt; j)來確認總和，因此是個前綴和的問題，從開頭開始加，用map紀錄出現過的總和，對每次的總和作判斷，如果前面出現過相同的總和代表在這區間中有子陣列總和為0，例: a=[8 5 -5]，子陣列總和=[8 13 8]，8重複出現可以發現因為有子陣列[5 -5]總和為0的關係，因此這區間需要插入一個數，因為插入一個數的關係，所以左邊的區間總和不會出現0，因此出現過的總和(map)需要重置，重新計算總和。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/cb5049de13da8958e88679cb0375f3ac.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Codeforces-1426D-Non-zero-Segments&quot;&gt;&lt;a href=&quot;#Codeforces-1426D-Non-zero-Segments&quot; class=&quot;headerlink&quot; title=&quot;Codeforces 1426D - Non-zero Segments&quot;&gt;&lt;/a&gt;Codeforces 1426D - Non-zero Segments&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1426/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;Kolya有一陣列a，裡面數字有正有負，因為Kolya不喜歡0所以不包含0，Kolya也不喜歡子陣列中的總合為0(子陣列為一個連續的範圍)。&lt;br&gt;你要幫Kolya調整陣列使得任意子陣列總和不為0，你可以在陣列中的任一位置插入任意數字，就算數字超過可顯示範圍也行，請找出「最少」需要插入的數字的次數。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://chucs.github.io/categories/Codeforces/"/>
    
    
      <category term="sortings" scheme="https://chucs.github.io/tags/sortings/"/>
    
      <category term="greedy" scheme="https://chucs.github.io/tags/greedy/"/>
    
      <category term="constructive algorithms" scheme="https://chucs.github.io/tags/constructive-algorithms/"/>
    
      <category term="data structures" scheme="https://chucs.github.io/tags/data-structures/"/>
    
      <category term="1500" scheme="https://chucs.github.io/tags/1500/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1426C</title>
    <link href="https://chucs.github.io/Increase-and-Copy/"/>
    <id>https://chucs.github.io/Increase-and-Copy/</id>
    <published>2020-10-03T07:10:14.000Z</published>
    <updated>2020-10-16T15:26:49.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-1426C-Increase-and-Copy"><a href="#Codeforces-1426C-Increase-and-Copy" class="headerlink" title="Codeforces 1426C - Increase and Copy"></a>Codeforces 1426C - Increase and Copy</h1><p><a href="https://codeforces.com/problemset/problem/1426/C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>你有一陣列a，一開始只有一個元素1(a = [1])，每次動作你能做以下一種事:<br>1.對a中其中一個元素+1<br>2.對a中其中一個元素做複製，並放在陣列最後面<br>你要找出「最小」次數的動作讓陣列a裡的元素總和至少為n。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>要次數最小，所以一次動作加越多數字越好，因此應該是先+1到某個數字後在做複製，根據數學可以知道某數的平方數字最大(算幾)，也會發現執行動作次數最少，所以要加到sqrt(n)之後作複製到超過n所需的次數。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/6e6e6cc5ae4c3bd72ddfc6b89c8d648b.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Codeforces-1426C-Increase-and-Copy&quot;&gt;&lt;a href=&quot;#Codeforces-1426C-Increase-and-Copy&quot; class=&quot;headerlink&quot; title=&quot;Codeforces 1426C - Increase and Copy&quot;&gt;&lt;/a&gt;Codeforces 1426C - Increase and Copy&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1426/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;你有一陣列a，一開始只有一個元素1(a = [1])，每次動作你能做以下一種事:&lt;br&gt;1.對a中其中一個元素+1&lt;br&gt;2.對a中其中一個元素做複製，並放在陣列最後面&lt;br&gt;你要找出「最小」次數的動作讓陣列a裡的元素總和至少為n。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://chucs.github.io/categories/Codeforces/"/>
    
    
      <category term="math" scheme="https://chucs.github.io/tags/math/"/>
    
      <category term="binary search" scheme="https://chucs.github.io/tags/binary-search/"/>
    
      <category term="constructive algorithms" scheme="https://chucs.github.io/tags/constructive-algorithms/"/>
    
      <category term="1100" scheme="https://chucs.github.io/tags/1100/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1426B</title>
    <link href="https://chucs.github.io/Symmetric-Matrix/"/>
    <id>https://chucs.github.io/Symmetric-Matrix/</id>
    <published>2020-10-03T07:09:56.000Z</published>
    <updated>2020-10-16T15:26:49.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-1426B-Symmetric-Matrix"><a href="#Codeforces-1426B-Symmetric-Matrix" class="headerlink" title="Codeforces 1426B - Symmetric Matrix"></a>Codeforces 1426B - Symmetric Matrix</h1><p><a href="https://codeforces.com/problemset/problem/1426/B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>Masha有n種類型2x2大小的磁磚，磁磚上每格各有一個數字，Masha想利用這幾種磁磚組成mxm的矩形(可用任意種類與任意數量組成)，然後Masha希望這個矩形上的數字是對稱的–對任一對位置(i,j)要符合s[i][j] = s[j][i]，請問Masha有辦法組成他想要的矩形嗎?</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>當m為奇數就不可能用2x2組成，觀察後可以發現當磁磚右上與左下數字相同必能符合對稱條件，反之則不符合對稱條件，因此在n種磁磚中有一種右上左下數字相同就能組成。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/bded1c9c1f388bf6a4f1a331a2a08147.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Codeforces-1426B-Symmetric-Matrix&quot;&gt;&lt;a href=&quot;#Codeforces-1426B-Symmetric-Matrix&quot; class=&quot;headerlink&quot; title=&quot;Codeforces 1426B - Symmetric Matrix&quot;&gt;&lt;/a&gt;Codeforces 1426B - Symmetric Matrix&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1426/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;Masha有n種類型2x2大小的磁磚，磁磚上每格各有一個數字，Masha想利用這幾種磁磚組成mxm的矩形(可用任意種類與任意數量組成)，然後Masha希望這個矩形上的數字是對稱的–對任一對位置(i,j)要符合s[i][j] = s[j][i]，請問Masha有辦法組成他想要的矩形嗎?&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://chucs.github.io/categories/Codeforces/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
      <category term="900" scheme="https://chucs.github.io/tags/900/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1426A</title>
    <link href="https://chucs.github.io/Floor-Number/"/>
    <id>https://chucs.github.io/Floor-Number/</id>
    <published>2020-10-03T07:09:35.000Z</published>
    <updated>2020-10-16T15:26:49.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-1426A-Floor-Number"><a href="#Codeforces-1426A-Floor-Number" class="headerlink" title="Codeforces 1426A - Floor Number"></a>Codeforces 1426A - Floor Number</h1><p><a href="https://codeforces.com/problemset/problem/1426/A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>Vasya拜訪Petya，Petya在公寓的第n號房間，公寓裡第一層房間為1號、2號，第二層開始每層有x間房間，請問Petya的房間在第幾層?</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>根據題目公式計算n在哪個區間，並進行樓層計算。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/0e7813a59b9e23c50d8364af4c850a65.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Codeforces-1426A-Floor-Number&quot;&gt;&lt;a href=&quot;#Codeforces-1426A-Floor-Number&quot; class=&quot;headerlink&quot; title=&quot;Codeforces 1426A - Floor Number&quot;&gt;&lt;/a&gt;Codeforces 1426A - Floor Number&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1426/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;Vasya拜訪Petya，Petya在公寓的第n號房間，公寓裡第一層房間為1號、2號，第二層開始每層有x間房間，請問Petya的房間在第幾層?&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://chucs.github.io/categories/Codeforces/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
      <category term="math" scheme="https://chucs.github.io/tags/math/"/>
    
      <category term="800" scheme="https://chucs.github.io/tags/800/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1418B</title>
    <link href="https://chucs.github.io/Negative-Prefixes/"/>
    <id>https://chucs.github.io/Negative-Prefixes/</id>
    <published>2020-09-22T14:52:31.000Z</published>
    <updated>2020-10-16T15:28:09.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodeForces-1418B-Negative-Prefixes"><a href="#CodeForces-1418B-Negative-Prefixes" class="headerlink" title="CodeForces 1418B - Negative Prefixes"></a>CodeForces 1418B - Negative Prefixes</h1><p><a href="https://codeforces.com/problemset/problem/1418/B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>你有一個陣列a，裡面有n個整數，有些整數被鎖住有些沒有，你能對沒有鎖住的整數做交換位置的動作(沒鎖對沒鎖)，另外有個序列p，為a<sub>1</sub>~a<sub>n</sub>的總和:p<sub>1</sub> = a<sub>1</sub>, p<sub>2</sub> = a<sub>1</sub> + a<sub>2</sub>… p<sub>n</sub> = a<sub>1</sub> + a<sub>2</sub> +…+ a<sub>n</sub><br>讓k為最大值j，並且p<sub>j</sub> &lt; 0 ，若p中沒有任何p<sub>j</sub> &lt; 0，則 k=0<br>你要交換未鎖住整數的位置，使得k為最小值，印出調整過後的陣列a</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>將沒鎖住的整數獨立出來，由大到小排序，再依序從頭一一放回陣列中沒鎖住的位置。<br>不考慮鎖住的數字，當正整數總和 &gt;= 負整數總和時，將正整數排前面則k=0<br>當正整數總和 &lt; 負整數總和時，則不管甚麼順序k最大<br>不選擇小排到大是因為第一個狀況，若負整數先在前面則k值不會最小</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/14bcb2bffc5c9b8cd2341a8758f78b47.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CodeForces-1418B-Negative-Prefixes&quot;&gt;&lt;a href=&quot;#CodeForces-1418B-Negative-Prefixes&quot; class=&quot;headerlink&quot; title=&quot;CodeForces 1418B - Negative Prefixes&quot;&gt;&lt;/a&gt;CodeForces 1418B - Negative Prefixes&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1418/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;你有一個陣列a，裡面有n個整數，有些整數被鎖住有些沒有，你能對沒有鎖住的整數做交換位置的動作(沒鎖對沒鎖)，另外有個序列p，為a&lt;sub&gt;1&lt;/sub&gt;~a&lt;sub&gt;n&lt;/sub&gt;的總和:p&lt;sub&gt;1&lt;/sub&gt; = a&lt;sub&gt;1&lt;/sub&gt;, p&lt;sub&gt;2&lt;/sub&gt; = a&lt;sub&gt;1&lt;/sub&gt; + a&lt;sub&gt;2&lt;/sub&gt;… p&lt;sub&gt;n&lt;/sub&gt; = a&lt;sub&gt;1&lt;/sub&gt; + a&lt;sub&gt;2&lt;/sub&gt; +…+ a&lt;sub&gt;n&lt;/sub&gt;&lt;br&gt;讓k為最大值j，並且p&lt;sub&gt;j&lt;/sub&gt; &amp;lt; 0 ，若p中沒有任何p&lt;sub&gt;j&lt;/sub&gt; &amp;lt; 0，則 k=0&lt;br&gt;你要交換未鎖住整數的位置，使得k為最小值，印出調整過後的陣列a&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://chucs.github.io/categories/Codeforces/"/>
    
    
      <category term="sortings" scheme="https://chucs.github.io/tags/sortings/"/>
    
      <category term="greedy" scheme="https://chucs.github.io/tags/greedy/"/>
    
      <category term="1300" scheme="https://chucs.github.io/tags/1300/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1418A</title>
    <link href="https://chucs.github.io/Buying-Torches/"/>
    <id>https://chucs.github.io/Buying-Torches/</id>
    <published>2020-09-22T14:51:35.000Z</published>
    <updated>2020-10-16T15:29:20.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodeForces-1418A-Buying-Torches"><a href="#CodeForces-1418A-Buying-Torches" class="headerlink" title="CodeForces 1418A - Buying Torches"></a>CodeForces 1418A - Buying Torches</h1><p><a href="https://codeforces.com/problemset/problem/1418/A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>你玩遊戲想要製作k個火把，每個火把需要一根棒子和一個煤炭，一開始你只有一根棒子,你能跟商人做兩種交易:<br>    1.用一根棒子交換x根棒子<br>    2.用y根棒子交換一個煤炭<br>每次只能做其中一種交易，請問你需要k個火把「最少」需要幾次交易? (測資必存在解答)</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>數學問題，幾個煤炭就需要交易幾次，並且煤炭等於y根棒子，所以交易次數=到達所需棒子量的交易次數+換煤炭的次數。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/fce4c025b50df9f1982acbd833a09d91.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CodeForces-1418A-Buying-Torches&quot;&gt;&lt;a href=&quot;#CodeForces-1418A-Buying-Torches&quot; class=&quot;headerlink&quot; title=&quot;CodeForces 1418A - Buying Torches&quot;&gt;&lt;/a&gt;CodeForces 1418A - Buying Torches&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1418/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;你玩遊戲想要製作k個火把，每個火把需要一根棒子和一個煤炭，一開始你只有一根棒子,你能跟商人做兩種交易:&lt;br&gt;    1.用一根棒子交換x根棒子&lt;br&gt;    2.用y根棒子交換一個煤炭&lt;br&gt;每次只能做其中一種交易，請問你需要k個火把「最少」需要幾次交易? (測資必存在解答)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://chucs.github.io/categories/Codeforces/"/>
    
    
      <category term="math" scheme="https://chucs.github.io/tags/math/"/>
    
      <category term="1000" scheme="https://chucs.github.io/tags/1000/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_8_C - Binary Search Tree III</title>
    <link href="https://chucs.github.io/ALDS1-8-C-Binary-Search-Tree-III/"/>
    <id>https://chucs.github.io/ALDS1-8-C-Binary-Search-Tree-III/</id>
    <published>2020-08-24T05:45:44.000Z</published>
    <updated>2020-09-08T12:13:58.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二元樹搜索-刪除"><a href="#二元樹搜索-刪除" class="headerlink" title="二元樹搜索 - 刪除"></a>二元樹搜索 - 刪除</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>編程一個擁有新增、查詢、刪除功能的二元樹，在每次新增點時，如果key大於node-&gt;key，就新增在node-&gt;right，否則新增在node-&gt;left。最後輸出Preorder與Inorder。</p><a id="more"></a><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/e5a835cfa1a3f511e096388e9697423c.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二元樹搜索-刪除&quot;&gt;&lt;a href=&quot;#二元樹搜索-刪除&quot; class=&quot;headerlink&quot; title=&quot;二元樹搜索 - 刪除&quot;&gt;&lt;/a&gt;二元樹搜索 - 刪除&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;編程一個擁有新增、查詢、刪除功能的二元樹，在每次新增點時，如果key大於node-&amp;gt;key，就新增在node-&amp;gt;right，否則新增在node-&amp;gt;left。最後輸出Preorder與Inorder。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_8_B - Binary Search Tree II</title>
    <link href="https://chucs.github.io/ALDS1-8-B-Binary-Search-Tree-II/"/>
    <id>https://chucs.github.io/ALDS1-8-B-Binary-Search-Tree-II/</id>
    <published>2020-08-24T05:45:33.000Z</published>
    <updated>2020-09-08T12:13:55.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二元樹搜索-查詢"><a href="#二元樹搜索-查詢" class="headerlink" title="二元樹搜索 - 查詢"></a>二元樹搜索 - 查詢</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node-&gt;key，就新增在node-&gt;right，否則新增在node-&gt;left。最後輸出Preorder與Inorder。</p><a id="more"></a><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/64cf5d826826134e302151c569adb7d8.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二元樹搜索-查詢&quot;&gt;&lt;a href=&quot;#二元樹搜索-查詢&quot; class=&quot;headerlink&quot; title=&quot;二元樹搜索 - 查詢&quot;&gt;&lt;/a&gt;二元樹搜索 - 查詢&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node-&amp;gt;key，就新增在node-&amp;gt;right，否則新增在node-&amp;gt;left。最後輸出Preorder與Inorder。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_8_A - Binary Search Tree I</title>
    <link href="https://chucs.github.io/ALDS1-8-A-Binary-Search-Tree-I/"/>
    <id>https://chucs.github.io/ALDS1-8-A-Binary-Search-Tree-I/</id>
    <published>2020-08-24T05:45:19.000Z</published>
    <updated>2020-09-08T12:13:52.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二元樹搜索-新增"><a href="#二元樹搜索-新增" class="headerlink" title="二元樹搜索 - 新增"></a>二元樹搜索 - 新增</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node-&gt;key，就新增在node-&gt;right，否則新增在node-&gt;left。最後輸出Preorder與Inorder。</p><a id="more"></a><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/f392df5b2c8130b6eeff6a0b8c1b82bb.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二元樹搜索-新增&quot;&gt;&lt;a href=&quot;#二元樹搜索-新增&quot; class=&quot;headerlink&quot; title=&quot;二元樹搜索 - 新增&quot;&gt;&lt;/a&gt;二元樹搜索 - 新增&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node-&amp;gt;key，就新增在node-&amp;gt;right，否則新增在node-&amp;gt;left。最後輸出Preorder與Inorder。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_7_C - Tree Walk</title>
    <link href="https://chucs.github.io/ALDS1-7-C-Tree-Walk/"/>
    <id>https://chucs.github.io/ALDS1-7-C-Tree-Walk/</id>
    <published>2020-08-11T04:55:23.000Z</published>
    <updated>2020-08-24T05:54:23.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="樹遍歷"><a href="#樹遍歷" class="headerlink" title="樹遍歷"></a>樹遍歷</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>您的任務是編寫一個程序，該程序根據以下算法執行樹遍歷（系統遍歷樹中的所有例程）：</p><ol><li>根、左子樹和右子樹(preorder)。</li><li>左子樹、根子樹和右子樹(inorder)。</li><li>左子樹、右子樹和根(postorder)。</li></ol><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>創建一個結構left代表左子樹，right代表右子樹，pr代表父節點用於檢查是否為跟節點。</p><p>創建一個帶有結構的陣列依序填入所有值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; key &gt;&gt; left &gt;&gt; right;</span><br><span class="line">    </span><br><span class="line">    tree[key].left = left;</span><br><span class="line">    tree[key].right = right;</span><br><span class="line">    tree[left].pr = key;</span><br><span class="line">    tree[right].pr = key;</span><br><span class="line">    node[i] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著尋找父節點，輸入的所有節點檢查pr為-1就是父節點。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRoot</span><span class="params">(Node* tree, <span class="keyword">int</span> *node, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[node[i]].pr == <span class="number">-1</span>)&#123;</span><br><span class="line">            root = node[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後利用題目上敘的規則遞迴輸出。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/b95063f99f1a85b8b827f35fe13c2c35.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;樹遍歷&quot;&gt;&lt;a href=&quot;#樹遍歷&quot; class=&quot;headerlink&quot; title=&quot;樹遍歷&quot;&gt;&lt;/a&gt;樹遍歷&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;您的任務是編寫一個程序，該程序根據以下算法執行樹遍歷（系統遍歷樹中的所有例程）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根、左子樹和右子樹(preorder)。&lt;/li&gt;
&lt;li&gt;左子樹、根子樹和右子樹(inorder)。&lt;/li&gt;
&lt;li&gt;左子樹、右子樹和根(postorder)。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_7_B - Binary Tree</title>
    <link href="https://chucs.github.io/ALDS1-7-B-Binary-Tree/"/>
    <id>https://chucs.github.io/ALDS1-7-B-Binary-Tree/</id>
    <published>2020-07-18T07:53:01.000Z</published>
    <updated>2020-08-11T06:22:55.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二元樹"><a href="#二元樹" class="headerlink" title="二元樹"></a>二元樹</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>有根的二叉樹是具有根節點的樹，其中每個節點最多有兩個子節點。</p><p>您的任務是編寫一個程序，該程序讀取有根的二叉樹T並為T的每個節點u打印以下信息：<br>node ID of u (節點編號)<br>parent of u (節點父親)<br>sibling of u (節點兄弟)<br>the number of children of u (節點小孩數目)<br>depth of u (節點深度)<br>height of u (節點高)<br>node type (root, internal node or leaf) (節點狀態)</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="sibling-兄弟"><a href="#sibling-兄弟" class="headerlink" title="sibling 兄弟"></a>sibling 兄弟</h5><p>如果左節點跟右節點都不為-1就代表有兄弟。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tree[id].left != <span class="number">-1</span> &amp;&amp; tree[id].right != <span class="number">-1</span>) &#123;</span><br><span class="line">    tree[left].sibling = right;</span><br><span class="line">    tree[right].sibling = left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="degree-＆-children-parent-子節點個數與子節點父親"><a href="#degree-＆-children-parent-子節點個數與子節點父親" class="headerlink" title="degree ＆ children parent 子節點個數與子節點父親"></a>degree ＆ children parent 子節點個數與子節點父親</h5><p>計算子節點數並順便將子節點的父親標記。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left != <span class="number">-1</span>) &#123;</span><br><span class="line">    tree[id].degree++;</span><br><span class="line">    tree[left].parent = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(right != <span class="number">-1</span>) &#123;</span><br><span class="line">    tree[id].degree++;</span><br><span class="line">    tree[right].parent = id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="height-節點高度"><a href="#height-節點高度" class="headerlink" title="height 節點高度"></a>height 節點高度</h5><p>一直往下找然後比較最大的深度回傳。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Node *tree, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (tree[key].left == <span class="number">-1</span> &amp;&amp; tree[key].right == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree[key].left == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(tree, tree[key].right) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree[key].right == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(tree, tree[key].left) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dfs(tree, tree[key].left), dfs(tree, tree[key].right)) + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="depth-深度"><a href="#depth-深度" class="headerlink" title="depth 深度"></a>depth 深度</h5><p>從根往下並沿路標記深度，深度則是由父親的深度加一就可以得到自己的深度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">depth</span><span class="params">(Node *tree, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[key].parent != <span class="number">-1</span>)&#123; </span><br><span class="line">        tree[key].depth = tree[tree[key].parent].depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[key].left != <span class="number">-1</span>)&#123;</span><br><span class="line">        depth(tree, tree[key].left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[key].right != <span class="number">-1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        depth(tree, tree[key].right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/400e539d787926ef7fc0ef89f881f4a5.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二元樹&quot;&gt;&lt;a href=&quot;#二元樹&quot; class=&quot;headerlink&quot; title=&quot;二元樹&quot;&gt;&lt;/a&gt;二元樹&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;有根的二叉樹是具有根節點的樹，其中每個節點最多有兩個子節點。&lt;/p&gt;
&lt;p&gt;您的任務是編寫一個程序，該程序讀取有根的二叉樹T並為T的每個節點u打印以下信息：&lt;br&gt;node ID of u (節點編號)&lt;br&gt;parent of u (節點父親)&lt;br&gt;sibling of u (節點兄弟)&lt;br&gt;the number of children of u (節點小孩數目)&lt;br&gt;depth of u (節點深度)&lt;br&gt;height of u (節點高)&lt;br&gt;node type (root, internal node or leaf) (節點狀態)&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_7_A - Rooted Trees</title>
    <link href="https://chucs.github.io/ALDS1-7-A-Rooted-Trees/"/>
    <id>https://chucs.github.io/ALDS1-7-A-Rooted-Trees/</id>
    <published>2020-07-15T08:05:42.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="根樹"><a href="#根樹" class="headerlink" title="根樹"></a>根樹</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>Rooted Trees是連接的，無環的，無向的圖。Rooted Trees是一種自由樹，其中一個頂點與另一個頂點是不同的。Rooted Trees的頂點稱為“節點”。<br>你的任務是編寫一個程序，為給定的根樹T的每個節點u報告以下信息：<br>node ID of u (節點編號)<br>parent of u (節點父親)<br>depth of u (節點深度)<br>node type (root, internal node or leaf)<br>a list of chidlren of u (列出節點小孩)</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先創立一個結構parent、depth、type和internalNode方便紀錄我們的資料，接下來我們輸入每筆資料的時候就把自己節點的父親深度加一，就可以得到自己節點的深度，然後在子節點裡面，我們也做一樣的事情然後順便紀錄子節點的父親。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/c3dfdc3026767577257e91a5902bae1d.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;根樹&quot;&gt;&lt;a href=&quot;#根樹&quot; class=&quot;headerlink&quot; title=&quot;根樹&quot;&gt;&lt;/a&gt;根樹&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;Rooted Trees是連接的，無環的，無向的圖。Rooted Trees是一種自由樹，其中一個頂點與另一個頂點是不同的。Rooted Trees的頂點稱為“節點”。&lt;br&gt;你的任務是編寫一個程序，為給定的根樹T的每個節點u報告以下信息：&lt;br&gt;node ID of u (節點編號)&lt;br&gt;parent of u (節點父親)&lt;br&gt;depth of u (節點深度)&lt;br&gt;node type (root, internal node or leaf)&lt;br&gt;a list of chidlren of u (列出節點小孩)&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_6_C - Quick Sort</title>
    <link href="https://chucs.github.io/ALDS1-6-C-Quick-Sort/"/>
    <id>https://chucs.github.io/ALDS1-6-C-Quick-Sort/</id>
    <published>2020-07-15T06:36:48.000Z</published>
    <updated>2020-08-11T06:21:55.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>快速排序有三個步驟：<br>1.挑選基準值：從數列中挑出一個元素，稱為「基準」（pivot)。</p><p>2.分割：重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面（與基準值相等的數可以到任何一邊）。在這個分割結束之後，對基準值的排序就已經完成。</p><p>3.遞迴排序子序列：遞迴地將小於基準值元素的子序列和大於基準值元素的子序列排序。</p><p>完成排序後檢查出現順序是否依照順序，例如先輸入”D 1”、”H 1”，輸出時若為”D 1”、”H 1”就輸出”Stable”，否則輸出”Not stable”。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>按照上面快速排序的步驟編寫。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/b1de01e5346182490fa59fec396ecd2c.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;快速排序有三個步驟：&lt;br&gt;1.挑選基準值：從數列中挑出一個元素，稱為「基準」（pivot)。&lt;/p&gt;
&lt;p&gt;2.分割：重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面（與基準值相等的數可以到任何一邊）。在這個分割結束之後，對基準值的排序就已經完成。&lt;/p&gt;
&lt;p&gt;3.遞迴排序子序列：遞迴地將小於基準值元素的子序列和大於基準值元素的子序列排序。&lt;/p&gt;
&lt;p&gt;完成排序後檢查出現順序是否依照順序，例如先輸入”D 1”、”H 1”，輸出時若為”D 1”、”H 1”就輸出”Stable”，否則輸出”Not stable”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_6_B - Partition</title>
    <link href="https://chucs.github.io/ALDS1-6-B-Partition/"/>
    <id>https://chucs.github.io/ALDS1-6-B-Partition/</id>
    <published>2020-07-15T06:26:38.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序劃分"><a href="#快速排序劃分" class="headerlink" title="快速排序劃分"></a>快速排序劃分</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>快速排序有三個步驟：<br>1.挑選基準值：從數列中挑出一個元素，稱為「基準」（pivot）。</p><p>2.分割：重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面（與基準值相等的數可以到任何一邊）。在這個分割結束之後，對基準值的排序就已經完成。</p><p>3.遞迴排序子序列：遞迴地將小於基準值元素的子序列和大於基準值元素的子序列排序。</p><p>而這題要做的就是分割這個動作。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>如果(a[j] &lt;= x)我們就交換，最後我們將最後一個切割點輸出。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/2b61bf149936044aab2d398c8496b1b3.js"></script>    ]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快速排序劃分&quot;&gt;&lt;a href=&quot;#快速排序劃分&quot; class=&quot;headerlink&quot; title=&quot;快速排序劃分&quot;&gt;&lt;/a&gt;快速排序劃分&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;快速排序有三個步驟：&lt;br&gt;1.挑選基準值：從數列中挑出一個元素，稱為「基準」（pivot）。&lt;/p&gt;
&lt;p&gt;2.分割：重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面（與基準值相等的數可以到任何一邊）。在這個分割結束之後，對基準值的排序就已經完成。&lt;/p&gt;
&lt;p&gt;3.遞迴排序子序列：遞迴地將小於基準值元素的子序列和大於基準值元素的子序列排序。&lt;/p&gt;
&lt;p&gt;而這題要做的就是分割這個動作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_6_A - Counting Sort</title>
    <link href="https://chucs.github.io/ALDS1-6-A-Counting-Sort/"/>
    <id>https://chucs.github.io/ALDS1-6-A-Counting-Sort/</id>
    <published>2020-07-15T05:33:29.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>計數排序可用於對數組中的元素進行排序，用一個陣列來計算元素有幾個，而他的index就是原本的數字裡面存的是出現次數。請利用計數排序排序下列數列。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>將每個數字都放進Ｃ陣列內計數(c[a[i]]++)，處理完後從0跑到K並根據C陣列內的計數，將所有的數字輸出一遍。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/245397223969f64944326fb98f0b1e80.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;索引排序&quot;&gt;&lt;a href=&quot;#索引排序&quot; class=&quot;headerlink&quot; title=&quot;索引排序&quot;&gt;&lt;/a&gt;索引排序&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;計數排序可用於對數組中的元素進行排序，用一個陣列來計算元素有幾個，而他的index就是原本的數字裡面存的是出現次數。請利用計數排序排序下列數列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_5_B - Merge Sort</title>
    <link href="https://chucs.github.io/ALDS1-5-B-Merge-Sort/"/>
    <id>https://chucs.github.io/ALDS1-5-B-Merge-Sort/</id>
    <published>2020-07-15T04:39:23.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合併排序"><a href="#合併排序" class="headerlink" title="合併排序"></a>合併排序</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_5_B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>給你N個整數序列S創建一個程序，根據上面的虛擬碼通過合併排序由小到大進行排序。另外，請報告合併中的比較總數。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先拆開然後檢查左邊和右邊誰大誰小，小的放左邊大的放右邊合併，重複這個動作到結束。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/86ace3aedb574bee48d1a7869cca847c.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;合併排序&quot;&gt;&lt;a href=&quot;#合併排序&quot; class=&quot;headerlink&quot; title=&quot;合併排序&quot;&gt;&lt;/a&gt;合併排序&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_5_B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;給你N個整數序列S創建一個程序，根據上面的虛擬碼通過合併排序由小到大進行排序。另外，請報告合併中的比較總數。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_5_A - Exhaustive Search</title>
    <link href="https://chucs.github.io/ALDS1-5-A-Exhaustive-Search/"/>
    <id>https://chucs.github.io/ALDS1-5-A-Exhaustive-Search/</id>
    <published>2020-07-14T08:13:31.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全面搜索"><a href="#全面搜索" class="headerlink" title="全面搜索"></a>全面搜索</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_5_A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>給N個整數數列A，Q個整數數列M，判斷A任意數字加起來是否等於Mi，如果有輸出”yes”，否則輸出”no”。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>直接建一張查詢表把所有的可能加一遍並修改，之後直接查表。<br>累加後遞迴然後把位子移動到下一個數字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build(sum+a[index], index+<span class="number">1</span>, n);</span><br></pre></td></tr></table></figure><p>把自己也改變。<br>build(sum, index+1, n);</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/ca85b1798c3535457231e0d3a4c645e9.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;全面搜索&quot;&gt;&lt;a href=&quot;#全面搜索&quot; class=&quot;headerlink&quot; title=&quot;全面搜索&quot;&gt;&lt;/a&gt;全面搜索&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_5_A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;給N個整數數列A，Q個整數數列M，判斷A任意數字加起來是否等於Mi，如果有輸出”yes”，否則輸出”no”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_4_C - Dictionary</title>
    <link href="https://chucs.github.io/ALDS1-4-C-Dictionary/"/>
    <id>https://chucs.github.io/ALDS1-4-C-Dictionary/</id>
    <published>2020-07-14T06:51:04.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>寫一個具備以下功能的字典程式:<br>insert str: 插入一個字串到字典裡。<br>find str: 找尋字串如果找到輸出”yes”，否則”no”。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>利用C++的map函式來加入，使用find的功能來查詢，如果沒找會輸出0，所以我們就可以放在判斷式裡面做判斷。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/0e68ebaec599b3a3b31c9e84fbac8840.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;寫一個具備以下功能的字典程式:&lt;br&gt;insert str: 插入一個字串到字典裡。&lt;br&gt;find str: 找尋字串如果找到輸出”yes”，否則”no”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_4_B - Binary Search</title>
    <link href="https://chucs.github.io/ALDS1-4-B-Binary-Search/"/>
    <id>https://chucs.github.io/ALDS1-4-B-Binary-Search/</id>
    <published>2020-07-14T05:24:03.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>給N個整數數列S，還有q個整數數列T，請輸出T在S裡面有找到幾個。利用二分搜索來尋找。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>宣告三個變數分別紀錄左邊、右邊和中間位置，每次判斷中間那個數字是否等於要找的數字，如果沒有則判斷大於小於以利切割，如果大於的話就把r換成中間的位置，小於則把l換成中間的位置。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/b7e47a957066b3bb5888030be0aac43f.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分搜索&quot;&gt;&lt;a href=&quot;#二分搜索&quot; class=&quot;headerlink&quot; title=&quot;二分搜索&quot;&gt;&lt;/a&gt;二分搜索&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;給N個整數數列S，還有q個整數數列T，請輸出T在S裡面有找到幾個。利用二分搜索來尋找。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_4_A - Linear Search</title>
    <link href="https://chucs.github.io/ALDS1-4-A-Linear-Search/"/>
    <id>https://chucs.github.io/ALDS1-4-A-Linear-Search/</id>
    <published>2020-07-14T04:39:48.000Z</published>
    <updated>2020-08-11T06:18:59.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="線性排序"><a href="#線性排序" class="headerlink" title="線性排序"></a>線性排序</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>給N個整數數列S，還有q個整數數列T，請輸出T在S裡面有找到幾個。利用線性搜索來尋找。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>逐一檢查，如果相等count加一然後斷開避免重複加到。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/be27322df4e6cf323429cc22b66ebcd3.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;線性排序&quot;&gt;&lt;a href=&quot;#線性排序&quot; class=&quot;headerlink&quot; title=&quot;線性排序&quot;&gt;&lt;/a&gt;線性排序&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;給N個整數數列S，還有q個整數數列T，請輸出T在S裡面有找到幾個。利用線性搜索來尋找。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
</feed>
