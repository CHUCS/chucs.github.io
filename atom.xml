<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHUCSIE</title>
  
  <subtitle>解題報告</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chucs.github.io/"/>
  <updated>2020-09-23T06:09:43.338Z</updated>
  <id>https://chucs.github.io/</id>
  
  <author>
    <name>CHUCSIE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CodeForces 1418B</title>
    <link href="https://chucs.github.io/Negative-Prefixes/"/>
    <id>https://chucs.github.io/Negative-Prefixes/</id>
    <published>2020-09-22T14:52:31.000Z</published>
    <updated>2020-09-23T06:09:43.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodeForces-1418B-Negative-Prefixes"><a href="#CodeForces-1418B-Negative-Prefixes" class="headerlink" title="CodeForces 1418B - Negative Prefixes"></a>CodeForces 1418B - Negative Prefixes</h1><p><a href="https://codeforces.com/problemset/problem/1418/B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>你有一個陣列a，裡面有n個整數，有些整數被鎖住有些沒有，你能對沒有鎖住的整數做交換位置的動作(沒鎖對沒鎖)，另外有個序列p，為a<sub>1</sub>~a<sub>n</sub>的總和:p<sub>1</sub> = a<sub>1</sub>, p<sub>2</sub> = a<sub>1</sub> + a<sub>2</sub>… p<sub>n</sub> = a<sub>1</sub> + a<sub>2</sub> +…+ a<sub>n</sub><br>讓k為最大值j，並且p<sub>j</sub> &lt; 0 ，若p中沒有任何p<sub>j</sub> &lt; 0，則 k=0<br>你要交換未鎖住整數的位置，使得k為最小值，印出調整過後的陣列a</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>將沒鎖住的整數獨立出來，由大到小排序，再依序從頭一一放回陣列中沒鎖住的位置。<br>不考慮鎖住的數字，當正整數總和 &gt;= 負整數總和時，將正整數排前面則k=0<br>當正整數總和 &lt; 負整數總和時，則不管甚麼順序k最大<br>不選擇小排到大是因為第一個狀況，若負整數先在前面則k值不會最小</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/14bcb2bffc5c9b8cd2341a8758f78b47.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CodeForces-1418B-Negative-Prefixes&quot;&gt;&lt;a href=&quot;#CodeForces-1418B-Negative-Prefixes&quot; class=&quot;headerlink&quot; title=&quot;CodeForces 1418B - Negative Prefixes&quot;&gt;&lt;/a&gt;CodeForces 1418B - Negative Prefixes&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1418/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;你有一個陣列a，裡面有n個整數，有些整數被鎖住有些沒有，你能對沒有鎖住的整數做交換位置的動作(沒鎖對沒鎖)，另外有個序列p，為a&lt;sub&gt;1&lt;/sub&gt;~a&lt;sub&gt;n&lt;/sub&gt;的總和:p&lt;sub&gt;1&lt;/sub&gt; = a&lt;sub&gt;1&lt;/sub&gt;, p&lt;sub&gt;2&lt;/sub&gt; = a&lt;sub&gt;1&lt;/sub&gt; + a&lt;sub&gt;2&lt;/sub&gt;… p&lt;sub&gt;n&lt;/sub&gt; = a&lt;sub&gt;1&lt;/sub&gt; + a&lt;sub&gt;2&lt;/sub&gt; +…+ a&lt;sub&gt;n&lt;/sub&gt;&lt;br&gt;讓k為最大值j，並且p&lt;sub&gt;j&lt;/sub&gt; &amp;lt; 0 ，若p中沒有任何p&lt;sub&gt;j&lt;/sub&gt; &amp;lt; 0，則 k=0&lt;br&gt;你要交換未鎖住整數的位置，使得k為最小值，印出調整過後的陣列a&lt;/p&gt;
    
    </summary>
    
    
      <category term="CodeForces" scheme="https://chucs.github.io/categories/CodeForces/"/>
    
    
      <category term="sortings" scheme="https://chucs.github.io/tags/sortings/"/>
    
      <category term="greedy" scheme="https://chucs.github.io/tags/greedy/"/>
    
      <category term="1300" scheme="https://chucs.github.io/tags/1300/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1418A</title>
    <link href="https://chucs.github.io/Buying-Torches/"/>
    <id>https://chucs.github.io/Buying-Torches/</id>
    <published>2020-09-22T14:51:35.000Z</published>
    <updated>2020-09-23T06:09:43.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodeForces-1418A-Buying-Torches"><a href="#CodeForces-1418A-Buying-Torches" class="headerlink" title="CodeForces 1418A - Buying Torches"></a>CodeForces 1418A - Buying Torches</h1><p><a href="https://codeforces.com/problemset/problem/1418/A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>你玩遊戲想要製作k個火把，每個火把需要一根棒子和一個煤炭，一開始你只有一根棒子,你能跟商人做兩種交易:<br>    1.用一根棒子交換x根棒子<br>    2.用y根棒子交換一個煤炭<br>每次只能做其中一種交易，請問你需要k個火把「最少」需要幾次交易? (測資必存在解答)</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>數學問題，幾個煤炭就需要交易幾次，並且煤炭等於y根棒子，所以交易次數=到達所需棒子量的交易次數+換煤炭的次數。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/fce4c025b50df9f1982acbd833a09d91.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CodeForces-1418A-Buying-Torches&quot;&gt;&lt;a href=&quot;#CodeForces-1418A-Buying-Torches&quot; class=&quot;headerlink&quot; title=&quot;CodeForces 1418A - Buying Torches&quot;&gt;&lt;/a&gt;CodeForces 1418A - Buying Torches&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1418/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;你玩遊戲想要製作k個火把，每個火把需要一根棒子和一個煤炭，一開始你只有一根棒子,你能跟商人做兩種交易:&lt;br&gt;    1.用一根棒子交換x根棒子&lt;br&gt;    2.用y根棒子交換一個煤炭&lt;br&gt;每次只能做其中一種交易，請問你需要k個火把「最少」需要幾次交易? (測資必存在解答)&lt;/p&gt;
    
    </summary>
    
    
      <category term="CodeForces" scheme="https://chucs.github.io/categories/CodeForces/"/>
    
    
      <category term="math" scheme="https://chucs.github.io/tags/math/"/>
    
      <category term="1000" scheme="https://chucs.github.io/tags/1000/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_8_C - Binary Search Tree III</title>
    <link href="https://chucs.github.io/ALDS1-8-C-Binary-Search-Tree-III/"/>
    <id>https://chucs.github.io/ALDS1-8-C-Binary-Search-Tree-III/</id>
    <published>2020-08-24T05:45:44.000Z</published>
    <updated>2020-09-08T12:13:58.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二元樹搜索-刪除"><a href="#二元樹搜索-刪除" class="headerlink" title="二元樹搜索 - 刪除"></a>二元樹搜索 - 刪除</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>編程一個擁有新增、查詢、刪除功能的二元樹，在每次新增點時，如果key大於node-&gt;key，就新增在node-&gt;right，否則新增在node-&gt;left。最後輸出Preorder與Inorder。</p><a id="more"></a><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/e5a835cfa1a3f511e096388e9697423c.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二元樹搜索-刪除&quot;&gt;&lt;a href=&quot;#二元樹搜索-刪除&quot; class=&quot;headerlink&quot; title=&quot;二元樹搜索 - 刪除&quot;&gt;&lt;/a&gt;二元樹搜索 - 刪除&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;編程一個擁有新增、查詢、刪除功能的二元樹，在每次新增點時，如果key大於node-&amp;gt;key，就新增在node-&amp;gt;right，否則新增在node-&amp;gt;left。最後輸出Preorder與Inorder。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_8_B - Binary Search Tree II</title>
    <link href="https://chucs.github.io/ALDS1-8-B-Binary-Search-Tree-II/"/>
    <id>https://chucs.github.io/ALDS1-8-B-Binary-Search-Tree-II/</id>
    <published>2020-08-24T05:45:33.000Z</published>
    <updated>2020-09-08T12:13:55.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二元樹搜索-查詢"><a href="#二元樹搜索-查詢" class="headerlink" title="二元樹搜索 - 查詢"></a>二元樹搜索 - 查詢</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node-&gt;key，就新增在node-&gt;right，否則新增在node-&gt;left。最後輸出Preorder與Inorder。</p><a id="more"></a><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/64cf5d826826134e302151c569adb7d8.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二元樹搜索-查詢&quot;&gt;&lt;a href=&quot;#二元樹搜索-查詢&quot; class=&quot;headerlink&quot; title=&quot;二元樹搜索 - 查詢&quot;&gt;&lt;/a&gt;二元樹搜索 - 查詢&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node-&amp;gt;key，就新增在node-&amp;gt;right，否則新增在node-&amp;gt;left。最後輸出Preorder與Inorder。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_8_A - Binary Search Tree I</title>
    <link href="https://chucs.github.io/ALDS1-8-A-Binary-Search-Tree-I/"/>
    <id>https://chucs.github.io/ALDS1-8-A-Binary-Search-Tree-I/</id>
    <published>2020-08-24T05:45:19.000Z</published>
    <updated>2020-09-08T12:13:52.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二元樹搜索-新增"><a href="#二元樹搜索-新增" class="headerlink" title="二元樹搜索 - 新增"></a>二元樹搜索 - 新增</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node-&gt;key，就新增在node-&gt;right，否則新增在node-&gt;left。最後輸出Preorder與Inorder。</p><a id="more"></a><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/f392df5b2c8130b6eeff6a0b8c1b82bb.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二元樹搜索-新增&quot;&gt;&lt;a href=&quot;#二元樹搜索-新增&quot; class=&quot;headerlink&quot; title=&quot;二元樹搜索 - 新增&quot;&gt;&lt;/a&gt;二元樹搜索 - 新增&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node-&amp;gt;key，就新增在node-&amp;gt;right，否則新增在node-&amp;gt;left。最後輸出Preorder與Inorder。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_7_C - Tree Walk</title>
    <link href="https://chucs.github.io/ALDS1-7-C-Tree-Walk/"/>
    <id>https://chucs.github.io/ALDS1-7-C-Tree-Walk/</id>
    <published>2020-08-11T04:55:23.000Z</published>
    <updated>2020-08-24T05:54:23.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="樹遍歷"><a href="#樹遍歷" class="headerlink" title="樹遍歷"></a>樹遍歷</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>您的任務是編寫一個程序，該程序根據以下算法執行樹遍歷（系統遍歷樹中的所有例程）：</p><ol><li>根、左子樹和右子樹(preorder)。</li><li>左子樹、根子樹和右子樹(inorder)。</li><li>左子樹、右子樹和根(postorder)。</li></ol><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>創建一個結構left代表左子樹，right代表右子樹，pr代表父節點用於檢查是否為跟節點。</p><p>創建一個帶有結構的陣列依序填入所有值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; key &gt;&gt; left &gt;&gt; right;</span><br><span class="line">    </span><br><span class="line">    tree[key].left = left;</span><br><span class="line">    tree[key].right = right;</span><br><span class="line">    tree[left].pr = key;</span><br><span class="line">    tree[right].pr = key;</span><br><span class="line">    node[i] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著尋找父節點，輸入的所有節點檢查pr為-1就是父節點。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRoot</span><span class="params">(Node* tree, <span class="keyword">int</span> *node, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[node[i]].pr == <span class="number">-1</span>)&#123;</span><br><span class="line">            root = node[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後利用題目上敘的規則遞迴輸出。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/b95063f99f1a85b8b827f35fe13c2c35.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;樹遍歷&quot;&gt;&lt;a href=&quot;#樹遍歷&quot; class=&quot;headerlink&quot; title=&quot;樹遍歷&quot;&gt;&lt;/a&gt;樹遍歷&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;您的任務是編寫一個程序，該程序根據以下算法執行樹遍歷（系統遍歷樹中的所有例程）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根、左子樹和右子樹(preorder)。&lt;/li&gt;
&lt;li&gt;左子樹、根子樹和右子樹(inorder)。&lt;/li&gt;
&lt;li&gt;左子樹、右子樹和根(postorder)。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_7_B - Binary Tree</title>
    <link href="https://chucs.github.io/ALDS1-7-B-Binary-Tree/"/>
    <id>https://chucs.github.io/ALDS1-7-B-Binary-Tree/</id>
    <published>2020-07-18T07:53:01.000Z</published>
    <updated>2020-08-11T06:22:55.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二元樹"><a href="#二元樹" class="headerlink" title="二元樹"></a>二元樹</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>有根的二叉樹是具有根節點的樹，其中每個節點最多有兩個子節點。</p><p>您的任務是編寫一個程序，該程序讀取有根的二叉樹T並為T的每個節點u打印以下信息：<br>node ID of u (節點編號)<br>parent of u (節點父親)<br>sibling of u (節點兄弟)<br>the number of children of u (節點小孩數目)<br>depth of u (節點深度)<br>height of u (節點高)<br>node type (root, internal node or leaf) (節點狀態)</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="sibling-兄弟"><a href="#sibling-兄弟" class="headerlink" title="sibling 兄弟"></a>sibling 兄弟</h5><p>如果左節點跟右節點都不為-1就代表有兄弟。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tree[id].left != <span class="number">-1</span> &amp;&amp; tree[id].right != <span class="number">-1</span>) &#123;</span><br><span class="line">    tree[left].sibling = right;</span><br><span class="line">    tree[right].sibling = left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="degree-＆-children-parent-子節點個數與子節點父親"><a href="#degree-＆-children-parent-子節點個數與子節點父親" class="headerlink" title="degree ＆ children parent 子節點個數與子節點父親"></a>degree ＆ children parent 子節點個數與子節點父親</h5><p>計算子節點數並順便將子節點的父親標記。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left != <span class="number">-1</span>) &#123;</span><br><span class="line">    tree[id].degree++;</span><br><span class="line">    tree[left].parent = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(right != <span class="number">-1</span>) &#123;</span><br><span class="line">    tree[id].degree++;</span><br><span class="line">    tree[right].parent = id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="height-節點高度"><a href="#height-節點高度" class="headerlink" title="height 節點高度"></a>height 節點高度</h5><p>一直往下找然後比較最大的深度回傳。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Node *tree, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (tree[key].left == <span class="number">-1</span> &amp;&amp; tree[key].right == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree[key].left == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(tree, tree[key].right) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree[key].right == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(tree, tree[key].left) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dfs(tree, tree[key].left), dfs(tree, tree[key].right)) + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="depth-深度"><a href="#depth-深度" class="headerlink" title="depth 深度"></a>depth 深度</h5><p>從根往下並沿路標記深度，深度則是由父親的深度加一就可以得到自己的深度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">depth</span><span class="params">(Node *tree, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[key].parent != <span class="number">-1</span>)&#123; </span><br><span class="line">        tree[key].depth = tree[tree[key].parent].depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[key].left != <span class="number">-1</span>)&#123;</span><br><span class="line">        depth(tree, tree[key].left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[key].right != <span class="number">-1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        depth(tree, tree[key].right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/400e539d787926ef7fc0ef89f881f4a5.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二元樹&quot;&gt;&lt;a href=&quot;#二元樹&quot; class=&quot;headerlink&quot; title=&quot;二元樹&quot;&gt;&lt;/a&gt;二元樹&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;有根的二叉樹是具有根節點的樹，其中每個節點最多有兩個子節點。&lt;/p&gt;
&lt;p&gt;您的任務是編寫一個程序，該程序讀取有根的二叉樹T並為T的每個節點u打印以下信息：&lt;br&gt;node ID of u (節點編號)&lt;br&gt;parent of u (節點父親)&lt;br&gt;sibling of u (節點兄弟)&lt;br&gt;the number of children of u (節點小孩數目)&lt;br&gt;depth of u (節點深度)&lt;br&gt;height of u (節點高)&lt;br&gt;node type (root, internal node or leaf) (節點狀態)&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_7_A - Rooted Trees</title>
    <link href="https://chucs.github.io/ALDS1-7-A-Rooted-Trees/"/>
    <id>https://chucs.github.io/ALDS1-7-A-Rooted-Trees/</id>
    <published>2020-07-15T08:05:42.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="根樹"><a href="#根樹" class="headerlink" title="根樹"></a>根樹</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>Rooted Trees是連接的，無環的，無向的圖。Rooted Trees是一種自由樹，其中一個頂點與另一個頂點是不同的。Rooted Trees的頂點稱為“節點”。<br>你的任務是編寫一個程序，為給定的根樹T的每個節點u報告以下信息：<br>node ID of u (節點編號)<br>parent of u (節點父親)<br>depth of u (節點深度)<br>node type (root, internal node or leaf)<br>a list of chidlren of u (列出節點小孩)</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先創立一個結構parent、depth、type和internalNode方便紀錄我們的資料，接下來我們輸入每筆資料的時候就把自己節點的父親深度加一，就可以得到自己節點的深度，然後在子節點裡面，我們也做一樣的事情然後順便紀錄子節點的父親。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/c3dfdc3026767577257e91a5902bae1d.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;根樹&quot;&gt;&lt;a href=&quot;#根樹&quot; class=&quot;headerlink&quot; title=&quot;根樹&quot;&gt;&lt;/a&gt;根樹&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;Rooted Trees是連接的，無環的，無向的圖。Rooted Trees是一種自由樹，其中一個頂點與另一個頂點是不同的。Rooted Trees的頂點稱為“節點”。&lt;br&gt;你的任務是編寫一個程序，為給定的根樹T的每個節點u報告以下信息：&lt;br&gt;node ID of u (節點編號)&lt;br&gt;parent of u (節點父親)&lt;br&gt;depth of u (節點深度)&lt;br&gt;node type (root, internal node or leaf)&lt;br&gt;a list of chidlren of u (列出節點小孩)&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_6_C - Quick Sort</title>
    <link href="https://chucs.github.io/ALDS1-6-C-Quick-Sort/"/>
    <id>https://chucs.github.io/ALDS1-6-C-Quick-Sort/</id>
    <published>2020-07-15T06:36:48.000Z</published>
    <updated>2020-08-11T06:21:55.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>快速排序有三個步驟：<br>1.挑選基準值：從數列中挑出一個元素，稱為「基準」（pivot)。</p><p>2.分割：重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面（與基準值相等的數可以到任何一邊）。在這個分割結束之後，對基準值的排序就已經完成。</p><p>3.遞迴排序子序列：遞迴地將小於基準值元素的子序列和大於基準值元素的子序列排序。</p><p>完成排序後檢查出現順序是否依照順序，例如先輸入”D 1”、”H 1”，輸出時若為”D 1”、”H 1”就輸出”Stable”，否則輸出”Not stable”。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>按照上面快速排序的步驟編寫。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/b1de01e5346182490fa59fec396ecd2c.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;快速排序有三個步驟：&lt;br&gt;1.挑選基準值：從數列中挑出一個元素，稱為「基準」（pivot)。&lt;/p&gt;
&lt;p&gt;2.分割：重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面（與基準值相等的數可以到任何一邊）。在這個分割結束之後，對基準值的排序就已經完成。&lt;/p&gt;
&lt;p&gt;3.遞迴排序子序列：遞迴地將小於基準值元素的子序列和大於基準值元素的子序列排序。&lt;/p&gt;
&lt;p&gt;完成排序後檢查出現順序是否依照順序，例如先輸入”D 1”、”H 1”，輸出時若為”D 1”、”H 1”就輸出”Stable”，否則輸出”Not stable”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_6_B - Partition</title>
    <link href="https://chucs.github.io/ALDS1-6-B-Partition/"/>
    <id>https://chucs.github.io/ALDS1-6-B-Partition/</id>
    <published>2020-07-15T06:26:38.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序劃分"><a href="#快速排序劃分" class="headerlink" title="快速排序劃分"></a>快速排序劃分</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>快速排序有三個步驟：<br>1.挑選基準值：從數列中挑出一個元素，稱為「基準」（pivot）。</p><p>2.分割：重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面（與基準值相等的數可以到任何一邊）。在這個分割結束之後，對基準值的排序就已經完成。</p><p>3.遞迴排序子序列：遞迴地將小於基準值元素的子序列和大於基準值元素的子序列排序。</p><p>而這題要做的就是分割這個動作。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>如果(a[j] &lt;= x)我們就交換，最後我們將最後一個切割點輸出。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/2b61bf149936044aab2d398c8496b1b3.js"></script>    ]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快速排序劃分&quot;&gt;&lt;a href=&quot;#快速排序劃分&quot; class=&quot;headerlink&quot; title=&quot;快速排序劃分&quot;&gt;&lt;/a&gt;快速排序劃分&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;快速排序有三個步驟：&lt;br&gt;1.挑選基準值：從數列中挑出一個元素，稱為「基準」（pivot）。&lt;/p&gt;
&lt;p&gt;2.分割：重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面（與基準值相等的數可以到任何一邊）。在這個分割結束之後，對基準值的排序就已經完成。&lt;/p&gt;
&lt;p&gt;3.遞迴排序子序列：遞迴地將小於基準值元素的子序列和大於基準值元素的子序列排序。&lt;/p&gt;
&lt;p&gt;而這題要做的就是分割這個動作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_6_A - Counting Sort</title>
    <link href="https://chucs.github.io/ALDS1-6-A-Counting-Sort/"/>
    <id>https://chucs.github.io/ALDS1-6-A-Counting-Sort/</id>
    <published>2020-07-15T05:33:29.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>計數排序可用於對數組中的元素進行排序，用一個陣列來計算元素有幾個，而他的index就是原本的數字裡面存的是出現次數。請利用計數排序排序下列數列。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>將每個數字都放進Ｃ陣列內計數(c[a[i]]++)，處理完後從0跑到K並根據C陣列內的計數，將所有的數字輸出一遍。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/245397223969f64944326fb98f0b1e80.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;索引排序&quot;&gt;&lt;a href=&quot;#索引排序&quot; class=&quot;headerlink&quot; title=&quot;索引排序&quot;&gt;&lt;/a&gt;索引排序&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;計數排序可用於對數組中的元素進行排序，用一個陣列來計算元素有幾個，而他的index就是原本的數字裡面存的是出現次數。請利用計數排序排序下列數列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_5_B - Merge Sort</title>
    <link href="https://chucs.github.io/ALDS1-5-B-Merge-Sort/"/>
    <id>https://chucs.github.io/ALDS1-5-B-Merge-Sort/</id>
    <published>2020-07-15T04:39:23.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合併排序"><a href="#合併排序" class="headerlink" title="合併排序"></a>合併排序</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_5_B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>給你N個整數序列S創建一個程序，根據上面的虛擬碼通過合併排序由小到大進行排序。另外，請報告合併中的比較總數。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先拆開然後檢查左邊和右邊誰大誰小，小的放左邊大的放右邊合併，重複這個動作到結束。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/86ace3aedb574bee48d1a7869cca847c.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;合併排序&quot;&gt;&lt;a href=&quot;#合併排序&quot; class=&quot;headerlink&quot; title=&quot;合併排序&quot;&gt;&lt;/a&gt;合併排序&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_5_B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;給你N個整數序列S創建一個程序，根據上面的虛擬碼通過合併排序由小到大進行排序。另外，請報告合併中的比較總數。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_5_A - Exhaustive Search</title>
    <link href="https://chucs.github.io/ALDS1-5-A-Exhaustive-Search/"/>
    <id>https://chucs.github.io/ALDS1-5-A-Exhaustive-Search/</id>
    <published>2020-07-14T08:13:31.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全面搜索"><a href="#全面搜索" class="headerlink" title="全面搜索"></a>全面搜索</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_5_A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>給N個整數數列A，Q個整數數列M，判斷A任意數字加起來是否等於Mi，如果有輸出”yes”，否則輸出”no”。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>直接建一張查詢表把所有的可能加一遍並修改，之後直接查表。<br>累加後遞迴然後把位子移動到下一個數字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build(sum+a[index], index+<span class="number">1</span>, n);</span><br></pre></td></tr></table></figure><p>把自己也改變。<br>build(sum, index+1, n);</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/ca85b1798c3535457231e0d3a4c645e9.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;全面搜索&quot;&gt;&lt;a href=&quot;#全面搜索&quot; class=&quot;headerlink&quot; title=&quot;全面搜索&quot;&gt;&lt;/a&gt;全面搜索&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_5_A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;給N個整數數列A，Q個整數數列M，判斷A任意數字加起來是否等於Mi，如果有輸出”yes”，否則輸出”no”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_4_C - Dictionary</title>
    <link href="https://chucs.github.io/ALDS1-4-C-Dictionary/"/>
    <id>https://chucs.github.io/ALDS1-4-C-Dictionary/</id>
    <published>2020-07-14T06:51:04.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>寫一個具備以下功能的字典程式:<br>insert str: 插入一個字串到字典裡。<br>find str: 找尋字串如果找到輸出”yes”，否則”no”。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>利用C++的map函式來加入，使用find的功能來查詢，如果沒找會輸出0，所以我們就可以放在判斷式裡面做判斷。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/0e68ebaec599b3a3b31c9e84fbac8840.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;寫一個具備以下功能的字典程式:&lt;br&gt;insert str: 插入一個字串到字典裡。&lt;br&gt;find str: 找尋字串如果找到輸出”yes”，否則”no”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_4_B - Binary Search</title>
    <link href="https://chucs.github.io/ALDS1-4-B-Binary-Search/"/>
    <id>https://chucs.github.io/ALDS1-4-B-Binary-Search/</id>
    <published>2020-07-14T05:24:03.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>給N個整數數列S，還有q個整數數列T，請輸出T在S裡面有找到幾個。利用二分搜索來尋找。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>宣告三個變數分別紀錄左邊、右邊和中間位置，每次判斷中間那個數字是否等於要找的數字，如果沒有則判斷大於小於以利切割，如果大於的話就把r換成中間的位置，小於則把l換成中間的位置。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/b7e47a957066b3bb5888030be0aac43f.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分搜索&quot;&gt;&lt;a href=&quot;#二分搜索&quot; class=&quot;headerlink&quot; title=&quot;二分搜索&quot;&gt;&lt;/a&gt;二分搜索&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;給N個整數數列S，還有q個整數數列T，請輸出T在S裡面有找到幾個。利用二分搜索來尋找。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_4_A - Linear Search</title>
    <link href="https://chucs.github.io/ALDS1-4-A-Linear-Search/"/>
    <id>https://chucs.github.io/ALDS1-4-A-Linear-Search/</id>
    <published>2020-07-14T04:39:48.000Z</published>
    <updated>2020-08-11T06:18:59.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="線性排序"><a href="#線性排序" class="headerlink" title="線性排序"></a>線性排序</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>給N個整數數列S，還有q個整數數列T，請輸出T在S裡面有找到幾個。利用線性搜索來尋找。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>逐一檢查，如果相等count加一然後斷開避免重複加到。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/be27322df4e6cf323429cc22b66ebcd3.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;線性排序&quot;&gt;&lt;a href=&quot;#線性排序&quot; class=&quot;headerlink&quot; title=&quot;線性排序&quot;&gt;&lt;/a&gt;線性排序&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;給N個整數數列S，還有q個整數數列T，請輸出T在S裡面有找到幾個。利用線性搜索來尋找。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI Stack</title>
    <link href="https://chucs.github.io/swiftui-stack/"/>
    <id>https://chucs.github.io/swiftui-stack/</id>
    <published>2020-07-14T04:04:13.000Z</published>
    <updated>2020-08-09T12:42:15.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SwiftUI-Stack-堆疊方式"><a href="#SwiftUI-Stack-堆疊方式" class="headerlink" title="SwiftUI Stack 堆疊方式"></a>SwiftUI Stack 堆疊方式</h1><p>在SwiftUI中有三種堆疊分別為VStack、ZStack和HStack，這些堆疊可以讓顯示的東西以不同的方式呈現。</p><a id="more"></a><h2 id="VStack-縱向堆疊"><a href="#VStack-縱向堆疊" class="headerlink" title="VStack 縱向堆疊"></a>VStack 縱向堆疊</h2><p>VStack可以使文字逐一縱向的堆疊。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span>() &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello"</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"SwiftUI"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顯示的結果為：<br>Hello<br>SwiftUI</p><h2 id="HStack-橫向堆疊"><a href="#HStack-橫向堆疊" class="headerlink" title="HStack 橫向堆疊"></a>HStack 橫向堆疊</h2><p>HStack可以使文字逐一橫向的堆疊。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span>() &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello"</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"SwiftUI"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顯示的結果為：<br>Hello SwiftUI</p><h2 id="ZStack-重疊"><a href="#ZStack-重疊" class="headerlink" title="ZStack 重疊"></a>ZStack 重疊</h2><p>HStack可以使文字重疊。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZStack</span>() &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello"</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"SwiftUI !!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="alignment與spacing-校準與間距"><a href="#alignment與spacing-校準與間距" class="headerlink" title="alignment與spacing 校準與間距"></a>alignment與spacing 校準與間距</h2><p>alignment可以控制校準的位置，你可以把VStack內的東西靠左靠右等等等…。spacing可以控制每個區塊距離。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span>(alignment: .leading, spacing: <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello"</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"SwiftUI !!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多個Stack"><a href="#多個Stack" class="headerlink" title="多個Stack"></a>多個Stack</h2><p>你可以使用多個堆疊來表現不同的樣式，例如下面代碼。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span>()&#123;</span><br><span class="line">    <span class="type">VStack</span>() &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"1. Hello"</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"SwiftUI"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">VStack</span>() &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"2. Hello"</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"SwiftUI"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SwiftUI-Stack-堆疊方式&quot;&gt;&lt;a href=&quot;#SwiftUI-Stack-堆疊方式&quot; class=&quot;headerlink&quot; title=&quot;SwiftUI Stack 堆疊方式&quot;&gt;&lt;/a&gt;SwiftUI Stack 堆疊方式&lt;/h1&gt;&lt;p&gt;在SwiftUI中有三種堆疊分別為VStack、ZStack和HStack，這些堆疊可以讓顯示的東西以不同的方式呈現。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SwiftUI tutorials" scheme="https://chucs.github.io/categories/SwiftUI-tutorials/"/>
    
    
      <category term="swiftui" scheme="https://chucs.github.io/tags/swiftui/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI Color</title>
    <link href="https://chucs.github.io/swiftui-color/"/>
    <id>https://chucs.github.io/swiftui-color/</id>
    <published>2020-07-14T03:44:25.000Z</published>
    <updated>2020-08-09T12:43:05.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SwiftUI-Hex-Color-十六進至顏色轉換"><a href="#SwiftUI-Hex-Color-十六進至顏色轉換" class="headerlink" title="SwiftUI Hex Color 十六進至顏色轉換"></a>SwiftUI Hex Color 十六進至顏色轉換</h1><p>如果想要使用hex的色碼的話可以先定義好轉換方式，之後只需要設定Color裡面的hex就可以轉換成想要的顏色。當然你必須先定義好你的函式。</p><a id="more"></a><p>首先你需要在extension定義好色碼轉換方法，例如下面的代碼。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> cloloABC = <span class="type">Color</span>(hex: <span class="string">"#FFFFFF"</span>, alpha: <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(hex: <span class="type">String</span>, alpha: <span class="type">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> hex = hex.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.alphanumerics.inverted)</span><br><span class="line">        <span class="keyword">if</span> hex.hasPrefix(<span class="string">"#"</span>) &#123;</span><br><span class="line">            hex = <span class="type">String</span>(hex.<span class="built_in">dropFirst</span>())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(hex.<span class="built_in">count</span> == <span class="number">3</span> || hex.<span class="built_in">count</span> == <span class="number">6</span> || hex.<span class="built_in">count</span> == <span class="number">8</span>, <span class="string">"Invalid hex code used. hex count is #(3, 6, 8)."</span>)</span><br><span class="line">        <span class="keyword">var</span> int: <span class="type">UInt64</span> = <span class="number">0</span></span><br><span class="line">        <span class="type">Scanner</span>(string: hex).scanHexInt64(&amp;int)</span><br><span class="line">        <span class="keyword">let</span> r, g, b: <span class="type">UInt64</span></span><br><span class="line">        <span class="keyword">switch</span> hex.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// RGB (12-bit)</span></span><br><span class="line">            (r, g, b) = ((int &gt;&gt; <span class="number">8</span>) * <span class="number">17</span>, (int &gt;&gt; <span class="number">4</span> &amp; <span class="number">0xF</span>) * <span class="number">17</span>, (int &amp; <span class="number">0xF</span>) * <span class="number">17</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// RGB (24-bit)</span></span><br><span class="line">            (r, g, b) = (int &gt;&gt; <span class="number">16</span>, int &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xFF</span>, int &amp; <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">// ARGB (32-bit)</span></span><br><span class="line">            (r, g, b) = (int &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xFF</span>, int &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xFF</span>, int &amp; <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            (r, g, b) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(</span><br><span class="line">            .sRGB,</span><br><span class="line">            red: <span class="type">Double</span>(r) / <span class="number">255</span>,</span><br><span class="line">            green: <span class="type">Double</span>(g) / <span class="number">255</span>,</span><br><span class="line">            blue:  <span class="type">Double</span>(b) / <span class="number">255</span>,</span><br><span class="line">            opacity: <span class="type">Double</span>(alpha)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定義完成後，你可以在ContentView裡面直接使用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .foregroundColor(<span class="type">Color</span>.<span class="keyword">init</span>(hex: <span class="string">"#FFFFFF"</span>, alpha: <span class="number">1.0</span>))</span><br></pre></td></tr></table></figure><p>也可以定義在extension內這樣就可以直接使用而且不必重新設定色碼。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .foregroundColor(<span class="type">Color</span>.cloloABC)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SwiftUI-Hex-Color-十六進至顏色轉換&quot;&gt;&lt;a href=&quot;#SwiftUI-Hex-Color-十六進至顏色轉換&quot; class=&quot;headerlink&quot; title=&quot;SwiftUI Hex Color 十六進至顏色轉換&quot;&gt;&lt;/a&gt;SwiftUI Hex Color 十六進至顏色轉換&lt;/h1&gt;&lt;p&gt;如果想要使用hex的色碼的話可以先定義好轉換方式，之後只需要設定Color裡面的hex就可以轉換成想要的顏色。當然你必須先定義好你的函式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SwiftUI tutorials" scheme="https://chucs.github.io/categories/SwiftUI-tutorials/"/>
    
    
      <category term="swiftui" scheme="https://chucs.github.io/tags/swiftui/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI Text</title>
    <link href="https://chucs.github.io/swiftui-text/"/>
    <id>https://chucs.github.io/swiftui-text/</id>
    <published>2020-07-13T07:47:34.000Z</published>
    <updated>2020-08-09T12:43:37.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Text-用法"><a href="#Text-用法" class="headerlink" title="Text 用法"></a>Text 用法</h2><h3 id="顯示簡單文字"><a href="#顯示簡單文字" class="headerlink" title="顯示簡單文字"></a>顯示簡單文字</h3><p>ContentView已在中生成的範例代碼向你展示瞭如何顯示一行文字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="更改字體類型"><a href="#更改字體類型" class="headerlink" title="更改字體類型"></a>更改字體類型</h3><h4 id="fontWeight-文字類型"><a href="#fontWeight-文字類型" class="headerlink" title="fontWeight 文字類型"></a>fontWeight 文字類型</h4><p>你可以使用fontWeight來更改字體的類型，例如下面所使用的粗體字，當然字體類型有很多種像是heavy, light, medium等等等…</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .fontWeight(.bold)</span><br></pre></td></tr></table></figure><h4 id="font-字體樣式"><a href="#font-字體樣式" class="headerlink" title="font 字體樣式"></a>font 字體樣式</h4><p>字體樣式中你可以修改字體的大小, 字形和大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font(.title)</span><br></pre></td></tr></table></figure><p>如果想要進一步修改字體的設計你可以像這樣寫：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.font(.system(.largeTitle, design: .rounded))</span><br></pre></td></tr></table></figure><p>這樣寫字體就會被修成largeTitle的樣式而且是圓弧的。</p><p>該font修改器可以更改字體屬性。在上面的代碼中，我們指定使用標題字體類型以放大文本。</p><p>如果要使用固定大小的字體你只要在system裡面設定size就可以了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.font(.system(size: <span class="number">20</span>))</span><br></pre></td></tr></table></figure><p>如果想更改字體的字型的話可以使用custom來更改字型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.font(.custom(<span class="string">"Helvetica Neue"</span>, size: <span class="number">25</span>))</span><br></pre></td></tr></table></figure><p>字體名稱可以在“字體書”中找到。您可以打開Finder應用程序，然後單擊字體簿以啟動該應用程序。</p><h4 id="shadow-陰影"><a href="#shadow-陰影" class="headerlink" title="shadow 陰影"></a>shadow 陰影</h4><p>為文本增加陰影效果可以使字體更有感覺，而radius可以設定陰影的風格。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.shadow(color: .black, radius: <span class="number">2</span>, x: <span class="number">0</span>, y: <span class="number">15</span>)</span><br></pre></td></tr></table></figure><h3 id="更改字體顏色"><a href="#更改字體顏色" class="headerlink" title="更改字體顏色"></a>更改字體顏色</h3><h4 id="foregroundColor-修改顏色"><a href="#foregroundColor-修改顏色" class="headerlink" title="foregroundColor 修改顏色"></a>foregroundColor 修改顏色</h4><p>您可以使用其他內置值喜歡.red，.purple等等。如果你想知道如何使用hex色碼的話可以參考<a href="https://chucs.github.io/swiftui-text/">SwiftUI Color</a>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .foregroundColor(.red)</span><br></pre></td></tr></table></figure><h3 id="多個修處理多行文字飾"><a href="#多個修處理多行文字飾" class="headerlink" title="多個修處理多行文字飾"></a>多個修處理多行文字飾</h3><p>在SwiftUI裡支持多個修飾，你可以使用foregroundColor修改顏色fontWeight修改字體類型等等等…</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .fontWeight(.bold)</span><br><span class="line">    .font(.title)</span><br></pre></td></tr></table></figure><h3 id="處理多行文字"><a href="#處理多行文字" class="headerlink" title="處理多行文字"></a>處理多行文字</h3><p>Text默認情況下支持多行，因此它可以顯示文本段落，而無需使用任何其他修飾符。但你可以使用一些函式來修改文本。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!"</span>)</span><br><span class="line">    .fontWeight(.bold)</span><br><span class="line">    .font(.title)</span><br></pre></td></tr></table></figure><h4 id="multilineTextAlignment-修改文字位置"><a href="#multilineTextAlignment-修改文字位置" class="headerlink" title="multilineTextAlignment 修改文字位置"></a>multilineTextAlignment 修改文字位置</h4><p>要使文本置中對齊，請插入multilineTextAlignment修飾符並將值設置為.center如下所示，當然你也可以靠左對齊靠右對齊。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.multilineTextAlignment(.center)</span><br></pre></td></tr></table></figure><h4 id="lineLimit-行數行數限制"><a href="#lineLimit-行數行數限制" class="headerlink" title="lineLimit 行數行數限制"></a>lineLimit 行數行數限制</h4><p>你可能希望將行數限制為一定數量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.lineLimit(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="設置填充和行距"><a href="#設置填充和行距" class="headerlink" title="設置填充和行距"></a>設置填充和行距</h3><h4 id="lineSpacing-行距調整"><a href="#lineSpacing-行距調整" class="headerlink" title="lineSpacing 行距調整"></a>lineSpacing 行距調整</h4><p>默認行間距足以應付大多數情況。如果要更改默認設置，可以使用lineSpacing修飾符來調整行距。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.lineSpacing(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="padding-填充空間"><a href="#padding-填充空間" class="headerlink" title="padding 填充空間"></a>padding 填充空間</h4><p>如您所見，文本太靠近邊緣的左側和右側。要給它更多的空間，可以使用padding修飾符，該修飾符為文本的每一側增加一些額外的空間。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.padding()</span><br></pre></td></tr></table></figure><p>如果沒有在裡面設定數字的話就會是默認的長度。如果想要設定固定長度的話可以直接帶入數字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.padding(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>在padding修飾符中也可以設定你想要哪幾個邊做增加。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.padding([.top, .leading, .trailing])</span><br></pre></td></tr></table></figure><h3 id="旋轉文字"><a href="#旋轉文字" class="headerlink" title="旋轉文字"></a>旋轉文字</h3><h4 id="rotationEffect-旋轉"><a href="#rotationEffect-旋轉" class="headerlink" title="rotationEffect 旋轉"></a>rotationEffect 旋轉</h4><p>SwiftUI框架提供了API，無論是2D還是3D都可以讓您輕鬆旋轉文本。</p><p>2D旋轉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.rotationEffect(.degrees(<span class="number">20</span>), anchor: <span class="type">UnitPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>3D旋轉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.rotation3DEffect(.degrees(<span class="number">60</span>), axis: (x: <span class="number">1</span>, y: <span class="number">0</span>, z: <span class="number">0</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Text-用法&quot;&gt;&lt;a href=&quot;#Text-用法&quot; class=&quot;headerlink&quot; title=&quot;Text 用法&quot;&gt;&lt;/a&gt;Text 用法&lt;/h2&gt;&lt;h3 id=&quot;顯示簡單文字&quot;&gt;&lt;a href=&quot;#顯示簡單文字&quot; class=&quot;headerlink&quot; title=&quot;顯示簡單文字&quot;&gt;&lt;/a&gt;顯示簡單文字&lt;/h3&gt;&lt;p&gt;ContentView已在中生成的範例代碼向你展示瞭如何顯示一行文字。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;Text&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="SwiftUI tutorials" scheme="https://chucs.github.io/categories/SwiftUI-tutorials/"/>
    
    
      <category term="swiftui" scheme="https://chucs.github.io/tags/swiftui/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_3_C - Doubly Linked List</title>
    <link href="https://chucs.github.io/ALDS1-3-C-Doubly-Linked-List/"/>
    <id>https://chucs.github.io/ALDS1-3-C-Doubly-Linked-List/</id>
    <published>2020-07-13T05:06:41.000Z</published>
    <updated>2020-08-11T06:32:51.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="雙向鏈結串列"><a href="#雙向鏈結串列" class="headerlink" title="雙向鏈結串列"></a>雙向鏈結串列</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_3_C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>寫一個具備以下功能的Doubly Linked List:<br>insert x: 加入一個元素x在list的最前面.<br>delete x: 刪除一個元素x. 如果沒有找到，不必做任何動作.<br>deleteFirst: 刪除list第一個元素.<br>deleteLast: 刪除list最後一個元素.</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="節點"><a href="#節點" class="headerlink" title="節點"></a>節點</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">    <span class="comment">// 上一個節點</span></span><br><span class="line">Node* prev;</span><br><span class="line">    <span class="comment">// 下一個節點</span></span><br><span class="line">Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先我們要先宣告一個結構分別為資料,上個節點和下一個節點。</p><h5 id="新增數字"><a href="#新增數字" class="headerlink" title="新增數字"></a>新增數字</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Node* tmpNode = motherNode-&gt;next;</span><br><span class="line">    motherNode-&gt;next = <span class="keyword">new</span> Node();</span><br><span class="line">    motherNode-&gt;next-&gt;data = x;</span><br><span class="line">    motherNode-&gt;next-&gt;next = tmpNode;</span><br><span class="line">    motherNode-&gt;next-&gt;prev = motherNode;</span><br><span class="line">    tmpNode-&gt;prev = motherNode-&gt;next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先新增一個新節點然後將資料放入後，與主節點做連接。</p><h5 id="刪除數字"><a href="#刪除數字" class="headerlink" title="刪除數字"></a>刪除數字</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Node* tmpNode = motherNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(tmpNode != motherNode &amp;&amp; tmpNode-&gt;data != x)&#123;</span><br><span class="line">        tmpNode = tmpNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmpNode != motherNode)&#123;</span><br><span class="line">        tmpNode-&gt;prev-&gt;next = tmpNode-&gt;next;</span><br><span class="line">        tmpNode-&gt;next-&gt;prev = tmpNode-&gt;prev;</span><br><span class="line">        <span class="keyword">delete</span> tmpNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>逐一檢查節點資料是否為x，如果找到了就將next與prev的節點換成下一個位置的，然後刪除節點。</p><h5 id="刪除最前面的"><a href="#刪除最前面的" class="headerlink" title="刪除最前面的"></a>刪除最前面的</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node* tmpNode = motherNode-&gt;next;</span><br><span class="line">    motherNode-&gt;next = motherNode-&gt;next-&gt;next;</span><br><span class="line">    motherNode-&gt;next-&gt;prev = motherNode;</span><br><span class="line">    <span class="keyword">delete</span> tmpNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>將最前面的節點交換後與主節點連接，然後再將他刪除。</p><h5 id="刪除最後面的"><a href="#刪除最後面的" class="headerlink" title="刪除最後面的"></a>刪除最後面的</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node* tmpNode = motherNode-&gt;prev;</span><br><span class="line">    motherNode-&gt;prev = motherNode-&gt;prev-&gt;prev;</span><br><span class="line">    motherNode-&gt;prev-&gt;next = motherNode;</span><br><span class="line">    <span class="keyword">delete</span> tmpNode; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>將最後面的節點交換後與主節點連接，然後再將他刪除。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/b9f0ee48e8f8965c9b8b30ecaeee9afe.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;雙向鏈結串列&quot;&gt;&lt;a href=&quot;#雙向鏈結串列&quot; class=&quot;headerlink&quot; title=&quot;雙向鏈結串列&quot;&gt;&lt;/a&gt;雙向鏈結串列&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_3_C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;寫一個具備以下功能的Doubly Linked List:&lt;br&gt;insert x: 加入一個元素x在list的最前面.&lt;br&gt;delete x: 刪除一個元素x. 如果沒有找到，不必做任何動作.&lt;br&gt;deleteFirst: 刪除list第一個元素.&lt;br&gt;deleteLast: 刪除list最後一個元素.&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
</feed>
