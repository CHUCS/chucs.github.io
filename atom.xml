<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHUCSIE</title>
  
  <subtitle>解題報告</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chucs.github.io/"/>
  <updated>2020-11-11T14:17:49.245Z</updated>
  <id>https://chucs.github.io/</id>
  
  <author>
    <name>CHUCSIE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust 007 Struct</title>
    <link href="https://chucs.github.io/rust-007-struct/"/>
    <id>https://chucs.github.io/rust-007-struct/</id>
    <published>2020-11-11T12:45:13.000Z</published>
    <updated>2020-11-11T14:17:49.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust-結構與模塊"><a href="#Rust-結構與模塊" class="headerlink" title="Rust 結構與模塊"></a>Rust 結構與模塊</h1><p>Struct是自定義的數據類型，因此我們可以自行定義，而他也使我們能夠根據自己的需求調整數據的結構。Methods是將你所有的函式包裝再一起，而當你可以在這個模組下找到相關的函式。</p><a id="more"></a><h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><p>我們利用Struct定義我們結構，他就像一個物件一樣包含了所有你所定義的東西，當你需要取得值時你只需要<code>name.a</code>或是<code>name.b</code>就可以輕鬆地取得。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著我們創建一個函式來計算面積，傳進去的東西就是我們剛剛所宣告的物件。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(obj: Object) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.width * obj.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在這邊我們利用我們所創的結構將整個物件傳入函式，你可以在Object裡面拿到你所定義的值，當你的值越多時，他可以讓你的程式碼更加得清楚，使用起來更加方便。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(obj: Object) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.width * obj.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> o = Object &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">5</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, area(o));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Impl"><a href="#Impl" class="headerlink" title="Impl"></a>Impl</h1><p>impl關鍵字被主要用於對類型限定的方式，而<code>impl</code>中定義的功能可以是獨立的，這意味著將其稱為<code>hello::world()</code>。這有點類似於<code>hello.world()</code>的概念。  </p><p>在使用<code>impl</code>時我們一樣先創建一個<code>struct</code>來定義我們所需要的數據。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>創建完後將<code>impl</code>與創建得<code>struct</code>名稱宣告成一樣的，這將會使他綁定再一起的感覺，你可以在裡面使用你所宣告的數據。<code>self</code>得用意是引用當前模塊和標記方法的接收者，這就是為什麼下面還有一個<code>new</code>的函式，我將直傳進去後在當前的模塊中，<code>self</code>就可以拿到我所須要的數據，而這邊有一個很特別的點是，<code>new</code>裡面的<code>Object</code>可以不用寫成<code>width:width</code>，因為在rust中只要他定義的名字是一樣的就會動傳到裡面去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct Object&#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Object &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">        return self.width * self.height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fn new(width: u32, height: u32) -&gt; Object &#123;</span><br><span class="line">        Object &#123;</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn run() &#123;</span><br><span class="line">    let obj &#x3D; Object::new(10, 3);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, obj.area());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想要把它拆的細一點，你也可以把<code>new</code>和<code>area</code>拆開寫也是可以的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Object &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width * <span class="keyword">self</span>.height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Object&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(width: <span class="built_in">u32</span>, height: <span class="built_in">u32</span>) -&gt; Object &#123;</span><br><span class="line">        Object &#123;</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Rust-結構與模塊&quot;&gt;&lt;a href=&quot;#Rust-結構與模塊&quot; class=&quot;headerlink&quot; title=&quot;Rust 結構與模塊&quot;&gt;&lt;/a&gt;Rust 結構與模塊&lt;/h1&gt;&lt;p&gt;Struct是自定義的數據類型，因此我們可以自行定義，而他也使我們能夠根據自己的需求調整數據的結構。Methods是將你所有的函式包裝再一起，而當你可以在這個模組下找到相關的函式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Rust tutorials" scheme="https://chucs.github.io/categories/Rust-tutorials/"/>
    
    
      <category term="rust" scheme="https://chucs.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 006 Types</title>
    <link href="https://chucs.github.io/rust-006-types/"/>
    <id>https://chucs.github.io/rust-006-types/</id>
    <published>2020-11-09T12:53:39.000Z</published>
    <updated>2020-11-10T13:24:17.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust-型態"><a href="#Rust-型態" class="headerlink" title="Rust 型態"></a>Rust 型態</h1><h4 id="Integer-Types"><a href="#Integer-Types" class="headerlink" title="Integer Types"></a>Integer Types</h4><p>整數是沒有小數部分的數字。以下是在RUST中整數型態的表示方法。</p><a id="more"></a><table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>u8</td></tr><tr><td>16-bit</td><td>i16</td><td>u16</td></tr><tr><td>32-bit</td><td>i32</td><td>u32</td></tr><tr><td>64-bit</td><td>i64</td><td>u64</td></tr><tr><td>128-bit</td><td>i128</td><td>u128</td></tr></tbody></table><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">i8</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">i16</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">i32</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="Floating-Point-Types"><a href="#Floating-Point-Types" class="headerlink" title="Floating-Point Types"></a>Floating-Point Types</h4><p>Rust對於浮點數也有兩種原始類型<code>f32</code>和<code>f64</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5.0</span>; <span class="comment">// f64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br></pre></td></tr></table></figure><h4 id="The-Boolean-Type"><a href="#The-Boolean-Type" class="headerlink" title="The Boolean Type"></a>The Boolean Type</h4><p>在布林函數中只有對和錯。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">bool</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="The-Character-Type"><a href="#The-Character-Type" class="headerlink" title="The Character Type"></a>The Character Type</h4><p>字元型態中可儲存一個字，如果一個以上就會變成字串。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'B'</span>;</span><br></pre></td></tr></table></figure><h4 id="The-Array-Type"><a href="#The-Array-Type" class="headerlink" title="The Array Type"></a>The Array Type</h4><p>利用陣列儲存多筆資料，取用時只需要輸入對應的<code>index</code>就可以了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> second = a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Rust-型態&quot;&gt;&lt;a href=&quot;#Rust-型態&quot; class=&quot;headerlink&quot; title=&quot;Rust 型態&quot;&gt;&lt;/a&gt;Rust 型態&lt;/h1&gt;&lt;h4 id=&quot;Integer-Types&quot;&gt;&lt;a href=&quot;#Integer-Types&quot; class=&quot;headerlink&quot; title=&quot;Integer Types&quot;&gt;&lt;/a&gt;Integer Types&lt;/h4&gt;&lt;p&gt;整數是沒有小數部分的數字。以下是在RUST中整數型態的表示方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Rust tutorials" scheme="https://chucs.github.io/categories/Rust-tutorials/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 005 Variable</title>
    <link href="https://chucs.github.io/rust-005-variable/"/>
    <id>https://chucs.github.io/rust-005-variable/</id>
    <published>2020-11-09T12:52:30.000Z</published>
    <updated>2020-11-09T13:09:03.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust-變量"><a href="#Rust-變量" class="headerlink" title="Rust 變量"></a>Rust 變量</h1><p>在變量中我們可以給予一些固定的值在變數中，而這些值不允許被任意更改。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"My name is &#123;&#125;."</span>, name);</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ID: <span class="built_in">i32</span> = <span class="number">001</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"My ID is &#123;&#125;."</span>, ID);</span><br></pre></td></tr></table></figure><p>分配多個變量的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ( a, b ) = (<span class="string">"Alice"</span>, <span class="number">23</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; is &#123;&#125;."</span>, a, b);</span><br></pre></td></tr></table></figure><p>輸出結果<br><img src="gZqndHG.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Rust-變量&quot;&gt;&lt;a href=&quot;#Rust-變量&quot; class=&quot;headerlink&quot; title=&quot;Rust 變量&quot;&gt;&lt;/a&gt;Rust 變量&lt;/h1&gt;&lt;p&gt;在變量中我們可以給予一些固定的值在變數中，而這些值不允許被任意更改。&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;Bob&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;My name is &amp;#123;&amp;#125;.&quot;&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Rust tutorials" scheme="https://chucs.github.io/categories/Rust-tutorials/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 004 Format</title>
    <link href="https://chucs.github.io/rust-004-format/"/>
    <id>https://chucs.github.io/rust-004-format/</id>
    <published>2020-11-09T12:50:45.000Z</published>
    <updated>2020-11-09T13:09:03.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust-格式化輸出"><a href="#Rust-格式化輸出" class="headerlink" title="Rust 格式化輸出"></a>Rust 格式化輸出</h1><p>格式化輸出可以讓你方便的排版你想要的輸出方式，以下我們介紹幾中常見的格式化輸出。  </p><p>利用大括弧來標示變數所在的地方，由左而右依序輸出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"Num: &#123;&#125;, &#123;&#125;"</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>在大括弧內設下index，以照後面資料的順序索取你需要的資料。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;0&#125; is &#123;0&#125; and &#123;1&#125; haha &#123;2&#125;."</span>, <span class="string">"Bob"</span>, <span class="string">"Alice"</span>, <span class="string">"John"</span>);</span><br></pre></td></tr></table></figure><p>在大括弧內設下變數，在後面以變數給予值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;a&#125; is &#123;b&#125; and &#123;c&#125; haha &#123;a&#125;."</span>, b = <span class="string">"Bob"</span>, a = <span class="string">"Alice"</span>, c = <span class="string">"John"</span>);</span><br></pre></td></tr></table></figure><p>依照型態命名，輸出則會以我們所設的型態輸出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"Binary: &#123;:b&#125;, Hex: &#123;:x&#125;, Octal: &#123;:o&#125;."</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>輸出結果<br><img src="HgVZM4p.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Rust-格式化輸出&quot;&gt;&lt;a href=&quot;#Rust-格式化輸出&quot; class=&quot;headerlink&quot; title=&quot;Rust 格式化輸出&quot;&gt;&lt;/a&gt;Rust 格式化輸出&lt;/h1&gt;&lt;p&gt;格式化輸出可以讓你方便的排版你想要的輸出方式，以下我們介紹幾中常見的格式化輸出。  &lt;/p&gt;
&lt;p&gt;利用大括弧來標示變數所在的地方，由左而右依序輸出。&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Num: &amp;#123;&amp;#125;, &amp;#123;&amp;#125;&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Rust tutorials" scheme="https://chucs.github.io/categories/Rust-tutorials/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 003 Function</title>
    <link href="https://chucs.github.io/rust-003-function/"/>
    <id>https://chucs.github.io/rust-003-function/</id>
    <published>2020-11-09T12:21:48.000Z</published>
    <updated>2020-11-09T13:09:03.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust-函式"><a href="#Rust-函式" class="headerlink" title="Rust 函式"></a>Rust 函式</h1><p>我們可以在src下創建一個新的檔案<code>print.rs</code>，編寫一下程式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello print.rs run!!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>然後我們回到主程式來引用我們寫得函式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> print;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    print::run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著執行就可以看到我們的結果了。</p><p><img src="iMTn529.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Rust-函式&quot;&gt;&lt;a href=&quot;#Rust-函式&quot; class=&quot;headerlink&quot; title=&quot;Rust 函式&quot;&gt;&lt;/a&gt;Rust 函式&lt;/h1&gt;&lt;p&gt;我們可以在src下創建一個新的檔案&lt;code&gt;print.rs&lt;/code&gt;，編寫一下程式。&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello print.rs run!!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Rust tutorials" scheme="https://chucs.github.io/categories/Rust-tutorials/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 002 Project</title>
    <link href="https://chucs.github.io/rust-002-project/"/>
    <id>https://chucs.github.io/rust-002-project/</id>
    <published>2020-11-09T12:15:13.000Z</published>
    <updated>2020-11-09T13:09:03.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust-第一個專案"><a href="#Rust-第一個專案" class="headerlink" title="Rust 第一個專案"></a>Rust 第一個專案</h1><p>安裝完RUST後我們可以開始寫我們第一個RUST得程式了，首先我們先下<code>cargo init</code>這將會替我們創建一些基本的檔案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo init</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="uMvHeRj.png" alt=""></p><p>目錄應該是長下面這樣，<code>Cargo.toml</code>裡面寫的是一些設定檔案，版本訊息等等，<code>main.rs</code>則是我們主要寫程式的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- Cargo.toml</span><br><span class="line">&#96;-- src</span><br><span class="line">    &#96;-- main.rs</span><br></pre></td></tr></table></figure><p>然後打開<code>main.rs</code>編寫我們第一個RUST程式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著執行程式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br></pre></td></tr></table></figure><p><img src="J4JlXIU.png" alt=""></p><p>執行完後你會看到你剛剛寫的<code>Hello, world!</code>印在終端機上面。</p><p>如果你不想要執行程式的話可以輸入<code>build</code>就好。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br></pre></td></tr></table></figure><p><img src="vudWD4D.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Rust-第一個專案&quot;&gt;&lt;a href=&quot;#Rust-第一個專案&quot; class=&quot;headerlink&quot; title=&quot;Rust 第一個專案&quot;&gt;&lt;/a&gt;Rust 第一個專案&lt;/h1&gt;&lt;p&gt;安裝完RUST後我們可以開始寫我們第一個RUST得程式了，首先我們先下&lt;code&gt;cargo init&lt;/code&gt;這將會替我們創建一些基本的檔案。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cargo init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Rust tutorials" scheme="https://chucs.github.io/categories/Rust-tutorials/"/>
    
    
      <category term="rust" scheme="https://chucs.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 001 Install</title>
    <link href="https://chucs.github.io/rust-001-install/"/>
    <id>https://chucs.github.io/rust-001-install/</id>
    <published>2020-11-09T12:13:19.000Z</published>
    <updated>2020-11-09T13:09:03.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RUST-介紹與安裝"><a href="#RUST-介紹與安裝" class="headerlink" title="RUST 介紹與安裝"></a>RUST 介紹與安裝</h1><h2 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h2><p>安全：Rust 擁有豐富類型系統和所有權模型，保證了內存安全性和線程安全性。</p><p>並發：Rust 可讓程序在編譯時並發執行，也就是多個事件在同一時間間隔執行，並且將安全與並發完美統一。</p><p>高效：Rust 快且節省內存。</p><a id="more"></a><h2 id="安裝-RUST"><a href="#安裝-RUST" class="headerlink" title="安裝 RUST"></a>安裝 RUST</h2><p>到<a href="https://www.rust-lang.org/" target="_blank" rel="noopener">RUST</a>的官網按下<code>get started</code>然後你會看到下載畫面，選擇你的作業系統下載對應的下載檔案，通常他會先替你選好。</p><p><img src="E2SfgQY.png" alt=""></p><p>打開你下載好的<code>rustup-init</code>檔案，打開後你會看到他所幫你安裝的路徑等資訊，接著在終端機內輸入1使用預設的安裝。</p><p><img src="MOrVY0n.png" alt=""></p><p>安裝完後可以在終端機輸入<code>rustc --version</code>和<code>cargo --version</code>查看你所安裝版本。</p><p>接下來下載<code>Visual Studio Code</code>，打開後點擊左邊第四個選項來新增RUST套件，新增完後重新載入<code>Visual Studio Code</code>，然後右下角會跳出安裝RUST提醒就直接<code>install</code>。<br><img src="Dt3OZKz.png" alt=""></p><p>新建一個<code>hello.rs</code>然後打開檔案將以下程式碼寫入。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成後打開終端機到檔案下的目錄執行下面的指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rustc hello.rs</span><br><span class="line">$ ./hello</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RUST-介紹與安裝&quot;&gt;&lt;a href=&quot;#RUST-介紹與安裝&quot; class=&quot;headerlink&quot; title=&quot;RUST 介紹與安裝&quot;&gt;&lt;/a&gt;RUST 介紹與安裝&lt;/h1&gt;&lt;h2 id=&quot;優點&quot;&gt;&lt;a href=&quot;#優點&quot; class=&quot;headerlink&quot; title=&quot;優點&quot;&gt;&lt;/a&gt;優點&lt;/h2&gt;&lt;p&gt;安全：Rust 擁有豐富類型系統和所有權模型，保證了內存安全性和線程安全性。&lt;/p&gt;
&lt;p&gt;並發：Rust 可讓程序在編譯時並發執行，也就是多個事件在同一時間間隔執行，並且將安全與並發完美統一。&lt;/p&gt;
&lt;p&gt;高效：Rust 快且節省內存。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Rust tutorials" scheme="https://chucs.github.io/categories/Rust-tutorials/"/>
    
    
      <category term="rust" scheme="https://chucs.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Parallel Programming MS-MPI install</title>
    <link href="https://chucs.github.io/parallel-001-MS-MPI-install/"/>
    <id>https://chucs.github.io/parallel-001-MS-MPI-install/</id>
    <published>2020-11-09T11:14:25.000Z</published>
    <updated>2020-11-09T13:09:03.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Parallel-Programming-平行程式"><a href="#Parallel-Programming-平行程式" class="headerlink" title="Parallel Programming 平行程式"></a>Parallel Programming 平行程式</h1><p>平行計算是一種類型的計算，許多計算或執行過程是同時進行的。把大問題分為小問題，然後同時解決。以下式建置平行程式環境的流程。</p><a id="more"></a><h2 id="MS-MPI-安裝教學"><a href="#MS-MPI-安裝教學" class="headerlink" title="MS-MPI 安裝教學"></a>MS-MPI 安裝教學</h2><p>首先打開<a href="https://docs.microsoft.com/en-us/message-passing-interface/microsoft-mpi" target="_blank" rel="noopener">MS-MPI</a>然後到下載的地方點擊MS-MPI vxx.x.x，如下圖紫色字體。</p><p><img src="Otdr8uZ.png" alt=""></p><p>接著將所有檔案打勾然後按下一步就會把檔案下載下來了。</p><p><img src="a8jSD2x.png" alt=""></p><p>下載下來後執行並下移步到底，若要更換路徑請自行記得路徑。<br>接著打開Visual Studio 開啟一個C++專案。</p><p><img src="hfmZ9fk.png" alt=""></p><p>點擊右邊專案右鍵，屬性。</p><p><img src="eC9A1o6.png" alt=""></p><p>打開後按<code>C/C++</code>-&gt;<code>其他include目錄</code>，將剛剛按裝好的<code>MPI/Include</code>路徑設好。</p><p><img src="1LVNsYp.png" alt=""></p><p><img src="tXWUuIj.png" alt=""></p><p>建置完後就會產出一個<code>.exe</code>的檔案。</p><p><img src="1q8F8cx.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rank, <span class="built_in">size</span>;</span><br><span class="line">MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">MPI_Comm_size(MPI_COMM_WORLD, &amp;<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello, World.  I am %d of %d\n"</span>, rank, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">MPI_Finalize();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="HKDJrkG.png" alt=""></p><p>將終端機打開<code>source\repos\MpiTest\Debug</code>執行面下指令(這個路徑是你的專案路徑，因此可能會有所不同)，你就會看到下圖結果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec -n 4 MpiTest.exe</span><br></pre></td></tr></table></figure><p>若無此指令請確認環境變數是否有設定完成。<br><img src="aXnvwD9.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Parallel-Programming-平行程式&quot;&gt;&lt;a href=&quot;#Parallel-Programming-平行程式&quot; class=&quot;headerlink&quot; title=&quot;Parallel Programming 平行程式&quot;&gt;&lt;/a&gt;Parallel Programming 平行程式&lt;/h1&gt;&lt;p&gt;平行計算是一種類型的計算，許多計算或執行過程是同時進行的。把大問題分為小問題，然後同時解決。以下式建置平行程式環境的流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Parallel Programming" scheme="https://chucs.github.io/categories/Parallel-Programming/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces 1426D</title>
    <link href="https://chucs.github.io/Non-zero-Segments/"/>
    <id>https://chucs.github.io/Non-zero-Segments/</id>
    <published>2020-10-03T07:10:30.000Z</published>
    <updated>2020-10-16T15:26:49.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-1426D-Non-zero-Segments"><a href="#Codeforces-1426D-Non-zero-Segments" class="headerlink" title="Codeforces 1426D - Non-zero Segments"></a>Codeforces 1426D - Non-zero Segments</h1><p><a href="https://codeforces.com/problemset/problem/1426/D" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>Kolya有一陣列a，裡面數字有正有負，因為Kolya不喜歡0所以不包含0，Kolya也不喜歡子陣列中的總合為0(子陣列為一個連續的範圍)。<br>你要幫Kolya調整陣列使得任意子陣列總和不為0，你可以在陣列中的任一位置插入任意數字，就算數字超過可顯示範圍也行，請找出「最少」需要插入的數字的次數。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>需要從a<sub>i</sub>加到a<sub>j</sub>, (i &lt; j)來確認總和，因此是個前綴和的問題，從開頭開始加，用map紀錄出現過的總和，對每次的總和作判斷，如果前面出現過相同的總和代表在這區間中有子陣列總和為0，例: a=[8 5 -5]，子陣列總和=[8 13 8]，8重複出現可以發現因為有子陣列[5 -5]總和為0的關係，因此這區間需要插入一個數，因為插入一個數的關係，所以左邊的區間總和不會出現0，因此出現過的總和(map)需要重置，重新計算總和。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/cb5049de13da8958e88679cb0375f3ac.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Codeforces-1426D-Non-zero-Segments&quot;&gt;&lt;a href=&quot;#Codeforces-1426D-Non-zero-Segments&quot; class=&quot;headerlink&quot; title=&quot;Codeforces 1426D - Non-zero Segments&quot;&gt;&lt;/a&gt;Codeforces 1426D - Non-zero Segments&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1426/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;Kolya有一陣列a，裡面數字有正有負，因為Kolya不喜歡0所以不包含0，Kolya也不喜歡子陣列中的總合為0(子陣列為一個連續的範圍)。&lt;br&gt;你要幫Kolya調整陣列使得任意子陣列總和不為0，你可以在陣列中的任一位置插入任意數字，就算數字超過可顯示範圍也行，請找出「最少」需要插入的數字的次數。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://chucs.github.io/categories/Codeforces/"/>
    
    
      <category term="sortings" scheme="https://chucs.github.io/tags/sortings/"/>
    
      <category term="greedy" scheme="https://chucs.github.io/tags/greedy/"/>
    
      <category term="constructive algorithms" scheme="https://chucs.github.io/tags/constructive-algorithms/"/>
    
      <category term="data structures" scheme="https://chucs.github.io/tags/data-structures/"/>
    
      <category term="1500" scheme="https://chucs.github.io/tags/1500/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1426C</title>
    <link href="https://chucs.github.io/Increase-and-Copy/"/>
    <id>https://chucs.github.io/Increase-and-Copy/</id>
    <published>2020-10-03T07:10:14.000Z</published>
    <updated>2020-10-16T15:26:49.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-1426C-Increase-and-Copy"><a href="#Codeforces-1426C-Increase-and-Copy" class="headerlink" title="Codeforces 1426C - Increase and Copy"></a>Codeforces 1426C - Increase and Copy</h1><p><a href="https://codeforces.com/problemset/problem/1426/C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>你有一陣列a，一開始只有一個元素1(a = [1])，每次動作你能做以下一種事:<br>1.對a中其中一個元素+1<br>2.對a中其中一個元素做複製，並放在陣列最後面<br>你要找出「最小」次數的動作讓陣列a裡的元素總和至少為n。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>要次數最小，所以一次動作加越多數字越好，因此應該是先+1到某個數字後在做複製，根據數學可以知道某數的平方數字最大(算幾)，也會發現執行動作次數最少，所以要加到sqrt(n)之後作複製到超過n所需的次數。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/6e6e6cc5ae4c3bd72ddfc6b89c8d648b.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Codeforces-1426C-Increase-and-Copy&quot;&gt;&lt;a href=&quot;#Codeforces-1426C-Increase-and-Copy&quot; class=&quot;headerlink&quot; title=&quot;Codeforces 1426C - Increase and Copy&quot;&gt;&lt;/a&gt;Codeforces 1426C - Increase and Copy&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1426/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;你有一陣列a，一開始只有一個元素1(a = [1])，每次動作你能做以下一種事:&lt;br&gt;1.對a中其中一個元素+1&lt;br&gt;2.對a中其中一個元素做複製，並放在陣列最後面&lt;br&gt;你要找出「最小」次數的動作讓陣列a裡的元素總和至少為n。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://chucs.github.io/categories/Codeforces/"/>
    
    
      <category term="math" scheme="https://chucs.github.io/tags/math/"/>
    
      <category term="binary search" scheme="https://chucs.github.io/tags/binary-search/"/>
    
      <category term="constructive algorithms" scheme="https://chucs.github.io/tags/constructive-algorithms/"/>
    
      <category term="1100" scheme="https://chucs.github.io/tags/1100/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1426B</title>
    <link href="https://chucs.github.io/Symmetric-Matrix/"/>
    <id>https://chucs.github.io/Symmetric-Matrix/</id>
    <published>2020-10-03T07:09:56.000Z</published>
    <updated>2020-10-16T15:26:49.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-1426B-Symmetric-Matrix"><a href="#Codeforces-1426B-Symmetric-Matrix" class="headerlink" title="Codeforces 1426B - Symmetric Matrix"></a>Codeforces 1426B - Symmetric Matrix</h1><p><a href="https://codeforces.com/problemset/problem/1426/B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>Masha有n種類型2x2大小的磁磚，磁磚上每格各有一個數字，Masha想利用這幾種磁磚組成mxm的矩形(可用任意種類與任意數量組成)，然後Masha希望這個矩形上的數字是對稱的–對任一對位置(i,j)要符合s[i][j] = s[j][i]，請問Masha有辦法組成他想要的矩形嗎?</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>當m為奇數就不可能用2x2組成，觀察後可以發現當磁磚右上與左下數字相同必能符合對稱條件，反之則不符合對稱條件，因此在n種磁磚中有一種右上左下數字相同就能組成。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/bded1c9c1f388bf6a4f1a331a2a08147.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Codeforces-1426B-Symmetric-Matrix&quot;&gt;&lt;a href=&quot;#Codeforces-1426B-Symmetric-Matrix&quot; class=&quot;headerlink&quot; title=&quot;Codeforces 1426B - Symmetric Matrix&quot;&gt;&lt;/a&gt;Codeforces 1426B - Symmetric Matrix&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1426/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;Masha有n種類型2x2大小的磁磚，磁磚上每格各有一個數字，Masha想利用這幾種磁磚組成mxm的矩形(可用任意種類與任意數量組成)，然後Masha希望這個矩形上的數字是對稱的–對任一對位置(i,j)要符合s[i][j] = s[j][i]，請問Masha有辦法組成他想要的矩形嗎?&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://chucs.github.io/categories/Codeforces/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
      <category term="900" scheme="https://chucs.github.io/tags/900/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1426A</title>
    <link href="https://chucs.github.io/Floor-Number/"/>
    <id>https://chucs.github.io/Floor-Number/</id>
    <published>2020-10-03T07:09:35.000Z</published>
    <updated>2020-10-16T15:26:49.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-1426A-Floor-Number"><a href="#Codeforces-1426A-Floor-Number" class="headerlink" title="Codeforces 1426A - Floor Number"></a>Codeforces 1426A - Floor Number</h1><p><a href="https://codeforces.com/problemset/problem/1426/A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>Vasya拜訪Petya，Petya在公寓的第n號房間，公寓裡第一層房間為1號、2號，第二層開始每層有x間房間，請問Petya的房間在第幾層?</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>根據題目公式計算n在哪個區間，並進行樓層計算。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/0e7813a59b9e23c50d8364af4c850a65.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Codeforces-1426A-Floor-Number&quot;&gt;&lt;a href=&quot;#Codeforces-1426A-Floor-Number&quot; class=&quot;headerlink&quot; title=&quot;Codeforces 1426A - Floor Number&quot;&gt;&lt;/a&gt;Codeforces 1426A - Floor Number&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1426/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;Vasya拜訪Petya，Petya在公寓的第n號房間，公寓裡第一層房間為1號、2號，第二層開始每層有x間房間，請問Petya的房間在第幾層?&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://chucs.github.io/categories/Codeforces/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
      <category term="math" scheme="https://chucs.github.io/tags/math/"/>
    
      <category term="800" scheme="https://chucs.github.io/tags/800/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1418B</title>
    <link href="https://chucs.github.io/Negative-Prefixes/"/>
    <id>https://chucs.github.io/Negative-Prefixes/</id>
    <published>2020-09-22T14:52:31.000Z</published>
    <updated>2020-10-16T15:28:09.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodeForces-1418B-Negative-Prefixes"><a href="#CodeForces-1418B-Negative-Prefixes" class="headerlink" title="CodeForces 1418B - Negative Prefixes"></a>CodeForces 1418B - Negative Prefixes</h1><p><a href="https://codeforces.com/problemset/problem/1418/B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>你有一個陣列a，裡面有n個整數，有些整數被鎖住有些沒有，你能對沒有鎖住的整數做交換位置的動作(沒鎖對沒鎖)，另外有個序列p，為a<sub>1</sub>~a<sub>n</sub>的總和:p<sub>1</sub> = a<sub>1</sub>, p<sub>2</sub> = a<sub>1</sub> + a<sub>2</sub>… p<sub>n</sub> = a<sub>1</sub> + a<sub>2</sub> +…+ a<sub>n</sub><br>讓k為最大值j，並且p<sub>j</sub> &lt; 0 ，若p中沒有任何p<sub>j</sub> &lt; 0，則 k=0<br>你要交換未鎖住整數的位置，使得k為最小值，印出調整過後的陣列a</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>將沒鎖住的整數獨立出來，由大到小排序，再依序從頭一一放回陣列中沒鎖住的位置。<br>不考慮鎖住的數字，當正整數總和 &gt;= 負整數總和時，將正整數排前面則k=0<br>當正整數總和 &lt; 負整數總和時，則不管甚麼順序k最大<br>不選擇小排到大是因為第一個狀況，若負整數先在前面則k值不會最小</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/14bcb2bffc5c9b8cd2341a8758f78b47.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CodeForces-1418B-Negative-Prefixes&quot;&gt;&lt;a href=&quot;#CodeForces-1418B-Negative-Prefixes&quot; class=&quot;headerlink&quot; title=&quot;CodeForces 1418B - Negative Prefixes&quot;&gt;&lt;/a&gt;CodeForces 1418B - Negative Prefixes&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1418/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;你有一個陣列a，裡面有n個整數，有些整數被鎖住有些沒有，你能對沒有鎖住的整數做交換位置的動作(沒鎖對沒鎖)，另外有個序列p，為a&lt;sub&gt;1&lt;/sub&gt;~a&lt;sub&gt;n&lt;/sub&gt;的總和:p&lt;sub&gt;1&lt;/sub&gt; = a&lt;sub&gt;1&lt;/sub&gt;, p&lt;sub&gt;2&lt;/sub&gt; = a&lt;sub&gt;1&lt;/sub&gt; + a&lt;sub&gt;2&lt;/sub&gt;… p&lt;sub&gt;n&lt;/sub&gt; = a&lt;sub&gt;1&lt;/sub&gt; + a&lt;sub&gt;2&lt;/sub&gt; +…+ a&lt;sub&gt;n&lt;/sub&gt;&lt;br&gt;讓k為最大值j，並且p&lt;sub&gt;j&lt;/sub&gt; &amp;lt; 0 ，若p中沒有任何p&lt;sub&gt;j&lt;/sub&gt; &amp;lt; 0，則 k=0&lt;br&gt;你要交換未鎖住整數的位置，使得k為最小值，印出調整過後的陣列a&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://chucs.github.io/categories/Codeforces/"/>
    
    
      <category term="sortings" scheme="https://chucs.github.io/tags/sortings/"/>
    
      <category term="greedy" scheme="https://chucs.github.io/tags/greedy/"/>
    
      <category term="1300" scheme="https://chucs.github.io/tags/1300/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1418A</title>
    <link href="https://chucs.github.io/Buying-Torches/"/>
    <id>https://chucs.github.io/Buying-Torches/</id>
    <published>2020-09-22T14:51:35.000Z</published>
    <updated>2020-10-16T15:29:20.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodeForces-1418A-Buying-Torches"><a href="#CodeForces-1418A-Buying-Torches" class="headerlink" title="CodeForces 1418A - Buying Torches"></a>CodeForces 1418A - Buying Torches</h1><p><a href="https://codeforces.com/problemset/problem/1418/A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>你玩遊戲想要製作k個火把，每個火把需要一根棒子和一個煤炭，一開始你只有一根棒子,你能跟商人做兩種交易:<br>    1.用一根棒子交換x根棒子<br>    2.用y根棒子交換一個煤炭<br>每次只能做其中一種交易，請問你需要k個火把「最少」需要幾次交易? (測資必存在解答)</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>數學問題，幾個煤炭就需要交易幾次，並且煤炭等於y根棒子，所以交易次數=到達所需棒子量的交易次數+換煤炭的次數。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/zxzxcc112/fce4c025b50df9f1982acbd833a09d91.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CodeForces-1418A-Buying-Torches&quot;&gt;&lt;a href=&quot;#CodeForces-1418A-Buying-Torches&quot; class=&quot;headerlink&quot; title=&quot;CodeForces 1418A - Buying Torches&quot;&gt;&lt;/a&gt;CodeForces 1418A - Buying Torches&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1418/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;你玩遊戲想要製作k個火把，每個火把需要一根棒子和一個煤炭，一開始你只有一根棒子,你能跟商人做兩種交易:&lt;br&gt;    1.用一根棒子交換x根棒子&lt;br&gt;    2.用y根棒子交換一個煤炭&lt;br&gt;每次只能做其中一種交易，請問你需要k個火把「最少」需要幾次交易? (測資必存在解答)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://chucs.github.io/categories/Codeforces/"/>
    
    
      <category term="math" scheme="https://chucs.github.io/tags/math/"/>
    
      <category term="1000" scheme="https://chucs.github.io/tags/1000/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_8_C - Binary Search Tree III</title>
    <link href="https://chucs.github.io/ALDS1-8-C-Binary-Search-Tree-III/"/>
    <id>https://chucs.github.io/ALDS1-8-C-Binary-Search-Tree-III/</id>
    <published>2020-08-24T05:45:44.000Z</published>
    <updated>2020-09-08T12:13:58.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二元樹搜索-刪除"><a href="#二元樹搜索-刪除" class="headerlink" title="二元樹搜索 - 刪除"></a>二元樹搜索 - 刪除</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>編程一個擁有新增、查詢、刪除功能的二元樹，在每次新增點時，如果key大於node-&gt;key，就新增在node-&gt;right，否則新增在node-&gt;left。最後輸出Preorder與Inorder。</p><a id="more"></a><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/e5a835cfa1a3f511e096388e9697423c.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二元樹搜索-刪除&quot;&gt;&lt;a href=&quot;#二元樹搜索-刪除&quot; class=&quot;headerlink&quot; title=&quot;二元樹搜索 - 刪除&quot;&gt;&lt;/a&gt;二元樹搜索 - 刪除&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;編程一個擁有新增、查詢、刪除功能的二元樹，在每次新增點時，如果key大於node-&amp;gt;key，就新增在node-&amp;gt;right，否則新增在node-&amp;gt;left。最後輸出Preorder與Inorder。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_8_B - Binary Search Tree II</title>
    <link href="https://chucs.github.io/ALDS1-8-B-Binary-Search-Tree-II/"/>
    <id>https://chucs.github.io/ALDS1-8-B-Binary-Search-Tree-II/</id>
    <published>2020-08-24T05:45:33.000Z</published>
    <updated>2020-09-08T12:13:55.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二元樹搜索-查詢"><a href="#二元樹搜索-查詢" class="headerlink" title="二元樹搜索 - 查詢"></a>二元樹搜索 - 查詢</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node-&gt;key，就新增在node-&gt;right，否則新增在node-&gt;left。最後輸出Preorder與Inorder。</p><a id="more"></a><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/64cf5d826826134e302151c569adb7d8.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二元樹搜索-查詢&quot;&gt;&lt;a href=&quot;#二元樹搜索-查詢&quot; class=&quot;headerlink&quot; title=&quot;二元樹搜索 - 查詢&quot;&gt;&lt;/a&gt;二元樹搜索 - 查詢&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node-&amp;gt;key，就新增在node-&amp;gt;right，否則新增在node-&amp;gt;left。最後輸出Preorder與Inorder。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_8_A - Binary Search Tree I</title>
    <link href="https://chucs.github.io/ALDS1-8-A-Binary-Search-Tree-I/"/>
    <id>https://chucs.github.io/ALDS1-8-A-Binary-Search-Tree-I/</id>
    <published>2020-08-24T05:45:19.000Z</published>
    <updated>2020-09-08T12:13:52.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二元樹搜索-新增"><a href="#二元樹搜索-新增" class="headerlink" title="二元樹搜索 - 新增"></a>二元樹搜索 - 新增</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node-&gt;key，就新增在node-&gt;right，否則新增在node-&gt;left。最後輸出Preorder與Inorder。</p><a id="more"></a><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/f392df5b2c8130b6eeff6a0b8c1b82bb.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二元樹搜索-新增&quot;&gt;&lt;a href=&quot;#二元樹搜索-新增&quot; class=&quot;headerlink&quot; title=&quot;二元樹搜索 - 新增&quot;&gt;&lt;/a&gt;二元樹搜索 - 新增&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node-&amp;gt;key，就新增在node-&amp;gt;right，否則新增在node-&amp;gt;left。最後輸出Preorder與Inorder。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_7_C - Tree Walk</title>
    <link href="https://chucs.github.io/ALDS1-7-C-Tree-Walk/"/>
    <id>https://chucs.github.io/ALDS1-7-C-Tree-Walk/</id>
    <published>2020-08-11T04:55:23.000Z</published>
    <updated>2020-08-24T05:54:23.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="樹遍歷"><a href="#樹遍歷" class="headerlink" title="樹遍歷"></a>樹遍歷</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_C" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>您的任務是編寫一個程序，該程序根據以下算法執行樹遍歷（系統遍歷樹中的所有例程）：</p><ol><li>根、左子樹和右子樹(preorder)。</li><li>左子樹、根子樹和右子樹(inorder)。</li><li>左子樹、右子樹和根(postorder)。</li></ol><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>創建一個結構left代表左子樹，right代表右子樹，pr代表父節點用於檢查是否為跟節點。</p><p>創建一個帶有結構的陣列依序填入所有值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; key &gt;&gt; left &gt;&gt; right;</span><br><span class="line">    </span><br><span class="line">    tree[key].left = left;</span><br><span class="line">    tree[key].right = right;</span><br><span class="line">    tree[left].pr = key;</span><br><span class="line">    tree[right].pr = key;</span><br><span class="line">    node[i] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著尋找父節點，輸入的所有節點檢查pr為-1就是父節點。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRoot</span><span class="params">(Node* tree, <span class="keyword">int</span> *node, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[node[i]].pr == <span class="number">-1</span>)&#123;</span><br><span class="line">            root = node[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後利用題目上敘的規則遞迴輸出。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/b95063f99f1a85b8b827f35fe13c2c35.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;樹遍歷&quot;&gt;&lt;a href=&quot;#樹遍歷&quot; class=&quot;headerlink&quot; title=&quot;樹遍歷&quot;&gt;&lt;/a&gt;樹遍歷&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;您的任務是編寫一個程序，該程序根據以下算法執行樹遍歷（系統遍歷樹中的所有例程）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根、左子樹和右子樹(preorder)。&lt;/li&gt;
&lt;li&gt;左子樹、根子樹和右子樹(inorder)。&lt;/li&gt;
&lt;li&gt;左子樹、右子樹和根(postorder)。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_7_B - Binary Tree</title>
    <link href="https://chucs.github.io/ALDS1-7-B-Binary-Tree/"/>
    <id>https://chucs.github.io/ALDS1-7-B-Binary-Tree/</id>
    <published>2020-07-18T07:53:01.000Z</published>
    <updated>2020-08-11T06:22:55.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二元樹"><a href="#二元樹" class="headerlink" title="二元樹"></a>二元樹</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_B" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>有根的二叉樹是具有根節點的樹，其中每個節點最多有兩個子節點。</p><p>您的任務是編寫一個程序，該程序讀取有根的二叉樹T並為T的每個節點u打印以下信息：<br>node ID of u (節點編號)<br>parent of u (節點父親)<br>sibling of u (節點兄弟)<br>the number of children of u (節點小孩數目)<br>depth of u (節點深度)<br>height of u (節點高)<br>node type (root, internal node or leaf) (節點狀態)</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="sibling-兄弟"><a href="#sibling-兄弟" class="headerlink" title="sibling 兄弟"></a>sibling 兄弟</h5><p>如果左節點跟右節點都不為-1就代表有兄弟。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tree[id].left != <span class="number">-1</span> &amp;&amp; tree[id].right != <span class="number">-1</span>) &#123;</span><br><span class="line">    tree[left].sibling = right;</span><br><span class="line">    tree[right].sibling = left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="degree-＆-children-parent-子節點個數與子節點父親"><a href="#degree-＆-children-parent-子節點個數與子節點父親" class="headerlink" title="degree ＆ children parent 子節點個數與子節點父親"></a>degree ＆ children parent 子節點個數與子節點父親</h5><p>計算子節點數並順便將子節點的父親標記。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left != <span class="number">-1</span>) &#123;</span><br><span class="line">    tree[id].degree++;</span><br><span class="line">    tree[left].parent = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(right != <span class="number">-1</span>) &#123;</span><br><span class="line">    tree[id].degree++;</span><br><span class="line">    tree[right].parent = id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="height-節點高度"><a href="#height-節點高度" class="headerlink" title="height 節點高度"></a>height 節點高度</h5><p>一直往下找然後比較最大的深度回傳。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Node *tree, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (tree[key].left == <span class="number">-1</span> &amp;&amp; tree[key].right == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree[key].left == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(tree, tree[key].right) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree[key].right == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(tree, tree[key].left) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dfs(tree, tree[key].left), dfs(tree, tree[key].right)) + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="depth-深度"><a href="#depth-深度" class="headerlink" title="depth 深度"></a>depth 深度</h5><p>從根往下並沿路標記深度，深度則是由父親的深度加一就可以得到自己的深度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">depth</span><span class="params">(Node *tree, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[key].parent != <span class="number">-1</span>)&#123; </span><br><span class="line">        tree[key].depth = tree[tree[key].parent].depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[key].left != <span class="number">-1</span>)&#123;</span><br><span class="line">        depth(tree, tree[key].left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[key].right != <span class="number">-1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        depth(tree, tree[key].right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/400e539d787926ef7fc0ef89f881f4a5.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二元樹&quot;&gt;&lt;a href=&quot;#二元樹&quot; class=&quot;headerlink&quot; title=&quot;二元樹&quot;&gt;&lt;/a&gt;二元樹&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;有根的二叉樹是具有根節點的樹，其中每個節點最多有兩個子節點。&lt;/p&gt;
&lt;p&gt;您的任務是編寫一個程序，該程序讀取有根的二叉樹T並為T的每個節點u打印以下信息：&lt;br&gt;node ID of u (節點編號)&lt;br&gt;parent of u (節點父親)&lt;br&gt;sibling of u (節點兄弟)&lt;br&gt;the number of children of u (節點小孩數目)&lt;br&gt;depth of u (節點深度)&lt;br&gt;height of u (節點高)&lt;br&gt;node type (root, internal node or leaf) (節點狀態)&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>AOJ ALDS1_7_A - Rooted Trees</title>
    <link href="https://chucs.github.io/ALDS1-7-A-Rooted-Trees/"/>
    <id>https://chucs.github.io/ALDS1-7-A-Rooted-Trees/</id>
    <published>2020-07-15T08:05:42.000Z</published>
    <updated>2020-08-11T06:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="根樹"><a href="#根樹" class="headerlink" title="根樹"></a>根樹</h1><p><a href="https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_A" target="_blank" rel="noopener">題目網址</a></p><h4 id="題意"><a href="#題意" class="headerlink" title="題意:"></a>題意:</h4><p>Rooted Trees是連接的，無環的，無向的圖。Rooted Trees是一種自由樹，其中一個頂點與另一個頂點是不同的。Rooted Trees的頂點稱為“節點”。<br>你的任務是編寫一個程序，為給定的根樹T的每個節點u報告以下信息：<br>node ID of u (節點編號)<br>parent of u (節點父親)<br>depth of u (節點深度)<br>node type (root, internal node or leaf)<br>a list of chidlren of u (列出節點小孩)</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先創立一個結構parent、depth、type和internalNode方便紀錄我們的資料，接下來我們輸入每筆資料的時候就把自己節點的父親深度加一，就可以得到自己節點的深度，然後在子節點裡面，我們也做一樣的事情然後順便紀錄子節點的父親。</p><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼:"></a>程式碼:</h4><script src="https://gist.github.com/Daviswww/c3dfdc3026767577257e91a5902bae1d.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;根樹&quot;&gt;&lt;a href=&quot;#根樹&quot; class=&quot;headerlink&quot; title=&quot;根樹&quot;&gt;&lt;/a&gt;根樹&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目網址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;題意&quot;&gt;&lt;a href=&quot;#題意&quot; class=&quot;headerlink&quot; title=&quot;題意:&quot;&gt;&lt;/a&gt;題意:&lt;/h4&gt;&lt;p&gt;Rooted Trees是連接的，無環的，無向的圖。Rooted Trees是一種自由樹，其中一個頂點與另一個頂點是不同的。Rooted Trees的頂點稱為“節點”。&lt;br&gt;你的任務是編寫一個程序，為給定的根樹T的每個節點u報告以下信息：&lt;br&gt;node ID of u (節點編號)&lt;br&gt;parent of u (節點父親)&lt;br&gt;depth of u (節點深度)&lt;br&gt;node type (root, internal node or leaf)&lt;br&gt;a list of chidlren of u (列出節點小孩)&lt;/p&gt;
    
    </summary>
    
    
      <category term="AOJ" scheme="https://chucs.github.io/categories/AOJ/"/>
    
    
      <category term="implementation" scheme="https://chucs.github.io/tags/implementation/"/>
    
  </entry>
  
</feed>
