[{"title":"Rust 007 Struct","url":"/rust-007-struct/","content":"# Rust 結構與模塊\nStruct是自定義的數據類型，因此我們可以自行定義，而他也使我們能夠根據自己的需求調整數據的結構。Methods是將你所有的函式包裝再一起，而當你可以在這個模組下找到相關的函式。\n\n## Struct\n我們利用Struct定義我們結構，他就像一個物件一樣包含了所有你所定義的東西，當你需要取得值時你只需要`name.a`或是`name.b`就可以輕鬆地取得。\n\n```rust=\nstruct Object{\n    width: u32,\n    height: u32,\n}\n```\n\n接著我們創建一個函式來計算面積，傳進去的東西就是我們剛剛所宣告的物件。\n\n```rust=\nfn area(obj: Object) -> u32 {\n    return obj.width * obj.height;\n}\n```\n\n在這邊我們利用我們所創的結構將整個物件傳入函式，你可以在Object裡面拿到你所定義的值，當你的值越多時，他可以讓你的程式碼更加得清楚，使用起來更加方便。\n\n```rust=\nstruct Object{\n    width: u32,\n    height: u32,\n}\n\nfn area(obj: Object) -> u32 {\n    return obj.width * obj.height;\n}\n\nfn run() {\n    let o = Object {\n        width: 10,\n        height: 5,\n    };\n\n    println!(\"{}\", area(o));\n}\n\nfn main() {\n    run();\n}\n```\n\n# Impl\n\nimpl關鍵字被主要用於對類型限定的方式，而`impl`中定義的功能可以是獨立的，這意味著將其稱為`hello::world()`。這有點類似於`hello.world()`的概念。  \n\n在使用`impl`時我們一樣先創建一個`struct`來定義我們所需要的數據。\n```rust=\nstruct Object{\n    width: u32,\n    height: u32,\n}\n```\n創建完後將`impl`與創建得`struct`名稱宣告成一樣的，這將會使他綁定再一起的感覺，你可以在裡面使用你所宣告的數據。`self`得用意是引用當前模塊和標記方法的接收者，這就是為什麼下面還有一個`new`的函式，我將直傳進去後在當前的模塊中，`self`就可以拿到我所須要的數據，而這邊有一個很特別的點是，`new`裡面的`Object`可以不用寫成`width:width`，因為在rust中只要他定義的名字是一樣的就會動傳到裡面去。\n\n```\nstruct Object{\n    width: u32,\n    height: u32,\n}\n\nimpl Object {\n    fn area(&self) -> u32 {\n        return self.width * self.height;\n    }\n    \n    fn new(width: u32, height: u32) -> Object {\n        Object {\n            width,\n            height,\n        }\n    }\n}\n\nfn run() {\n    let obj = Object::new(10, 3);\n\n    println!(\"{}\", obj.area());\n}\n\nfn main() {\n    run();\n}\n```\n如果你想要把它拆的細一點，你也可以把`new`和`area`拆開寫也是可以的。\n\n```rust=\nimpl Object {\n    fn area(&self) -> u32 {\n        return self.width * self.height;\n    }\n}\n\nimpl Object{\n    fn new(width: u32, height: u32) -> Object {\n        Object {\n            width,\n            height,\n        }\n    }\n}\n```","tags":["rust"],"categories":["Rust tutorials"]},{"title":"Rust 006 Types","url":"/rust-006-types/","content":"# Rust 型態\n#### Integer Types\n整數是沒有小數部分的數字。以下是在RUST中整數型態的表示方法。\n<!-- more -->\n| Length  | Signed | Unsigned |\n| ------- | ------ | -------- |\n| 8-bit   | i8     | u8       |\n| 16-bit  | i16    | u16      |\n| 32-bit  | i32    | u32      |\n| 64-bit  | i64    | u64      |\n| 128-bit | i128   | u128     |\n\n\n```rust=\nlet a: i8 = 1;\n\nlet b: i16 = 2;\n\nlet c: i32 = 3;\n```\n\n#### Floating-Point Types\nRust對於浮點數也有兩種原始類型`f32`和`f64`。\n\n```rust=\nlet x = 5.0; // f64\n\nlet y: f32 = 3.0; // f32\n```\n\n#### The Boolean Type\n在布林函數中只有對和錯。\n```rust=\nlet x = true;\n\nlet y: bool = false;\n```\n\n#### The Character Type\n字元型態中可儲存一個字，如果一個以上就會變成字串。\n```rust=\nlet a = 'A';\n\nlet b = 'B';\n```\n\n#### The Array Type\n利用陣列儲存多筆資料，取用時只需要輸入對應的`index`就可以了。\n```rust=\nlet a = [1, 2, 3, 4, 5];\n\nlet first = a[0];\nlet second = a[1];\n```","categories":["Rust tutorials"]},{"title":"Rust 005 Variable","url":"/rust-005-variable/","content":"# Rust 變量\n\n在變量中我們可以給予一些固定的值在變數中，而這些值不允許被任意更改。\n```rust=\nlet name = \"Bob\";\nprintln!(\"My name is {}.\", name);\n```\n<!-- more -->\n```rust=\nconst ID: i32 = 001;\nprintln!(\"My ID is {}.\", ID);\n```\n\n分配多個變量的值。\n```rust=\nlet ( a, b ) = (\"Alice\", 23);\nprintln!(\"{} is {}.\", a, b);\n```\n\n輸出結果\n![](gZqndHG.png)","categories":["Rust tutorials"]},{"title":"Rust 004 Format","url":"/rust-004-format/","content":"# Rust 格式化輸出\n\n格式化輸出可以讓你方便的排版你想要的輸出方式，以下我們介紹幾中常見的格式化輸出。  \n\n利用大括弧來標示變數所在的地方，由左而右依序輸出。\n```rust=\nprintln!(\"Num: {}, {}\", 1, 2);\n```\n<!-- more -->\n在大括弧內設下index，以照後面資料的順序索取你需要的資料。\n```rust=\nprintln!(\"{0} is {0} and {1} haha {2}.\", \"Bob\", \"Alice\", \"John\");\n```\n\n在大括弧內設下變數，在後面以變數給予值。\n```rust=\nprintln!(\"{a} is {b} and {c} haha {a}.\", b = \"Bob\", a = \"Alice\", c = \"John\");\n```\n\n依照型態命名，輸出則會以我們所設的型態輸出。\n```rust=\nprintln!(\"Binary: {:b}, Hex: {:x}, Octal: {:o}.\", 10, 10, 10);\n```\n\n輸出結果\n![](HgVZM4p.png)","categories":["Rust tutorials"]},{"title":"Rust 003 Function","url":"/rust-003-function/","content":"# Rust 函式\n\n我們可以在src下創建一個新的檔案`print.rs`，編寫一下程式。\n\n```rust=\npub fn run(){\n    println!(\"Hello print.rs run!!\")\n}\n```\n<!-- more -->\n然後我們回到主程式來引用我們寫得函式。\n\n\n```rust=\nmod print;\n\nfn main() {\n    print::run();\n}\n\n```\n\n接著執行就可以看到我們的結果了。\n\n![](iMTn529.png)","categories":["Rust tutorials"]},{"title":"Rust 002 Project","url":"/rust-002-project/","content":"# Rust 第一個專案\n\n安裝完RUST後我們可以開始寫我們第一個RUST得程式了，首先我們先下`cargo init`這將會替我們創建一些基本的檔案。\n\n```bash=\n$ cargo init\n```\n<!-- more -->\n![](uMvHeRj.png)\n\n目錄應該是長下面這樣，`Cargo.toml`裡面寫的是一些設定檔案，版本訊息等等，`main.rs`則是我們主要寫程式的地方。\n```\n.\n|-- Cargo.toml\n`-- src\n    `-- main.rs\n```\n\n然後打開`main.rs`編寫我們第一個RUST程式。\n```rust=\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n接著執行程式\n\n```bash=\n$ cargo run\n```\n\n![](J4JlXIU.png)\n\n執行完後你會看到你剛剛寫的`Hello, world!`印在終端機上面。\n\n如果你不想要執行程式的話可以輸入`build`就好。\n```bash=\n$ cargo build\n```\n![](vudWD4D.png)","tags":["rust"],"categories":["Rust tutorials"]},{"title":"Rust 001 Install","url":"/rust-001-install/","content":"# RUST 介紹與安裝\n## 優點\n\n安全：Rust 擁有豐富類型系統和所有權模型，保證了內存安全性和線程安全性。\n\n並發：Rust 可讓程序在編譯時並發執行，也就是多個事件在同一時間間隔執行，並且將安全與並發完美統一。\n\n高效：Rust 快且節省內存。\n\n<!-- more -->\n## 安裝 RUST\n到[RUST](https://www.rust-lang.org/)的官網按下`get started`然後你會看到下載畫面，選擇你的作業系統下載對應的下載檔案，通常他會先替你選好。\n\n![](E2SfgQY.png)\n\n打開你下載好的`rustup-init`檔案，打開後你會看到他所幫你安裝的路徑等資訊，接著在終端機內輸入1使用預設的安裝。\n\n![](MOrVY0n.png)\n\n  \n安裝完後可以在終端機輸入`rustc --version`和`cargo --version`查看你所安裝版本。\n\n\n接下來下載`Visual Studio Code`，打開後點擊左邊第四個選項來新增RUST套件，新增完後重新載入`Visual Studio Code`，然後右下角會跳出安裝RUST提醒就直接`install`。\n![](Dt3OZKz.png)\n\n新建一個`hello.rs`然後打開檔案將以下程式碼寫入。\n\n```rust=\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n完成後打開終端機到檔案下的目錄執行下面的指令。\n```bash=\n$ rustc hello.rs\n$ ./hello\n```","tags":["rust"],"categories":["Rust tutorials"]},{"title":"Parallel Programming MS-MPI install","url":"/parallel-001-MS-MPI-install/","content":"# Parallel Programming 平行程式\n平行計算是一種類型的計算，許多計算或執行過程是同時進行的。把大問題分為小問題，然後同時解決。以下式建置平行程式環境的流程。\n\n<!-- more -->\n## MS-MPI 安裝教學\n首先打開[MS-MPI](https://docs.microsoft.com/en-us/message-passing-interface/microsoft-mpi)然後到下載的地方點擊MS-MPI vxx.x.x，如下圖紫色字體。\n\n![](Otdr8uZ.png)\n\n接著將所有檔案打勾然後按下一步就會把檔案下載下來了。\n\n![](a8jSD2x.png)\n\n下載下來後執行並下移步到底，若要更換路徑請自行記得路徑。  \n接著打開Visual Studio 開啟一個C++專案。\n\n![](hfmZ9fk.png)\n\n點擊右邊專案右鍵，屬性。\n\n![](eC9A1o6.png)\n\n打開後按`C/C++`->`其他include目錄`，將剛剛按裝好的`MPI/Include`路徑設好。\n\n![](1LVNsYp.png)\n\n![](tXWUuIj.png)\n\n建置完後就會產出一個`.exe`的檔案。\n\n![](1q8F8cx.png)\n\n```c=\n#include <mpi.h>\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n\tint rank, size;\n\tMPI_Init(&argc, &argv);\n\n\tMPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\tMPI_Comm_size(MPI_COMM_WORLD, &size);\n\n\tprintf(\"Hello, World.  I am %d of %d\\n\", rank, size);\n\n\tMPI_Finalize();\n\treturn 0;\n}\n```\n\n![](HKDJrkG.png)\n\n將終端機打開`source\\repos\\MpiTest\\Debug`執行面下指令(這個路徑是你的專案路徑，因此可能會有所不同)，你就會看到下圖結果。\n```bash=\n$ mpiexec -n 4 MpiTest.exe\n```\n若無此指令請確認環境變數是否有設定完成。  \n![](aXnvwD9.png)","categories":["Parallel Programming"]},{"title":"Codeforces 1426D","url":"/Non-zero-Segments/","content":"# Codeforces 1426D - Non-zero Segments\n[題目網址](https://codeforces.com/problemset/problem/1426/D)\n\n#### 題意:\nKolya有一陣列a，裡面數字有正有負，因為Kolya不喜歡0所以不包含0，Kolya也不喜歡子陣列中的總合為0(子陣列為一個連續的範圍)。\n你要幫Kolya調整陣列使得任意子陣列總和不為0，你可以在陣列中的任一位置插入任意數字，就算數字超過可顯示範圍也行，請找出「最少」需要插入的數字的次數。\n<!-- more -->\n#### 思路:\n需要從a<sub>i</sub>加到a<sub>j</sub>, (i < j)來確認總和，因此是個前綴和的問題，從開頭開始加，用map紀錄出現過的總和，對每次的總和作判斷，如果前面出現過相同的總和代表在這區間中有子陣列總和為0，例: a=[8 5 -5]，子陣列總和=[8 13 8]，8重複出現可以發現因為有子陣列[5 -5]總和為0的關係，因此這區間需要插入一個數，因為插入一個數的關係，所以左邊的區間總和不會出現0，因此出現過的總和(map)需要重置，重新計算總和。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/cb5049de13da8958e88679cb0375f3ac.js\"></script>","tags":["sortings","greedy","constructive algorithms","data structures","1500"],"categories":["Codeforces"]},{"title":"Codeforces 1426C","url":"/Increase-and-Copy/","content":"# Codeforces 1426C - Increase and Copy\n[題目網址](https://codeforces.com/problemset/problem/1426/C)\n\n#### 題意:\n你有一陣列a，一開始只有一個元素1(a = [1])，每次動作你能做以下一種事:\n1.對a中其中一個元素+1\n2.對a中其中一個元素做複製，並放在陣列最後面\n你要找出「最小」次數的動作讓陣列a裡的元素總和至少為n。\n<!-- more -->\n#### 思路:\n要次數最小，所以一次動作加越多數字越好，因此應該是先+1到某個數字後在做複製，根據數學可以知道某數的平方數字最大(算幾)，也會發現執行動作次數最少，所以要加到sqrt(n)之後作複製到超過n所需的次數。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/6e6e6cc5ae4c3bd72ddfc6b89c8d648b.js\"></script>","tags":["math","binary search","constructive algorithms","1100"],"categories":["Codeforces"]},{"title":"Codeforces 1426B","url":"/Symmetric-Matrix/","content":"# Codeforces 1426B - Symmetric Matrix\n[題目網址](https://codeforces.com/problemset/problem/1426/B)\n\n#### 題意:\nMasha有n種類型2x2大小的磁磚，磁磚上每格各有一個數字，Masha想利用這幾種磁磚組成mxm的矩形(可用任意種類與任意數量組成)，然後Masha希望這個矩形上的數字是對稱的--對任一對位置(i,j)要符合s[i][j] = s[j][i]，請問Masha有辦法組成他想要的矩形嗎?\n<!-- more -->\n#### 思路:\n當m為奇數就不可能用2x2組成，觀察後可以發現當磁磚右上與左下數字相同必能符合對稱條件，反之則不符合對稱條件，因此在n種磁磚中有一種右上左下數字相同就能組成。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/bded1c9c1f388bf6a4f1a331a2a08147.js\"></script>","tags":["implementation","900"],"categories":["Codeforces"]},{"title":"Codeforces 1426A","url":"/Floor-Number/","content":"# Codeforces 1426A - Floor Number\n[題目網址](https://codeforces.com/problemset/problem/1426/A)\n\n#### 題意:\nVasya拜訪Petya，Petya在公寓的第n號房間，公寓裡第一層房間為1號、2號，第二層開始每層有x間房間，請問Petya的房間在第幾層?\n<!-- more -->\n#### 思路:\n根據題目公式計算n在哪個區間，並進行樓層計算。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/0e7813a59b9e23c50d8364af4c850a65.js\"></script>","tags":["implementation","math","800"],"categories":["Codeforces"]},{"title":"CodeForces 1418B","url":"/Negative-Prefixes/","content":"# CodeForces 1418B - Negative Prefixes\n[題目網址](https://codeforces.com/problemset/problem/1418/B)\n\n#### 題意:\n你有一個陣列a，裡面有n個整數，有些整數被鎖住有些沒有，你能對沒有鎖住的整數做交換位置的動作(沒鎖對沒鎖)，另外有個序列p，為a<sub>1</sub>~a<sub>n</sub>的總和:p<sub>1</sub> = a<sub>1</sub>, p<sub>2</sub> = a<sub>1</sub> + a<sub>2</sub>... p<sub>n</sub> = a<sub>1</sub> + a<sub>2</sub> +...+ a<sub>n</sub>\n讓k為最大值j，並且p<sub>j</sub> < 0 ，若p中沒有任何p<sub>j</sub> < 0，則 k=0\n你要交換未鎖住整數的位置，使得k為最小值，印出調整過後的陣列a\n<!-- more -->\n#### 思路:\n將沒鎖住的整數獨立出來，由大到小排序，再依序從頭一一放回陣列中沒鎖住的位置。\n不考慮鎖住的數字，當正整數總和 >= 負整數總和時，將正整數排前面則k=0\n當正整數總和 < 負整數總和時，則不管甚麼順序k最大\n不選擇小排到大是因為第一個狀況，若負整數先在前面則k值不會最小\n\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/14bcb2bffc5c9b8cd2341a8758f78b47.js\"></script>","tags":["sortings","greedy","1300"],"categories":["Codeforces"]},{"title":"CodeForces 1418A","url":"/Buying-Torches/","content":"# CodeForces 1418A - Buying Torches\n[題目網址](https://codeforces.com/problemset/problem/1418/A)\n\n#### 題意:\n你玩遊戲想要製作k個火把，每個火把需要一根棒子和一個煤炭，一開始你只有一根棒子,你能跟商人做兩種交易:\n    1.用一根棒子交換x根棒子\n    2.用y根棒子交換一個煤炭\n每次只能做其中一種交易，請問你需要k個火把「最少」需要幾次交易? (測資必存在解答)\n<!-- more -->\n#### 思路:\n數學問題，幾個煤炭就需要交易幾次，並且煤炭等於y根棒子，所以交易次數=到達所需棒子量的交易次數+換煤炭的次數。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/fce4c025b50df9f1982acbd833a09d91.js\"></script>","tags":["math","1000"],"categories":["Codeforces"]},{"title":"AOJ ALDS1_8_C - Binary Search Tree III","url":"/ALDS1-8-C-Binary-Search-Tree-III/","content":"# 二元樹搜索 - 刪除\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_C)\n\n#### 題意:\n編程一個擁有新增、查詢、刪除功能的二元樹，在每次新增點時，如果key大於node->key，就新增在node->right，否則新增在node->left。最後輸出Preorder與Inorder。\n<!-- more -->\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/e5a835cfa1a3f511e096388e9697423c.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_8_B - Binary Search Tree II","url":"/ALDS1-8-B-Binary-Search-Tree-II/","content":"# 二元樹搜索 - 查詢\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_B)\n\n#### 題意:\n編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node->key，就新增在node->right，否則新增在node->left。最後輸出Preorder與Inorder。\n\n<!-- more -->\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/64cf5d826826134e302151c569adb7d8.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_8_A - Binary Search Tree I","url":"/ALDS1-8-A-Binary-Search-Tree-I/","content":"# 二元樹搜索 - 新增\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_A)\n\n#### 題意:\n編程一個擁有新增功能的二元樹，在每次新增點時，如果key大於node->key，就新增在node->right，否則新增在node->left。最後輸出Preorder與Inorder。\n\n<!-- more -->\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/f392df5b2c8130b6eeff6a0b8c1b82bb.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_7_C - Tree Walk","url":"/ALDS1-7-C-Tree-Walk/","content":"# 樹遍歷\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_C)\n\n#### 題意:\n您的任務是編寫一個程序，該程序根據以下算法執行樹遍歷（系統遍歷樹中的所有例程）：\n\n1. 根、左子樹和右子樹(preorder)。\n2. 左子樹、根子樹和右子樹(inorder)。\n3. 左子樹、右子樹和根(postorder)。\n\n<!-- more -->\n#### 思路:\n創建一個結構left代表左子樹，right代表右子樹，pr代表父節點用於檢查是否為跟節點。\n\n創建一個帶有結構的陣列依序填入所有值。\n```C++\nfor(int i = 0; i < n; i++){\n    cin >> key >> left >> right;\n    \n    tree[key].left = left;\n    tree[key].right = right;\n    tree[left].pr = key;\n    tree[right].pr = key;\n    node[i] = key;\n}\n```\n\n接著尋找父節點，輸入的所有節點檢查pr為-1就是父節點。\n```C++\nint getRoot(Node* tree, int *node, int n){\n    int root = 0;\n    for(int i = 0; i < n; i++){\n        if(tree[node[i]].pr == -1){\n            root = node[i];\n        }\n    }\n    return root;\n}\n```\n最後利用題目上敘的規則遞迴輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b95063f99f1a85b8b827f35fe13c2c35.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_7_B - Binary Tree","url":"/ALDS1-7-B-Binary-Tree/","content":"# 二元樹\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_B)\n\n#### 題意:\n有根的二叉樹是具有根節點的樹，其中每個節點最多有兩個子節點。\n\n您的任務是編寫一個程序，該程序讀取有根的二叉樹T並為T的每個節點u打印以下信息：\nnode ID of u (節點編號)\nparent of u (節點父親)\nsibling of u (節點兄弟)\nthe number of children of u (節點小孩數目)\ndepth of u (節點深度)\nheight of u (節點高)\nnode type (root, internal node or leaf) (節點狀態)\n<!-- more -->\n#### 思路:\n##### sibling 兄弟\n如果左節點跟右節點都不為-1就代表有兄弟。\n```C++\nif(tree[id].left != -1 && tree[id].right != -1) {\n    tree[left].sibling = right;\n    tree[right].sibling = left;\n}\n```\n##### degree ＆ children parent 子節點個數與子節點父親\n計算子節點數並順便將子節點的父親標記。\n```C++\nif(left != -1) {\n    tree[id].degree++;\n    tree[left].parent = id;\n}\nif(right != -1) {\n    tree[id].degree++;\n    tree[right].parent = id;\n}\n```\n\n##### height 節點高度\n一直往下找然後比較最大的深度回傳。\n```C++\nint dfs(Node *tree, int key) \n{ \n    if (tree[key].left == -1 && tree[key].right == -1) {\n        return 0;\n    }\n    if (tree[key].left == -1) {\n        return dfs(tree, tree[key].right) + 1; \n    }\n    if (tree[key].right == -1) {\n        return dfs(tree, tree[key].left) + 1; \n    }\n    \n    return max(dfs(tree, tree[key].left), dfs(tree, tree[key].right)) + 1; \n} \n```\n\n##### depth 深度\n從根往下並沿路標記深度，深度則是由父親的深度加一就可以得到自己的深度。\n```C++\nvoid depth(Node *tree, int key){\n    if(tree[key].parent != -1){ \n        tree[key].depth = tree[tree[key].parent].depth + 1;\n    }\n    if(tree[key].left != -1){\n        depth(tree, tree[key].left);\n    }\n    if(tree[key].right != -1){\n        \n        depth(tree, tree[key].right);\n    }\n    return;\n}\n```\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/400e539d787926ef7fc0ef89f881f4a5.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_7_A - Rooted Trees","url":"/ALDS1-7-A-Rooted-Trees/","content":"# 根樹\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_A)\n\n#### 題意:\nRooted Trees是連接的，無環的，無向的圖。Rooted Trees是一種自由樹，其中一個頂點與另一個頂點是不同的。Rooted Trees的頂點稱為“節點”。\n你的任務是編寫一個程序，為給定的根樹T的每個節點u報告以下信息：\nnode ID of u (節點編號)\nparent of u (節點父親)\ndepth of u (節點深度)\nnode type (root, internal node or leaf)\na list of chidlren of u (列出節點小孩)\n<!-- more -->\n#### 思路:\n先創立一個結構parent、depth、type和internalNode方便紀錄我們的資料，接下來我們輸入每筆資料的時候就把自己節點的父親深度加一，就可以得到自己節點的深度，然後在子節點裡面，我們也做一樣的事情然後順便紀錄子節點的父親。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/c3dfdc3026767577257e91a5902bae1d.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_6_C - Quick Sort","url":"/ALDS1-6-C-Quick-Sort/","content":"# 快速排序\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_C)\n\n#### 題意:\n快速排序有三個步驟：\n1.挑選基準值：從數列中挑出一個元素，稱為「基準」（pivot)。\n\n2.分割：重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面（與基準值相等的數可以到任何一邊）。在這個分割結束之後，對基準值的排序就已經完成。\n\n3.遞迴排序子序列：遞迴地將小於基準值元素的子序列和大於基準值元素的子序列排序。\n\n完成排序後檢查出現順序是否依照順序，例如先輸入\"D 1\"、\"H 1\"，輸出時若為\"D 1\"、\"H 1\"就輸出\"Stable\"，否則輸出\"Not stable\"。\n\n<!-- more -->\n#### 思路:\n按照上面快速排序的步驟編寫。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b1de01e5346182490fa59fec396ecd2c.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_6_B - Partition","url":"/ALDS1-6-B-Partition/","content":"# 快速排序劃分\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_B)\n\n#### 題意:\n\n快速排序有三個步驟：\n1.挑選基準值：從數列中挑出一個元素，稱為「基準」（pivot）。\n\n2.分割：重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面（與基準值相等的數可以到任何一邊）。在這個分割結束之後，對基準值的排序就已經完成。\n\n3.遞迴排序子序列：遞迴地將小於基準值元素的子序列和大於基準值元素的子序列排序。\n\n而這題要做的就是分割這個動作。\n\n<!-- more -->\n#### 思路:\n如果(a[j] <= x)我們就交換，最後我們將最後一個切割點輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/2b61bf149936044aab2d398c8496b1b3.js\"></script>    ","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_6_A - Counting Sort","url":"/ALDS1-6-A-Counting-Sort/","content":"# 索引排序\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_6_A)\n\n#### 題意:\n計數排序可用於對數組中的元素進行排序，用一個陣列來計算元素有幾個，而他的index就是原本的數字裡面存的是出現次數。請利用計數排序排序下列數列。\n\n<!-- more -->\n#### 思路:\n將每個數字都放進Ｃ陣列內計數(c[a[i]]++)，處理完後從0跑到K並根據C陣列內的計數，將所有的數字輸出一遍。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/245397223969f64944326fb98f0b1e80.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_5_B - Merge Sort","url":"/ALDS1-5-B-Merge-Sort/","content":"# 合併排序\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_5_B)\n\n#### 題意:\n給你N個整數序列S創建一個程序，根據上面的虛擬碼通過合併排序由小到大進行排序。另外，請報告合併中的比較總數。\n<!-- more -->\n#### 思路:\n先拆開然後檢查左邊和右邊誰大誰小，小的放左邊大的放右邊合併，重複這個動作到結束。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/86ace3aedb574bee48d1a7869cca847c.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_5_A - Exhaustive Search","url":"/ALDS1-5-A-Exhaustive-Search/","content":"# 全面搜索\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_5_A)\n\n#### 題意:\n給N個整數數列A，Q個整數數列M，判斷A任意數字加起來是否等於Mi，如果有輸出\"yes\"，否則輸出\"no\"。\n\n<!-- more -->\n#### 思路:\n直接建一張查詢表把所有的可能加一遍並修改，之後直接查表。\n累加後遞迴然後把位子移動到下一個數字。\n```C++\nbuild(sum+a[index], index+1, n);\n```\n把自己也改變。\nbuild(sum, index+1, n);\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/ca85b1798c3535457231e0d3a4c645e9.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_4_C - Dictionary","url":"/ALDS1-4-C-Dictionary/","content":"# 字典\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_C)\n\n#### 題意:\n寫一個具備以下功能的字典程式:\ninsert str: 插入一個字串到字典裡。\nfind str: 找尋字串如果找到輸出\"yes\"，否則\"no\"。\n<!-- more -->\n#### 思路:\n利用C++的map函式來加入，使用find的功能來查詢，如果沒找會輸出0，所以我們就可以放在判斷式裡面做判斷。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/0e68ebaec599b3a3b31c9e84fbac8840.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_4_B - Binary Search","url":"/ALDS1-4-B-Binary-Search/","content":"# 二分搜索\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_B)\n\n#### 題意:\n給N個整數數列S，還有q個整數數列T，請輸出T在S裡面有找到幾個。利用二分搜索來尋找。\n\n<!-- more -->\n#### 思路:\n宣告三個變數分別紀錄左邊、右邊和中間位置，每次判斷中間那個數字是否等於要找的數字，如果沒有則判斷大於小於以利切割，如果大於的話就把r換成中間的位置，小於則把l換成中間的位置。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b7e47a957066b3bb5888030be0aac43f.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_4_A - Linear Search","url":"/ALDS1-4-A-Linear-Search/","content":"# 線性排序\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_4_A)\n\n#### 題意:\n給N個整數數列S，還有q個整數數列T，請輸出T在S裡面有找到幾個。利用線性搜索來尋找。\n\n<!-- more -->\n#### 思路:\n逐一檢查，如果相等count加一然後斷開避免重複加到。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/be27322df4e6cf323429cc22b66ebcd3.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"SwiftUI Stack","url":"/swiftui-stack/","content":"# SwiftUI Stack 堆疊方式\n在SwiftUI中有三種堆疊分別為VStack、ZStack和HStack，這些堆疊可以讓顯示的東西以不同的方式呈現。\n<!-- more -->\n## VStack 縱向堆疊\nVStack可以使文字逐一縱向的堆疊。\n```swift\nVStack() {\n    Text(\"Hello\")\n    Text(\"SwiftUI\")\n}\n```\n顯示的結果為：\nHello\nSwiftUI\n\n## HStack 橫向堆疊\nHStack可以使文字逐一橫向的堆疊。\n```swift\nHStack() {\n    Text(\"Hello\")\n    Text(\"SwiftUI\")\n}\n```\n顯示的結果為：\nHello SwiftUI\n\n## ZStack 重疊\nHStack可以使文字重疊。\n```swift\nZStack() {\n    Text(\"Hello\")\n    Text(\"SwiftUI !!\")\n}\n```\n\n## alignment與spacing 校準與間距\nalignment可以控制校準的位置，你可以把VStack內的東西靠左靠右等等等...。spacing可以控制每個區塊距離。\n```swift\nVStack(alignment: .leading, spacing: 50) {\n    Text(\"Hello\")\n    Text(\"SwiftUI !!\")\n}\n```\n\n## 多個Stack\n你可以使用多個堆疊來表現不同的樣式，例如下面代碼。\n\n```swift\nHStack(){\n    VStack() {\n        Text(\"1. Hello\")\n        Text(\"SwiftUI\")\n    }\n    VStack() {\n        Text(\"2. Hello\")\n        Text(\"SwiftUI\")\n    }\n}\n```","tags":["swiftui"],"categories":["SwiftUI tutorials"]},{"title":"SwiftUI Color","url":"/swiftui-color/","content":"# SwiftUI Hex Color 十六進至顏色轉換\n如果想要使用hex的色碼的話可以先定義好轉換方式，之後只需要設定Color裡面的hex就可以轉換成想要的顏色。當然你必須先定義好你的函式。\n<!-- more -->\n首先你需要在extension定義好色碼轉換方法，例如下面的代碼。\n\n```swift\nimport SwiftUI\n\nextension Color {\n    static let cloloABC = Color(hex: \"#FFFFFF\", alpha: 0.5)\n\n    init(hex: String, alpha: CGFloat = 1.0) {\n        var hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        if hex.hasPrefix(\"#\") {\n            hex = String(hex.dropFirst())\n        }\n        assert(hex.count == 3 || hex.count == 6 || hex.count == 8, \"Invalid hex code used. hex count is #(3, 6, 8).\")\n        var int: UInt64 = 0\n        Scanner(string: hex).scanHexInt64(&int)\n        let r, g, b: UInt64\n        switch hex.count {\n        case 3: // RGB (12-bit)\n            (r, g, b) = ((int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)\n        case 6: // RGB (24-bit)\n            (r, g, b) = (int >> 16, int >> 8 & 0xFF, int & 0xFF)\n        case 8: // ARGB (32-bit)\n            (r, g, b) = (int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)\n        default:\n            (r, g, b) = (1, 1, 0)\n        }\n\n        self.init(\n            .sRGB,\n            red: Double(r) / 255,\n            green: Double(g) / 255,\n            blue:  Double(b) / 255,\n            opacity: Double(alpha)\n        )\n    }\n}\n```\n定義完成後，你可以在ContentView裡面直接使用。\n```swift\nText(\"Hello, World!\")\n    .foregroundColor(Color.init(hex: \"#FFFFFF\", alpha: 1.0))\n```\n也可以定義在extension內這樣就可以直接使用而且不必重新設定色碼。\n```swift\nText(\"Hello, World!\")\n    .foregroundColor(Color.cloloABC)\n```","tags":["swiftui"],"categories":["SwiftUI tutorials"]},{"title":"SwiftUI Text","url":"/swiftui-text/","content":"## Text 用法\n### 顯示簡單文字\nContentView已在中生成的範例代碼向你展示瞭如何顯示一行文字。\n```swift\nText(\"Hello, World!\")\n```\n<!-- more -->\n### 更改字體類型\n#### fontWeight 文字類型\n你可以使用fontWeight來更改字體的類型，例如下面所使用的粗體字，當然字體類型有很多種像是heavy, light, medium等等等...\n```swift\nText(\"Hello, World!\")\n    .fontWeight(.bold)\n```\n\n#### font 字體樣式\n字體樣式中你可以修改字體的大小, 字形和大小。\n```swift\nText(\"Hello, World!\")\n    .font(.title)\n```\n如果想要進一步修改字體的設計你可以像這樣寫：\n```swift\n.font(.system(.largeTitle, design: .rounded))\n```\n這樣寫字體就會被修成largeTitle的樣式而且是圓弧的。\n\n該font修改器可以更改字體屬性。在上面的代碼中，我們指定使用標題字體類型以放大文本。\n\n如果要使用固定大小的字體你只要在system裡面設定size就可以了。\n```swift\n.font(.system(size: 20))\n```\n\n如果想更改字體的字型的話可以使用custom來更改字型。\n```swift\n.font(.custom(\"Helvetica Neue\", size: 25))\n```\n字體名稱可以在“字體書”中找到。您可以打開Finder應用程序，然後單擊字體簿以啟動該應用程序。\n#### shadow 陰影\n為文本增加陰影效果可以使字體更有感覺，而radius可以設定陰影的風格。\n```swift\n.shadow(color: .black, radius: 2, x: 0, y: 15)\n```\n### 更改字體顏色\n#### foregroundColor 修改顏色\n您可以使用其他內置值喜歡.red，.purple等等。如果你想知道如何使用hex色碼的話可以參考[SwiftUI Color](https://chucs.github.io/swiftui-text/)。\n\n```swift\nText(\"Hello, World!\")\n    .foregroundColor(.red)\n```\n\n### 多個修處理多行文字飾\n在SwiftUI裡支持多個修飾，你可以使用foregroundColor修改顏色fontWeight修改字體類型等等等...\n```swift\nText(\"Hello, World!\")\n    .fontWeight(.bold)\n    .font(.title)\n```\n### 處理多行文字\nText默認情況下支持多行，因此它可以顯示文本段落，而無需使用任何其他修飾符。但你可以使用一些函式來修改文本。\n```swift\nText(\"Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!\")\n    .fontWeight(.bold)\n    .font(.title)\n```\n\n#### multilineTextAlignment 修改文字位置\n要使文本置中對齊，請插入multilineTextAlignment修飾符並將值設置為.center如下所示，當然你也可以靠左對齊靠右對齊。\n```swift\n.multilineTextAlignment(.center)\n```\n\n#### lineLimit 行數行數限制\n你可能希望將行數限制為一定數量。\n```swift\n.lineLimit(3)\n```\n### 設置填充和行距\n#### lineSpacing 行距調整\n默認行間距足以應付大多數情況。如果要更改默認設置，可以使用lineSpacing修飾符來調整行距。\n```swift\n.lineSpacing(10)\n```\n#### padding 填充空間\n\n如您所見，文本太靠近邊緣的左側和右側。要給它更多的空間，可以使用padding修飾符，該修飾符為文本的每一側增加一些額外的空間。\n```swift\n.padding()\n```\n如果沒有在裡面設定數字的話就會是默認的長度。如果想要設定固定長度的話可以直接帶入數字。\n```swift\n.padding(10)\n```\n在padding修飾符中也可以設定你想要哪幾個邊做增加。\n```swift\n.padding([.top, .leading, .trailing])\n```\n\n### 旋轉文字\n#### rotationEffect 旋轉\nSwiftUI框架提供了API，無論是2D還是3D都可以讓您輕鬆旋轉文本。\n\n2D旋轉\n```swift\n.rotationEffect(.degrees(20), anchor: UnitPoint(x: 0, y: 0))\n```\n3D旋轉\n```swift\n.rotation3DEffect(.degrees(60), axis: (x: 1, y: 0, z: 0))\n```\n","tags":["swiftui"],"categories":["SwiftUI tutorials"]},{"title":"AOJ ALDS1_3_C - Doubly Linked List","url":"/ALDS1-3-C-Doubly-Linked-List/","content":"# 雙向鏈結串列\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_3_C)\n\n#### 題意:\n寫一個具備以下功能的Doubly Linked List:\ninsert x: 加入一個元素x在list的最前面.\ndelete x: 刪除一個元素x. 如果沒有找到，不必做任何動作.\ndeleteFirst: 刪除list第一個元素.\ndeleteLast: 刪除list最後一個元素.\n<!-- more -->\n#### 思路:\n\n##### 節點\n```C++\nstruct Node{\n\tint data;\n    // 上一個節點\n\tNode* prev;\n    // 下一個節點\n\tNode* next;\n};\n```\n首先我們要先宣告一個結構分別為資料,上個節點和下一個節點。\n\n##### 新增數字\n```C++\nvoid insertNode(int x){\n    Node* tmpNode = motherNode->next;\n    motherNode->next = new Node();\n    motherNode->next->data = x;\n    motherNode->next->next = tmpNode;\n    motherNode->next->prev = motherNode;\n    tmpNode->prev = motherNode->next;\n};\n```\n先新增一個新節點然後將資料放入後，與主節點做連接。\n\n##### 刪除數字\n```C++\nvoid deleteNode(int x){\n    Node* tmpNode = motherNode->next;\n    while(tmpNode != motherNode && tmpNode->data != x){\n        tmpNode = tmpNode->next;\n    }\n    if(tmpNode != motherNode){\t\n        tmpNode->prev->next = tmpNode->next;\n        tmpNode->next->prev = tmpNode->prev;\n        delete tmpNode;\n    }\n};\n```\n逐一檢查節點資料是否為x，如果找到了就將next與prev的節點換成下一個位置的，然後刪除節點。\n\n##### 刪除最前面的\n```C++\nvoid deleteFirst(){\n    Node* tmpNode = motherNode->next;\n    motherNode->next = motherNode->next->next;\n    motherNode->next->prev = motherNode;\n    delete tmpNode;\t\n};\n```\n將最前面的節點交換後與主節點連接，然後再將他刪除。\n##### 刪除最後面的\n```C++\nvoid deleteLast(){\n    Node* tmpNode = motherNode->prev;\n    motherNode->prev = motherNode->prev->prev;\n    motherNode->prev->next = motherNode;\n    delete tmpNode; \n};\n```\n將最後面的節點交換後與主節點連接，然後再將他刪除。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b9f0ee48e8f8965c9b8b30ecaeee9afe.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_3_B - Queue","url":"/ALDS1-3-B-Queue/","content":"# 隊列\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_3_B)\n\n#### 題意：\n在稱為循環調度的處理方法中，CPU按順序處理進程。每個過程最多處理ms（也就輸入中的q）。如果已經完成q毫秒，但是該過程尚未完成，則移至該行的末尾，就有CPU分配給下一個過程。如果這個進程結束了那就輸出花費時間。\n\n<!--more-->\n\n#### 思路：\n利用queue先進先出的規則把所有的進程進行排序，然後按照順序依次執行的時間，並設置一個變數訪問轉換時間，直到所有進程結束。\n\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/c107bef46c7fcda613c6628d2849004c.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_3_A - Stack","url":"/ALDS1-3-A-Stack/","content":"# 堆疊\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_3_A)\n\n#### 題意:\nReverse Polish表示法是每個運算符都遵循其所有操作數的一種表示法。例如，正常符號中的表達式（1 + 2）*（5 + 4）可以用Reverse Polish表示為1 2 + 5 4 + *。Reverse Polish的優點之一是它沒有括號。\n\n編寫一個程序，該程序以\"Reverse Polish\"符號讀取表達式並打印計算結果。\n<!-- more -->\n#### 思路:\n利用stack先進後出的規則存取每個數字，遇到＋,-,*就把上面兩個數字排出並作運算，算完後再放入stack中。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/c3b0db7392bc501256200706688ca8bc.js\"></script>","tags":["implementation"]},{"title":"AOJ ALDS1_2_C - Stable Sort","url":"/ALDS1-2-C-Stable-Sort/","content":"# 穩定排序\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_2_C)\n\n#### 題意:\n讓我們安排一副紙牌。總共有36張卡，四個狀態（S，H，C，D）和9個值（1、2，... 9）。\n請將他們由小到大排序，並檢查排序結果是否有按照出現順序排序。例如：輸入 \"D1 S2 H2\"，排序結果為\"D1 H2 S2\"，而在輸入時S2比H2前面因此輸出\"Not stable\"，若排序結果為\"D1 S2 H2\"，那麼輸出\"Stable\"。\n\n<!-- more -->\n#### 思路:\n先宣告一個結構儲存三個狀態分別為，狀態、數字和輸入順序，利用此結構進行選擇排序與泡沫排序，排序完後檢查陣列，如果數字一樣而且前面順序大於後面那就代表不穩定。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/78500fcd44526355e664551e4333f5aa.js\"></script>","tags":["sortings"],"categories":["AOJ"]},{"title":"AOJ ALDS1_2_B - Selection Sort","url":"/ALDS1-2-B-Selection-Sort/","content":"# 選擇排序\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_2_B)\n\n#### 題意:\n利用選擇排序排序，當i不等於mini時才交換，請把結果與交換次數輸出。\n<!-- more -->\n#### 思路:\n```\nSelectionSort(A)\n    for i = 0 to A.length-1\n        mini = i\n        for j = i to A.length-1\n            if A[j] < A[mini]\n                mini = j\n        swap A[i] and A[mini]\n```\n先將一個數字的位置記住後逐一比較，如果比他大就將mini取代新的index，全部比較完後在進行交換。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/687c3ee75d3561997469a9830b92b038.js\"></script>","tags":["sortings"],"categories":["AOJ"]},{"title":"AOJ ALDS1_2_A - Bubble Sort","url":"/ALDS1-2-A-Bubble-Sort/","content":"# 泡沫排序\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_2_A)\n\n#### 題意:\n利用泡沫排序排序，將結果與交換次數輸出。\n<!-- more -->\n#### 思路:\n```\nBubbleSort(A)\n    for i = 0 to A.length-1\n        for j = A.length-1 downto i+1\n            if A[j] < A[j-1]\n                swap A[j] and A[j-1]\n```\n一邊比較一邊交換。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/d75e8bdad871d3b66348390c03f6f3d5.js\"></script>","tags":["sortings"],"categories":["AOJ"]},{"title":"Asm mips - 006 Function","url":"/asm-mips-006-function/","content":"# MIPS 組合語言 - 函式\n#### 題意:\n練習函式運用。\n<!-- more -->\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/2e7d22f2102929bf98e470d680b6b25c.js\"></script>","tags":["asm","mips"],"categories":["Assembly tutorials"]},{"title":"Asm mips - 005 Hanoi Tower","url":"/asm-mips-005-hanoi-tower/","content":"# MIPS 組合語言 - 河內塔\n#### 題意:\n模擬寫出河內塔。\n<!-- more -->\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b114dedc3df3b665bdc0eadf50c0d087.js\"></script>","tags":["asm","mips"],"categories":["Assembly tutorials"]},{"title":"Asm mips - 004 Prime","url":"/asm-mips-004-prime/","content":"# MIPS 組合語言 - 質數\n#### 題意:\n計算出它們得質數。\n\n<!-- more -->\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b2190f4dddb8a3a43e313abd9a9bade5.js\"></script>","tags":["asm","mips"],"categories":["Assembly tutorials"]},{"title":"Asm mips - 003 Lcm","url":"/asm-mips-003-lcm/","content":"# MIPS 組合語言 - 最小公倍數\n#### 題意:\n計算出它們的LCM。\n<!-- more -->\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/3cddb97cafa6b617502deb933d218ffa.js\"></script>","tags":["asm","mips"],"categories":["Assembly tutorials"]},{"title":"Asm mips - 002 Gcd","url":"/asm-mips-002-Gcd/","content":"# MIPS 組合語言 - 最大公因數\n#### 題意:\n計算出它們的ＧＣＤ\b。\n<!-- more -->\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/56203d26f0387610b8715cb5ee8d0ffa.js\"></script>","tags":["asm","mips"],"categories":["Assembly tutorials"]},{"title":"Asm mips - 001 Array","url":"/asm-mips-001-array/","content":"# MIPS 組合語言 - 陣列\n#### 題意:\n練習陣列存取資料。\n\n<!-- more -->\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/e4a349347dfa68b2fec32d3551e3b8e1.js\"></script>","tags":["asm","mips"],"categories":["Assembly tutorials"]},{"title":"Asm x86 - 007 Score","url":"/asm-x86-007-Score/","content":"# x86 組合語言 - 計算學生成績\n#### 題意:\n計算多位同學的成績並排名。\n\n<!-- more -->\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/f271f806310b4cf84e8cb23861cf27ee.js\"></script>","tags":["asm","x86"],"categories":["Assembly tutorials"]},{"title":"Asm x86 - 006 Prime","url":"/asm-x86-006-prime/","content":"# x86 組合語言 - 質數相乘與相加\n#### 題意:\n找出所有質數相加。\n<!-- more -->\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/653b1ecce943f3cfb55285bfafc6715f.js\"></script>","tags":["asm","x86"],"categories":["Assembly tutorials"]},{"title":"Asm x86 - 005 LIS","url":"/asm-x86-005-LIS/","content":"# x86 組合語言 - LIS\n#### 題意:\n最長遞增子序列，像是 1 4 5 3 9 就是一個由五個數字組成的 sequence 。至於 subsequence ，是指從一個 sequence 之中，依照由左到右的順序，挑幾個數字出來，就是 subsequence 。其中一個答案就是1 4 5 9。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/04b78c7d3d36562a6e56364a83827dab.js\"></script>","tags":["asm","x86"],"categories":["Assembly tutorials"]},{"title":"Asm x86 - 004 Hanoi Tower","url":"/asm-x86-004-Hanoi-Tower/","content":"# X86 組合語言 - 河內塔\n#### 題意:\n模擬用遞迴寫出河內塔\n<!-- more -->\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/bf03b99711cb5ae64008b121c45faab1.js\"></script>","tags":["asm","x86"],"categories":["Assembly tutorials"]},{"title":"Asm x86 - 003 GCDLCS","url":"/asm-x86-003-GCDLCS/","content":"# X86 組合語言 - GCD & LCS\n#### 題意:\n計算ＧＣＤ和ＬＣＳ\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/d98a40295a2e6fd4b4a6f06daa0f05b1.js\"></script>","tags":["asm","x86"],"categories":["Assembly tutorials"]},{"title":"Asm x86 - 002 Equation","url":"/asm-x86-002-Equation/","content":"# X86 組合語言 - 計算一元二次方程式\n\n#### 題意:\n計算一元二次方程式，且判斷各種不同的答案。\n\n<!-- more -->\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/8ddf9172e00e31107d5334798e21ff73.js\"></script>","tags":["asm","x86"],"categories":["Assembly tutorials"]},{"title":"Asm x86 - 001 Clockwise Area","url":"/asm-x86-001-Clockwise-area/","content":"# X86 組合語言 - 多個點面積\n#### 題意:\n利用矩陣順時針輸入計算多個點的面積。\n<!-- more -->\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/8451a71f9bfaf866139cd2fb06bc7e2c.js\"></script>","tags":["asm","x86"],"categories":["Assembly tutorials"]},{"title":"x86 Assembly Programming Tutorial","url":"/asm-x86-tutorial/","content":"# x86組合語言指令集\n## ● 摘要:\nx86是組合語言的其中一種，在組合語言裡所有的運算都必須透過暫存器來計算，在這邊整理了組合語言的指令範例方便大家學習使用。\n\n<!-- more -->\n## ● 框架\n在組合語言裡分為兩個部分，分別為資料與運行得程式碼。在資料(.data)裡就如同宣告一個變數一樣，在程式碼(.code)內就是你所要執行的內容。\n```\nINCLUDE Irvine32.inc \t;函式庫\n.data\n    ;資料\n.code\nmain PROC\n    ;運行的程式碼\nexit\nmain ENDP\n```\n\n## ● 資料大小與暫存器\n### ◆ 指令與資料大小\n在宣告變數時你還需要指定這個變數的大小，因此你必須了結每個指令所對應的位元數。\n\n指令    | 位元 |\n-----  | --- |\nBYTE   | 8-bit無號整數\nSBYTE  | 8-bit有號整數\nWORD   | 16-bit無號整數\nSWORD  | 16-bit有號整數\nDWORD  | 32-bit無號整數\nSDWORD | 32-bit有號整數\nFWORD  | 48-bit整數\nQWORD  | 64-bit整數\nTBYTE  | 80-bit整數\nREAL4  | 32-bit (4 byte)  IEEE短實數\nREAL8  | 64-bit (8 byte)  IEEE長實數\nREAL10 | 80-bit (10 byte) IEEE延伸實數\n\n### ◆ 暫存器\n在組合語言裡所有的運算都必須透過暫存器運算完後在放回變數內。\n\n指令    | 暫存器 |\n-----  | --- |\nBYTE  \t| 8位元通用暫存器:  AH、AL、BH、BL、CH、CL、DH、DL\nWORD  \t| 16位元通用暫存器: AX、BX、CX、DX、SI、DI、SP、BP\nDWORD \t| 32位元通用暫存器: EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP\n\n\n## ● 資料宣告\n\n```\n.data\nMsg BYTE \"hello ASM world!\", 0\narray DWORD 100 DUP(0)                  ;空陣列\nID BYTE 100 DUP (0)                     ;空字串\nasec DWORD 0                            ;變數\n```\n\n## ● 移動資料\n\n```\nmov eax, 10\t                            ;eax = 10\nmov ebx, eax                            ;ebx = eax\nmovzx al, eax                           ;較小值移至到較大值\n```\n\n## ● 運算範例\n### ◆ 根號\nmid為要被開根號的值。\n\n```\nmov ebx, 2\nW1:\n    mov eax, ebx\n    imul ebx\n    cmp mid, eax\n    JB W2\n    inc ebx\t\n    jmp W1\nW2:\ndec ebx\nmov eax, ebx\ncall WriteDec\t;eax = 開完根號的值\n```\n\n### ◆ 乘法\n5 * 5 = 25\n\n```\nmov ebx, 5\nmov eax, 5\nimul ebx \t \t;有號\nmul ebx \t\t;無號\ncall WriteDec \t;eax = 25\t\n```\n\n### ◆ 除法\n10 / 5 = 2 \n相除完後的餘數會放在edx這個暫存器內，所以如果你列印edx他會顯示0。\n\n```\nmov edx, 0\t\t;餘數\nmov eax, 10\t\t;商\nmov ebx, 5\t\t;除數\nidiv ebx \t\t;有號\ndiv ebx \t\t;無號\ncall WriteDec\t;ans = 2\n```\n\n### ◆ 減法\n10 - 5 = 5\n兩數相減。\n\n```\nmov eax, 10\nmov ebx, 5\nsub eax, ebx \t;小數\nsbb eax, ebx \t;大數\ncall WriteDec\t;ans = 5\n```\n\n### ◆ 加法\n10 + 5 = 15\n兩數相加。\n\n```\nmov eax, 10\nmov ebx, 5\nadd eax, ebx \t;小數\nadc eax, ebx \t;大數\ncall WriteDec\t;ans = 15\n```\n\n### ◆ 加一\n你可以使inc來對暫存器直接加一，又或者用sub這個指令來作加一的動作。\n```\nmov eax, 1\nadd eax, 1\ninc eax\ncall WriteDec \t;ans = 2\n```\n\n### ◆ 減一\n你可以使用dec來對暫存器直接減一，又或者用sub這個指令來作減一的動作。\n\n```\nmov eax, 2\nsub eax, 1 \ndec eax\ncall WriteDec \t;ans = 1\n```\n\n## ● 輸入與輸出\n### ◆ 換行\n\n```\ncall Crlf\n```\n\n### ◆ 輸入字串\n#### 多個字串輸入\n\n```\nlea EDX, ID[ESI]\nmov ECX, ( SIZEOF ID ) - 1 \ncall ReadString\nadd esi, 10\t\t\t;移動10格\n```\n\n#### 單一字串輸入\n\n```\nmov edx, OFFSET ID\nmov ecx, (SIZEOF ID) - 1\ncall ReadString\t\ncall WriteDec\t\t;字串長度會暫存EAX\n```\n\n### ◆ 輸出字串\n在這邊記得要依照陣列宣告的大小做對應的移動，例如字串就是BYTE所以每一個字都是移動一格。\n#### 多個字串輸出\n\n```\nlea EDX, ID[esi]\ncall WriteString\nadd esi, 12\t\t\t;移動12格\n```\n\n#### 資料字串輸出\n\n```\nMOV EDX, OFFSET Msg1\ncall WriteString\n```\n\n### ◆ 輸入數字\n#### 單一數字輸入\n\n```\n\tcall ReadDec\t\t;暫存EAX\n\tcall RedaInt\t\t;帶正負號\n```\n\n#### 陣列數字輸入\n\n```\n\tcall ReadDec\n\tmov array2[esi*4], eax\n\tinc esi\n```\n\n### ◆ 輸出數字\n#### 單一數字輸出\n\n```\nmov eax, 10\ncall WriteDec\t\t;Output = 10\ncall WriteInt\t\t;Output = +10\n```\n\n#### 陣列數字輸出\n\n```\nmov  eax, array2 [esi*4]\ncall WriteDec\ninc esi\n```\n\n## ● 比較\n\n```\nL1:\n    mov eax, 10\n    mov ebx, 5\n    cmp eax, ebx\n    JA L1\t\t;if(eax > ebx)則跳到L1\n```\n\n### ◆ 特殊的 flag 值\n指令   | 運算 | 指標 \n----- | --- | ---- \nJZ  | 若為零則跳        | ZF=1 \nJNZ | 若為不零則跳       | ZF=0  \nJC  | 若進位則跳     | CF=1\nJNC  | 若不進位則跳    | CF=0\nJO | 若溢位則跳         | OF=1 \nJNO  | 若不溢位則跳    | OF=0\nJS  | 若負號則跳        | SF=1\nJNS | 若非負號則跳      | SF=0 \nJP  | 同位(偶)則跳      | PF=1\nJNP | 非同位(奇)則跳    | PF=0\n\n### ◆ 兩運算元是否相等或(E)AX的值    \n指令   | 運算 | 範例 \n----- | --- | ---- \nJZ  | 相等則跳        | if(left == right)\nJNZ | 不相等則跳       | if(left != right) \nJC  | 若 CX = 0 則跳     | \nJNC  | 若 ECX = 0 則跳    | \n\n### ◆ 無號運算元的比較\n指令   | 運算 | \n----- | --- | \nJA  | 較大則跳        \nJNBE | 不是較小或相等則跳(=JA)       \nJAE  | 較大或相等則跳     \nJNB  | 不是較小則跳(=JAE)   \nJB | 較小則跳         \nJNAE  | 不是較大或相等則跳(=JB)   \nJBE  | 較小或相等則跳        \nJNA | 不是較大則跳(=JBE)     \n\n\n### ◆ 帶正負號運算元間的比較\n指令   | 運算 | \n----- | --- | \nJG\t |\t較大則跳\nJNLE |\t非較小或相等則跳(=JG)\nJGE\t |\t較大或相等則跳\nJNL\t |\t不是較小則跳(=JGE)\nJL\t |\t較小則跳\nJNGE |\t非較大或相等則跳(=JL)\nJLE\t |\t較小或相等則跳\nJNG\t |\t不是較大則跳(=JLE)\n\n## ● 迴圈\n### ◆ 32以內的迴圈\n```\nmov ecx, 5\t;次數\nL1:\n    ;內容\nloop L1\n```\n\n### ◆ 無限制迴圈\n```\nMOV EBX, 5\t;次數\nL1:\n    ;內容\nDEC EBX\nJNE L1\n```\n\n### ◆ 無條件跳躍\n```\nL1:\n    ;內容\nJMP L1\n```\n\n### ◆ 巢狀迴圈\n```\n.data\n    count DWORD 0\n.code\nmov ecx, 5\n;外迴圈\nL1:\n    mov count, ecx \t;儲存上一個外迴值\n    mov ecx, 10 \t;內迴值\n    ;內迴圈\n    L2:\n        ;內容\n    loop L2\n    mov ecx, count \t;放回外迴值\nloop L1\n```\n\n## ● 函式\n由於組合語言並非一半高階語言一樣方便，因此重複的代碼會非常多，所以你可以宣告一些函式來簡化你的程式。\n\n```\nPrime0 PROTO ,\nWa:DWORD, StrA:PTR BYTE\n    mov edx, StrA\n    call WriteString\n\n    mov eax, Wa\n    call WriteDec\nret\nPrime0 ENDP\nEND main\n\nPrime PROC USES ESI EAX ECX EBX \t;不改變主函式暫存器內存的值\n    ;副函式\nret\nPrime ENDP\nEND main\n```","tags":["tutorials","x86"],"categories":["Assembly tutorials"]},{"title":"AOJ ITP1_11_D","url":"/ITP1-11-D-Dice-IV/","content":"# AOJ ITP1_11_D - Dice IV\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_11_D)\n\n#### 題意:\n比對所有骰子是否一樣。\n\n<!-- more -->\n#### 思路:\n全部翻轉比一遍。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/8eb3f6dba3a39e5fa422f2fde74ce343.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_11_C","url":"/ITP1-11-C-Dice-III/","content":"# AOJ ITP1_11_C - Dice III\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_11_C)\n\n#### 題意:\n比對兩顆骰子是不是一樣的。\n\n<!-- more -->\n#### 思路:\n先將上下左右的翻轉寫好，比對每一面是否相同，若相同count++，如果count等於六就代表這兩顆骰子是一樣的。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/0e765d546f82f32465226327ebd1f98f.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_11_B","url":"/ITP1-11-B-Dice-II/","content":"# AOJ ITP1_11_B - Dice II\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_11_B)\n\n#### 題意:\n輸入一顆骰子，然後輸入骰子的兩面上面和正面，問你右邊那面數字是什麼。\n\n<!-- more -->\n#### 思路:\n先將上下左右的翻轉寫好，然後一條字串把所有面翻過一次找到正面和上面，然後就可以知道右邊那面是多少。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/25b5cd60d4468c874ff485d94323684c.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_11_A","url":"/ITP1-11-A-Dice-I/","content":"# AOJ ITP1_11_A - Dice I\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_11_A)\n\n#### 題意:\n輸入一顆骰子翻轉他後輸出他朝上的那面數字是多少(上N，下S，左W，右E)。\n<!-- more -->\n#### 思路:\n先把上下左右的排序方式寫好，然後依照指令翻轉。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/5ad0ba3765b4f3f8112b2b2df0763b31.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_10_D","url":"/ITP1-10-D-Distance-II/","content":"# AOJ ITP1_10_D - Distance II\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_10_D)\n\n#### 題意:\n計算距離。\n\n<!-- more -->\n#### 思路:\n套公式。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/25bffb80e8b6bfdb46267f7ab8b8efc9.js\"></script>","tags":["implementation","math"],"categories":["AOJ"]},{"title":"AOJ ITP1_10_C","url":"/ITP1-10-C-Standard-Deviation/","content":"# AOJ ITP1_10_C - Standard Deviation\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_10_C)\n\n#### 題意:\n計算標準差。\n\n<!-- more -->\n#### 思路:\n套公式。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/0a8f2be2b3d1e52b0d67e1ff1592a251.js\"></script>","tags":["implementation","math"],"categories":["AOJ"]},{"title":"AOJ ITP1_10_B","url":"/ITP1-10-B-Triangle/","content":"# AOJ ITP1_10_B - Triangle\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_10_B)\n\n#### 題意:\n給你三角形的兩邊a,b和角度c計算出以下問題。\nS：三角形的面積\nL：三角形的周長\nh：邊 a為底邊的三角形的高度\n<!-- more -->\n#### 思路:\n套公式。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/6b5b28321418d97d3707e75c7ed3f439.js\"></script>","tags":["implementation","math"],"categories":["AOJ"]},{"title":"AOJ ITP1_10_A","url":"/ITP1-10-A-Distance/","content":"# AOJ ITP1_10_A - Distance I\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_10_A)\n\n#### 題意:\n計算兩點距離。\n<!-- more -->\n#### 思路:\n套入兩點距離公式sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2))。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/25ed355fa6cde261577dc174bb7ac80d.js\"></script>","tags":["implementation","math"],"categories":["AOJ"]},{"title":"AOJ ITP1_9_D","url":"/ITP1-9-D-Transformation/","content":"# AOJ ITP1_9_D - Transformation\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_9_D)\n\n#### 題意:\n有三個指令分別為：\nprint a b: 打印第a~b之間的字串。\nreverse a b: 翻轉a~b之間的字串。\nreplace a b p: 交換a~b之間的字元p。\n<!-- more -->\n#### 思路:\n按照上面規則寫出來。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/2a8a3e2d040349f938b37b9c500f9969.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_9_C","url":"/ITP1-9-C-Card-Game/","content":"# AOJ ITP1_9_C - Card Game\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_9_C)\n\n#### 題意:\n芋頭和花子正在玩紙牌遊戲。他們每個人都有n張牌，並且每輪比賽n次。芋頭和花子在每個回合分別拿出一張牌。每張卡上都寫有由字母字母組成的動物的名字，按字母順序排列的較大動物成為該回合的贏家。獲勝者獲得3分。在平局的情況下，他們每個獲得1分。\n<!-- more -->\n#### 思路:\n比較每個字母得出誰是贏家。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/d326e53b09bbd81c341e7d60ba9a6ca6.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_9_B","url":"/ITP1-9-B-Shuffle/","content":"# AOJ ITP1_9_B - Shuffle\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_9_B)\n\n#### 題意:\n給你一條字串將h長度的字放到後面去，例如字串abcdeefab，長度h為4會變成eefababcd，原本在前面的abcd被搬到後面去。\n<!-- more -->\n#### 思路:\n把後面的字串搬到前面，前面的搬到後面換完後再放回原字串。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/f9f2de49e808132338c6b518a650aa8e.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_9_A","url":"/ITP1-9-A-Finding-a-Word/","content":"# AOJ ITP1_9_A - Finding a Word\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_9_A)\n\n#### 題意:\n輸入w(word)和t(text)檢查w出現在t文章中幾次。\n<!-- more -->\n#### 思路:\n先把輸入的單字轉成全小寫然後比對w。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/ad487bed154dd761af78f71fffe33ca3.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_8_D","url":"/ITP1-8-D-Ring/","content":"# AOJ ITP1_8_D - Ring\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_8_D)\n\n#### 題意:\n輸入一個字串他是環狀的，也就是頭尾相接的一個字串，問你p字串有沒有在環裡面出現，有的話印\"Yes\"，否則\"No\"。\n\n<!-- more -->\n#### 思路:\n下面有兩個方法，方法一是把頭尾相接然後用c++的函式find去尋找有沒有這個字串，第二個方式是逐一比對如直到比對長度一樣。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/711a21ff7c7a3dc889ec1214d2678117.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_8_C","url":"/ITP1-8-C-Counting-Characters/","content":"# AOJ ITP1_8_C - Counting Characters\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_8_C)\n\n#### 題意:\n計算並報告每個字母的數量。忽略字符的大小寫。 \n\n<!-- more -->\n#### 思路:\n使用getline(cin, str)讀取一行包含空白，用isalpha判斷字元是否為英文，用index方式計數ary[str[i] - 'A']++。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/aec8999fda97164d2ba8a1ded029ffda.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"ITP1_8_B Sum of Numbers","url":"/ITP1-8-B-Sum-of-Numbers/","content":"# AOJ ITP1_8_B - Sum of Numbers\n[題目網址](https://chucs.github.io/site/)\n\n#### 題意:\n給你一個1000位以內的數字問你全部數字加起來是多少，例如123加起來是6因為1+2+3=6。\n\n<!-- more -->\n#### 思路:\n由於int只能到9位數所以我們必須要用字串的放式處理。而我們可以利用ASCII的相減算出原本的數字，例如'0'對應48，'1'對應49所以我們都把他們減'0'就可以得到數字的值。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/add998f9189cec2f734a4d0e9d1fa6c0.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_8_A","url":"/ITP1-8-A-Toggling-Cases/","content":"# AOJ ITP1_8_A - Toggling Cases\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_8_A)\n\n#### 題意:\n把字串的內英文字母小轉大，大轉小。\n<!-- more -->\n#### 思路:\n用getline(cin ,str)讀取整行包含空白，isalpha判斷是否為英文如果不為就輸出那個字元，如果是的話判斷他是小寫還是大寫並轉換。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/efba99d8da45aad2f6d8fbc67cf22213.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_7_D","url":"/ITP1-7-D-Matrix-Multiplication/","content":"# AOJ ITP1_7_D - Matrix Multiplication\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_7_D)\n\n#### 題意:\n將a和b兩個矩陣相乘得到c矩陣。\n\n<!-- more -->\n#### 思路:\n依照公式a[i][k]*b[k][j]算出c矩陣。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b44f989b78ba32d9c88e47735840152c.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_7_C","url":"/ITP1-7-C-Spreadsheet/","content":"# AOJ ITP1_7_C - Spreadsheet\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_7_C)\n\n#### 題意:\n輸數一個矩陣將每一列的加起來的數字算出來放在最後，再將每一行的答案加起來放在最後接著輸出。\n<!-- more -->\n#### 思路:\n在輸入每一列時將答案計算並放在a[i+1]內，最後跑一次行的然後輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/ea47218d893d0d5e531a9dbc5b274126.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_7_B","url":"/ITP1-7-B-How-many-ways/","content":"# AOJ ITP1_7_B - How many ways\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_7_B)\n\n#### 題意:\n有1~n個數字問你隨便取三個不重複的數字加起來是x有多少個。\n\n<!-- more -->\n#### 思路:\n用三個迴圈跑分別代表三個數字然後判斷加起來是不是x。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/16aa4787ee20a71d3330cd05fb06f0ed.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_7_A","url":"/ITP1-7-A-Grading/","content":"# AOJ ITP1_7_A - Grading\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_7_A)\n\n#### 題意:\n輸入三個數字分別為期中考期末考與補考-1代表缺考。\n按照規則幫學生打分數：\n● 如果學生不參加期中考試或期末考試，則其成績應為F。\n● 如果期中和期末考試的總分大於或等於80，則學生的成績應為A。\n● 如果期中考試和期末考試的總分大於或等於65且小於80，則學生的成績應為B。\n● 如果期中考試和期末考試的總分大於或等於50且小於65，則學生的成績應為C。\n● 如果期中和期末考試的總分大於或等於30且小於50，則該學生的成績為D。但是，如\n● 果補考的分數大於或等於50，則該成績為C。\n● 如果期中和期末考試的總分小於30，則學生的成績應為F。\n<!-- more -->\n#### 思路:\n按照規則寫。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/9cc4ed69e10fe8eedc5fcd80245a19ac.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_6_D","url":"/ITP1-6-D-Matrix-Vector-Multiplication/","content":"# AOJ ITP1_6_D - Matrix Vector Multiplication\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_6_D)\n\n#### 題意:\n輸入一個矩陣和一個陣列將a[i][j]*b[j]累加並逐步印出。\n<!-- more -->\n#### 思路:\n用迴圈控制i和j按照公式打用兩。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/7f6d2aaa97f66548a2bf4193f2c87667.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_6_C","url":"/ITP1-6-C-Official-House/","content":"# AOJ ITP1_6_C - Official House\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_6_C)\n\n#### 題意:\n你有四棟房子，每棟有三層，輸入4個數字分別為，第幾棟房子b，第幾列f，第幾行r，幾個人v。\n<!-- more -->\n#### 思路:\n首先判斷是哪棟房子接著以index的方式做插入，輸入完後將剛剛存的數字印出來。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/fc4c5dd64909457dec8959733a576e1d.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_6_B","url":"/ITP1-6-B-Finding-Missing-Cards/","content":"# AOJ ITP1_6_B - Finding Missing Cards\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_6_B)\n\n#### 題意:\n輸入這副牌有的花色和數字，請找出遺失的牌(沒輸入的牌)。\n<!-- more -->\n#### 思路:\n用index的方式計算每一個花色的牌，最後判斷哪張牌是0代表沒有出現過。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/7d87751075a82cac1f7cc18dda00648f.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_6_A","url":"/ITP1-6-A-Reversing-Numbers/","content":"# AOJ ITP1_6_A - Reversing Numbers\n[題目網址](https://chucs.github.io/site/)\n\n#### 題意:\n編寫一個程序，該程序讀取序列並以相反的順序打印。\n<!-- more -->\n#### 思路:\n把迴圈的起始值設為n-1(index從零開始數入所以會是n-1)然後每次減一直到零。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/66c8c9199158c92e1fddfb4be8e6e965.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_5_D","url":"/ITP1-5-D-Structured-Programming/","content":"# AOJ ITP1_5_D - Structured Programming\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_5_D)\n\n#### 題意:\n轉換虛擬碼執行他的結果。\n”goto tag;“ 代表執行到這行時他會跳到對印的標籤上。\n<!-- more -->\n#### 思路:\n按照虛擬碼轉成Ｃ＋＋。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/43f9f57a336efddd2e5833d249178158.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_5_C","url":"/ITP1-5-C-Print-a-Chessboard/","content":"# AOJ ITP1_5_C - Print a Chessboard\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_5_C)\n\n#### 題意:\n輸入棋盤的寬和高，列印對應大小的棋盤。\n<!-- more -->\n#### 思路:\n利用Bool來切換狀態先印\"#\"在印\".\"。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b0ddf32dc696fcbbf44bff358de79bdf.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_5_B","url":"/ITP1-5-B-Print-a-Frame/","content":"# AOJ ITP1_5_B - Print a Frame\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_5_B)\n\n#### 題意:\n輸入長和寬列印對應大小的農田。\n\n<!-- more -->\n#### 思路:\n由於要考慮到農田得牆壁我們要先把長和寬都減2才可以知道農田的大小。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/95fb05c0080730d7b5bbb90aa7a4409a.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_5_A","url":"/ITP1-5-A-Print-a-Rectangle/","content":"# AOJ ITP1_5_A - Print a Rectangle\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_5_A)\n\n#### 題意:\n輸入兩個整數長和寬，印出對應大小的矩行。\n\n<!-- more -->\n#### 思路:\n用兩個迴圈一個控制長一個控制寬就可以印出來了。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/50e5bff18db1c5658f1c83e399ca6eb8.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_4_D","url":"/ITP1-4-D-Min-Max-and-Sum/","content":"# AOJ ITP1_4_D - Min, Max and Sum\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/4/ITP1_4_D)\n\n#### 題意:\n找出最大與最小的數字，並算出全部數字的總和。\n<!-- more -->\n#### 思路:\n練習利用陣列把全部的數字存起來，並設一個最大值與最小值判斷數字即可得到最大值與最小值。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/4bba8f3100310e5ffd9f547656ee5046.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_4_C","url":"/ITP1-4-C-Simple-Calculator/","content":"# AOJ ITP1_4_C - Simple Calculator\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/4/ITP1_4_C)\n\n#### 題意:\n算出對印的運算結果。\n\n<!-- more -->\n#### 思路:\n你可以用if判斷每個op是什麼在做運算，又或者你可以用switch去選擇。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/e0068e280fdf1be4df234e1eca65af92.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_4_B","url":"/ITP1-4-B-Circle/","content":"# AOJ ITP1_4_B - Circle\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/4/ITP1_4_B)\n\n#### 題意:\n列印圓周與面積。\n\n<!-- more -->\n#### 思路:\n面積公式：pi * r * r\n周長公式：2 * pi * r\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/13ff7800ede2eb9caefe4cb3ef529e74.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_4_A","url":"/ITP1-4-A-AB-Problem/","content":"# AOJ ITP1_4_A - A/B Problem\n[題目網址](https://chucs.github.io/site/)\n\n#### 題意:\n請印出a/b的整數，a%b的餘數，a/b的小數。\n<!-- more -->\n#### 思路:\n宣告時用double打印時轉成對應型態。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/47638746bfe75731f97d849a2a2801bd.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_3_D","url":"/ITP1-3-D-How-Many-Divisors/","content":"# AOJ ITP1_3_D - How Many Divisors\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/3/ITP1_3_D)\n\n#### 題意:\na~b\b這些數字除c\b有多少數字可以被整除。\n\n<!-- more -->\n#### 思路:\n一個迴圈從a~b每個都除一遍看餘數是否為零。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b3a7cbf69a38a86984db152a41ba1636.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_3_C","url":"/ITP1-3-C-Swapping-Two-Numbers/","content":"# AOJ ITP1_3_C - Swapping Two Numbers\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/3/ITP1_3_C)\n\n#### 題意:\n交換兩數字使它由小到大排序。\n\n<!-- more -->\n#### 思路:\n比較大小並交換。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/27f64d4bd1067da250e433edb8d75362.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_3_B","url":"/ITP1-3-B-Print-Test-Cases/","content":"# AOJ ITP1_3_B - Print Test Cases\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/3/ITP1_3_B)\n\n#### 題意:\n編寫一個讀取整數x並按原樣打印時前面加上第幾個\"Case n:\"。\n\n<!-- more -->\n#### 思路:\n輸入然後列印時前面加上Case。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/fda623b6851aa97546fc78e8bc218b4b.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_3_A","url":"/ITP1-3-A-Print-Many-Hello-World/","content":"# AOJ ITP1_3_A - Print Many Hello World\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/3/ITP1_3_A)\n\n#### 題意:\n打印1000個\"Hello World\"。\n\n<!-- more -->\n#### 思路:\n迴圈跑1000次列印。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/5e3804fa7a5fa32a4a1fc45d1696a7b3.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_2_D","url":"/ITP1-2-D-Circle-in-a-Rectangle/","content":"# AOJ ITP1_2_D - Circle in a Rectangle\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/2/ITP1_2_D)\n\n#### 題意:\n判斷圓是不是在長方形內。\n\n<!-- more -->\n#### 思路:\n圓心加半徑就可以判斷有沒有小於寬高，剪半徑大於零。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/2a5baeb6203b0eb6f3a2b4f34bf21522.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_2_C","url":"/ITP1-2-C-Sorting-Three-Numbers/","content":"# AOJ ITP1_2_C - Sorting Three Numbers\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/2/ITP1_2_C)\n\n#### 題意:\n由小到大排序三個數字。\n\n<!-- more -->\n#### 思路:\n用C++排序函式排序。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/148a90782eddee6a56b228152dc61cb8.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_2_B","url":"/ITP1-2-B-Range/","content":"# AOJ ITP1_2_B - Range\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_2_B)\n\n#### 題意:\n如果a&lt;b&lt;c就輸出\"Yes\"，否則\"No\"。\n\n<!-- more -->\n#### 思路:\n比較abc大小。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/9233d0bcd81cbdef6f2397c9177152e5.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_2_A","url":"/ITP1-2-A-Small-Large-or-Equal/","content":"# AOJ ITP1_2_A - Small Large or Equal\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/all/ITP1_2_A)\n\n#### 題意:\n輸入Ａ和Ｂ找出他們的大小關係，然後輸出Ａ大於小於等於Ｂ這樣。\n<!-- more -->\n#### 思路:\n判斷ＡＢ數字後列印他們的關係。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/7fad97ad2b69a80fd1d4299718c12a56.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_1_D","url":"/ITP1-1-D-Watch/","content":"# AOJ ITP1_1_D - Watch\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/1/ITP1_1_D)\n\n\n#### 題意:\n給你秒數請換算成時\b,分,秒。\n<!-- more -->\n#### 思路:\n最直覺的方式就是把小時算出來後，把秒扣掉小時除與60就知道分鐘以此類推...，而你也可以用取餘數的方式來完成。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/8053e142666cac547834ac8c1e0eaeb0.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_1_C","url":"/ITP1-1-C-Rectangle/","content":"# AOJ ITP1_1_C - Rectangle\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/1/ITP1_1_C)\n\n#### 題意:\n輸入長寬Ａ和Ｂ算出此長方形的面積和周長。\n<!-- more -->\n#### 思路:\n面積就把Ａ和Ｂ相乘，周長就Ａ＊2 + B * 2。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/27874857e79e6ac43ed5d4ddd8f14adf.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_1_B","url":"/ITP1-1-B-X-Cubic/","content":"# AOJ ITP1_1_B - X Cubic\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/1/ITP1_1_B)\n\n#### 題意:\n輸入一個數字然後算出3次平方是多少。\n<!-- more -->\n#### 思路:\n把輸入的數字相乘。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/70bee1914dadca1a852e384653a4a473.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ITP1_1_A","url":"/ITP1-1-A-Hello-World/","content":"# AOJ ITP1_1_A - Hello World\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/2/ITP1/1/ITP1_1_A)\n\n#### 題意:\n打印一個Hello World。\n<!-- more -->\n#### 思路:\n列印Hello World然後換行。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/149966b2530121148b6ab12c9c4563f1.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"K Dimensional Tree Tutorials","url":"/C-KDimensional-tree-tutorials/","content":"# K-Dimensional Tree tutorials\n\n## 介紹\nK元樹是一種樹的資料結構，其中每個節點可以有很多的子節點。\n<!-- more -->\n## 完整代碼:\n<script src=\"https://gist.github.com/Daviswww/bde0499460a088ad106e51154c6630f2.js\"></script>\n\n### 結構\n所以我們必須先建造一個結構包含父節點與一個動態陣列以便於我們利用。\n\n```\nstruct Node{\n    int key;\n    vector<Node *> child;\n};\n```\n### 創建一個新節點\n生成一個新的節點並設定它的父節點為key，而每一個key下面都有一個動態陣列。\n```\nNode* createNode(int key){\n    Node* node = new Node();\n    node->key = key;\n    return node;\n}\n```\n### 搜索節點(BFS)\n將節點放入queue後檢查陣列是否為空，如果不為空就將他放繼續放入queue中直到找到索引為止。\n\n舉例：\n```\n      1\n   / / \\ \\\n  7  2   3 6\n / \\        \\ \\\n4   5        8 9\n```\nq: vector(root)\n檢查vector(root)[0]下面陣列是否為NULL，放入\nq: vector(1)\n檢查vector(1)[0]下面的陣列是否為空，放入\nq: vector(7)\n檢查vector(1)[1]下面的陣列是否為空，不放入\nq: vector(7)\n檢查vector(1)[2]下面的陣列是否為空，不放入\nq: vector(7)\n檢查vector(1)[3]下面的陣列是否為空，放入\nq: vector(7), vector(6)\n檢查vector(7)[0]下面的陣列是否為空，不放入\nq: vector(6)\n.\n.\n.\n檢查vector(6)[1]下面的陣列是否為空，不放入\nq:\n\n```\nNode* search(Node *root, int key){\n    queue<Node*> q;\n    q.push(root);\n    if(root->key == key){\n        return root;\n    }else{\n        while(!q.empty()){\n            Node *temp = q.front();\n            q.pop();\n            for(int i = 0; i < temp->child.size(); i++){\n                if(temp->child[i]->key == key){\n                    return temp->child[i];\n                }\n                if(!temp->child[i]->child.empty()){\n                    q.push(temp->child[i]);\n                }\n            }\n        }\n    }\n    return NULL;\n}\n```\n\n### 插入\n先創建一個新的節點，在利用剛剛寫好的查詢功能搜尋父節點，接著放入動態陣列內的最後面，與queue的push一樣。\n```\nvoid insert(Node *root, int parent, int key){\n    Node *nodeToInsert = createNode(key);\n    Node *node = search(root, parent);\n    if(node != NULL){\n        (node->child).push_back(nodeToInsert);\n    }else{\n        cout << \"No\" << endl;\n        return;\n    }\n}\n```","tags":["tutorials","cpp"],"categories":["C++ tutorials"]},{"title":"Codeforces 1143C","url":"/Queen/","content":"# Codeforces 1143C - Queen\n[題目網址](https://codeforces.com/problemset/problem/1143/C)\n\n\n#### 題意:\n給你一棵有根樹，有1~n個頂點，沒有循環圖出現，有一個特殊的點叫做根，根的父級p<sub>i</sub>為-1。\n有些點會尊敬長輩，有些不會，c<sub>i</sub> = 1表示不尊敬任何長輩，c<sub>i</sub> = 0表示尊敬所有長輩。\n你必須一步步刪除一個非根的點，這的點被刪除的條件為不尊敬父母跟不被所有這個點的小孩尊敬，若一次動作中有多個點可以刪除，從「編號最小」的開始刪除，當這個點被刪除後，他的所有小孩會連接到他的父母。\n當沒有點可以刪除後，照順序印出你刪除的點。\n<!-- more -->\n#### 思路:\n思考如果本身是尊敬長輩的，那自己跟父母就不會被刪除，被刪除的點改變連接狀態，但不會影響結果，所以會被刪掉的點找出來後從編號小的點開始輸出。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/4f39d918e9e2586f63f31405ee11f1a1.js\"></script>","tags":["dfs and similar","trees","1400"],"categories":["Codeforces"]},{"title":"Codeforces 913B","url":"/Christmas-Spruce/","content":"# Codeforces 913B - Christmas Spruce\n[題目網址](https://codeforces.com/problemset/problem/913/B)\n\n\n#### 題意:\n有個有根樹，若點u有個連接到點v，那我們稱點u為小孩，點v為父母，另外若一個點有父母但沒有小孩，我們稱之為「葉子」。\n我們稱一種有根樹叫spruce，這種樹的所有非葉子的點都具有至少三個葉子，給你一個有根樹，從第二個點開始輸入它連接的父母，請問這是spruce嗎?\n<!-- more -->\n(點1一定是樹根)\n#### 思路:\n先計算每個點被多少點(孩子)連接，再看每個點是不是葉子，將不是葉子的點的父母連接數-1，被連接數 = 0的就是葉子，但如果因為-1的關係變成0必須判斷為否，可以提早判斷變成判斷是否小於3，最後確認每個非葉子的點是不是至少有三個葉子。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/bb663ba790cb88e745dc1c8c1a0647ff.js\"></script>","tags":["implementation","trees","1200"],"categories":["Codeforces"]},{"title":"Codeforces 59A","url":"/Word/","content":"# Codeforces 59A - Word\n[題目網址](https://codeforces.com/problemset/problem/59/A)\n\n\n#### 題意:\nVasya很難過，網絡上的許多人都將一個大寫字母和小寫字母混在一起。因此Vasya想要寫個程式把單字的大寫小血都轉成統一的，但要讓程式轉換字母的次數最少。\n<!-- more -->\n#### 思路:\n計算大寫小寫個多少，哪邊多就轉換成哪邊。\n(根據ASCII，'a' = 97 , 'A' = 65，可對字元進行數字加減做大小寫轉換)\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/40bedb712d029bb7f89949065a394418.js\"></script>","tags":["implementation","strings","800"],"categories":["Codeforces"]},{"title":"Codeforces 41A","url":"/Translation/","content":"# Codeforces 41A - Translation\n[題目網址](https://codeforces.com/problemset/problem/41/A)\n\n\n#### 題意:\n將一種語言的單字s翻譯成另一種語言的單字t，這兩種語言非常相似，單字剛好是反轉的，請問單字t是單字s翻譯過來的嗎?\n<!-- more -->\n#### 思路:\n一個從頭，一個從尾開始比對字母是否相同。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/a8813bc663dbb7ee52a7775522975c0a.js\"></script>","tags":["implementation","strings","800"],"categories":["Codeforces"]},{"title":"Codeforces 110A","url":"/Nearly-Lucky-Number/","content":"# Codeforces 110A - Nearly Lucky Number\n[題目網址](https://codeforces.com/problemset/problem/110/A)\n\n\n#### 題意:\nPetya喜歡幸運數字(數字裡只有4或7)，而Petya想要找出「接近幸運的數字」(數字裡的幸運數字的數量是幸運數字)，請幫Petya判斷是不是「接近幸運的數字」。\n<!-- more -->\n#### 思路:\n用字串輸入，計算4跟7的數量，判斷數量是否為幸運數字，因為最常是18位數，所以18內的幸運數字只有4跟7。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/a2c82cd42402980c86793a0ea09d37d1.js\"></script>","tags":["implementation","800"],"categories":["Codeforces"]},{"title":"Codeforces 266B","url":"/Queue-at-the-School/","content":"# Codeforces 266B - Queue at the School\n[題目網址](https://codeforces.com/problemset/problem/266/B)\n\n#### 題意:\n學校裡有男女生在排隊，過一段時間，男生覺得排在女生前面會覺得尷尬，所以決定讓位給女生，每隔一段時間所有排在女生前面的男生就會讓位給後面的女生，請問過了t段時間，隊伍會變成什麼樣子?\n<!-- more -->\n#### 思路:\n直接模擬排隊情況，每次時間都改變一次字串。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/1746167ba5e59709cd8f3b265f51b49d.js\"></script>","tags":["implementation","constructive algorithms","800","graph matchings","shortest paths"],"categories":["Codeforces"]},{"title":"Build the Binary Tree Tutorials","url":"/C-BTree-tutorials/","content":"# Binary Tree tutorials\n\n## 介紹\n二元樹是一種樹的資料結構，其中每個節點最多具有兩個子節點，分別稱為左節點和右節點。\n<!-- more -->\n## 完整代碼:\n<script src=\"https://gist.github.com/Daviswww/057b8a423219e1bbdcd14b2d1f25cf0d.js\"></script>\n\n### 結構\n所以我們必須先建造一個結構包含父節點與左右兩個子結點。\n\n```\nstruct Node{\n    int key;\n    Node *left;\n    Node *right;\n};\n```\n### 創建一個新節點\n生成一個新的節點並設定它的父節點為key。\n```\nNode* createNode(int key){\n    Node* node = new Node();\n    node->key = key;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n```\n### 搜索節點(BFS)\n將節點放入queue後檢查左節點與右節點使否為空，如果不為空就將他放繼續放入queue中直到找到索引為止。\n\n舉例：\n```\n    1\n   / \\\n  2   3\n / \\\n4   5\n```\nq: 1\n檢查1左節點是否為NULL，放入\nq: 2\n檢查1右節點是否為NULL，放入\nq: 2 3\n檢查2左節點是否為NULL，放入\nq: 3 4\n檢查2右節點是否為NULL，放入\nq: 3 4 5\n檢查3左節點是否為NULL，不放入\nq: 4 5\n檢查3右節點是否為NULL，不放入\nq: 4 5\n.\n.\n.\n檢查5右節點是否為NULL，不放入\nq: 5\n```\nNode* search(Node* root, int key){\n    queue<Node*> q;\n    q.push(root);\n\n    while(!q.empty()){\n        Node *temp = q.front();\n        q.pop();\n        if(temp->key == key) return temp;\n        if(temp->left != NULL) q.push(temp->left);\n        if(temp->right != NULL) q.push(temp->right);\n    }\n    return NULL;\n}\n```\n\n### 插入\n先創建一個新的節點，在利用剛剛寫好的查詢功能搜尋父節點，接著插入空的子節點位置完成新增。\n```\nvoid insert(Node *root, int parent, int key){\n    Node *nodeToInsert = createNode(key); \n    Node *node = search(root, parent);\n    if(node->left == NULL) {\n        node->left = nodeToInsert;\n        return;\n    }\n    if(node->right == NULL) {\n        node->right = nodeToInsert;\n        return;\n    }\n}\n```","tags":["tutorials","cpp"],"categories":["C++ tutorials"]},{"title":"Codeforces 540C","url":"/Ice-Cave/","content":"# Codeforces 540C - Ice Cave\n[題目網址](https://codeforces.com/problemset/problem/540/C)\n\n\n#### 題意:\n你玩一款電腦遊戲，你的角色在一個冰窟裡為了進下一關必須從指定的位置掉落洞穴。\n這一關，冰窟大小為nxm，每個位置的冰塊可以是完整的或裂開的，因為遊戲機制你的角色只能一次移動一格而且不能從原地移動到原地，當移動到裂冰時，角色就會掉下去，當移動到完整冰時，冰會裂開，請問能從指定的起點到指定的終點嗎?\n<!-- more -->\n起點一定會再裂冰的位置。\n'.': 完整的冰 , 'X':裂開的冰\n#### 思路:\n利用BFS將可走的路記錄起來，紀錄的位置用'*'標記，看能不能到目的地，目的地的冰可能是完整或裂開的，因為要在目的地掉落，因此如果目的地是完整的冰就要走兩次，那判斷就會是「裂開的冰」或「走過一次的冰」。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/56f174868a744aa1e3791f83dd573ebf.js\"></script>","tags":["dfs and similar","2000"],"categories":["Codeforces"]},{"title":"Codeforces 377A","url":"/Maze/","content":"# Codeforces 377A - Maze\n[題目網址](https://codeforces.com/problemset/problem/377/A)\n\n\n#### 題意:\nPavel喜歡格子迷宮，迷宮由nxm的矩形組成，每個點可以是空曠的也可以是圍牆，空曠地點可以移動到另一個空曠的點，Pavel畫了一張格子迷宮，但Pavel希望多k個牆，想將空曠的點變成牆後還能使所有空曠的點相通，請幫Pavel決定哪些空地要變成牆並把結果印出。\n<!-- more -->\n'#':牆 , '.':空地 , 'X':由空地變成牆\n#### 思路:\n利用DFS尋找路，當遇到死路就把空地變牆，因為是死路所以不會讓空地出現不相通的情況。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/56030cba02a4f75b6f6210825042fb99.js\"></script>","tags":["dfs and similar","1600"],"categories":["Codeforces"]},{"title":"Codeforces 225A","url":"/Dice-Tower/","content":"# Codeforces 225A - Dice Tower\n[題目網址](https://codeforces.com/problemset/problem/225/A)\n\n\n#### 題意:\n骰子由1~6的數字組成，兩個相面對面的數字加起來都是7，共有兩種旋轉方向的骰子，依題目所有骰子皆使用同一種骰子。\nAlice和Bob在玩骰子，Alice利用n個骰子疊成骰子塔，骰子與骰子的連接面不能是相同的數字，Bob只能在不移動的情況下看骰子，Bob只會看見骰子塔每個骰子的兩面及頂端的數字，請問Bob能猜出他看不見的所有數字嗎?\n<!-- more -->\n#### 思路:\n可以發現，從頂端數第二個骰子，如果用跟頂端骰子上下不同的數字，那第二個骰子上下用哪一面都可以，因此要猜出看不見的所有數字就必須每一個骰子上下面都是同一組數字。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/698162f0cf528b62b7a6b1787a79596a.js\"></script>","tags":["greedy","constructive algorithms","1100"],"categories":["Codeforces"]},{"title":"Codeforces 365A","url":"/Good-Number/","content":"# Codeforces 365A - Good Number\n[題目網址](https://codeforces.com/problemset/problem/365/A)\n\n\n#### 題意:\n一個數字如果0~k都有出現，我們稱「k-good」，你有一個陣列a包含n個數字，請問有多少數字是「k-good」?\n<!-- more -->\n#### 思路:\n利用字串格式輸入數字，就能對每個位數的數字做判斷。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/8d1c768a0b9784c3e7f40e2bd68d6261.js\"></script>","tags":["implementation","1100"],"categories":["Codeforces"]},{"title":"Codeforces 129B","url":"/Students-and-Shoelaces/","content":"# Codeforces 129B - Students and Shoelaces\n[題目網址](https://codeforces.com/problemset/problem/129/B)\n\n\n#### 題意:\nAnna和Maria想要訓斥表現不好的n位學生，因此買了m條鞋帶，每個鞋帶將兩位學生綁在一起，然後會訓斥剛好只有被綁一個鞋帶的所有學生，將這些學生分為一組並且這些學生會將鞋帶帶走，重複找相同狀況的學生直到不符條件。請問學生共被分為幾組訓斥?\n<!-- more -->\n#### 思路:\n用一個二位陣列存鞋帶綁了哪些學生，鞋帶是雙向的所以如果綁了i跟j，那陣列中[i][j]與[j][i]都要記為1，並記錄每一位學生被綁了幾條鞋帶，之後找只有被綁一條的學生，將學生與跟他綁在一起的學生的被綁數-1，並把關係移除，完成一輪就是一組，重複到沒有學生是指綁一條鞋帶為止。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/bef4680413ec760112edf8aba7fe9b1b.js\"></script>","tags":["implementation","dfs and similar","brute force","graphs","1200"],"categories":["Codeforces"]},{"title":"Codeforces 902B","url":"/Coloring-a-Tree/","content":"# Codeforces 902B - Coloring a Tree\n[題目網址](https://codeforces.com/problemset/problem/902/B)\n\n#### 題意:\n你有一個有n個點的有根樹，根的編號為1，要為每個點上色，每個點的顏色為c1,c2,...cn，一開始每個點都沒顏色c = 0，你必須用「最少」的步驟來完成上色，每一步你能選擇任點v與任一顏色x，然後被選擇的點v與v的子樹顏色都會變成x，可以確定最後每個點都有顏色c != 0。\n輸入n-1個數字p2,p3,...,pn代表第i個點與pi相連。\n<!-- more -->\n#### 思路:\n一棵樹上方會影響下方，所以就從第一個點看到最後，紀錄每個點當下是什麼顏色，對每一個點看這個點的上一個點是什麼顏色，如果是目標顏色就不用加一次步驟，並把當下顏色改成目標顏色。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/bfc82b72c03fee5a5657c8b26dbd1d96.js\"></script>","tags":["dfs and similar","greedy","1200","dsu"],"categories":["Codeforces"]},{"title":"Codeforces 218C","url":"/Ice-Skating-1/","content":"# Codeforces 218C - Ice Skating\n[題目網址](https://codeforces.com/problemset/problem/218/C)\n\n\n#### 題意:\nBajtek在學習溜冰，溜冰場裡有n個雪堆在不同的位置，Bajtek只會往東西南北四個方向移動，並且停不下來因此必須要依靠雪堆停下來，為了確保Bajtek能停下來，也就是說，每個雪堆的四個方向至少要有另一個雪堆，他想要多堆幾個雪堆，請幫忙找出Bajtek「最少」還需要堆多少雪堆?\n<!-- more -->\n#### 思路:\n用平面來看，一個雪堆往四個方向延伸尋找有沒有其他雪堆，如此可以將數個雪堆連在一起形成符合條件的集合，而平面中可以形成多個集合，代表每個集合中的任一雪堆不會與另一個集合中的任何雪堆有交集，讓任兩個集合有交集就需要多一個雪堆放在能讓兩集合相通的位置，所以答案是(集合數量-1)。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/e6dc78157461da5abb256bf66544c028.js\"></script>","tags":["dfs and similar","graphs","1200","dsu"],"categories":["Codeforces"]},{"title":"Codeforces 727A","url":"/Transformation-from-A-to-B/","content":"# Codeforces 727A - Transformation: from A to B\n[題目網址](https://codeforces.com/problemset/problem/727/A)\n\n\n#### 題意:\n輸入起始數字a與目標數字b(a ≤ b)，你能進行兩種操作:\n1.將現在的數字 x 2      (x = 2x)\n2.將現在的數字 x 10 + 1 (x = 10x + 1)\n請問，a能不能通過以上操作變成b，如果可以要把過程數字變化印出。\n<!-- more -->\n#### 思路:\na每次都有兩種變化可以選，但b每次只有一種變化，因此將兩種操作反向操作，看b能不能變成a。\n因為必為整數，所以:\n1.除2前必須是偶數\n2.減1後除十前數字的個位數必須是1\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/b711a2d526c39455320d783d844d0f56.js\"></script>","tags":["dfs and similar","math","brute force","1000"],"categories":["Codeforces"]},{"title":"Codeforces 1020B","url":"/Badge/","content":"# Codeforces 1020B - Badge\n[題目網址](https://codeforces.com/problemset/problem/1020/b)\n\n#### 題意:\n老師要在調皮的學生的徽章上打洞，有n位調皮的學生，每位學生都會回答另一位同學才是，過程持續了一段時間，老師最後遇到已經有被打洞的學生，老師最後在徽章上打了第二次洞，並結束這個過程。\n你不知道第一位被打洞得學生是誰，但你知道每一位學生指誰是下一位，你的任務是，當每一位學生是第一位時，找出最後會是誰被打兩次洞。\n<!-- more -->\n#### 思路:\n用一個陣列存學生被選中的次數，第一個出現第二次就是答案。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/a5a9bbcaa6db979e131db5bbeefc11b5.js\"></script>","tags":["dfs and similar","brute force","graphs","1000"],"categories":["Codeforces"]},{"title":"Codeforces 1033A","url":"/King-Escape/","content":"# Codeforces 1033A - King Escape\n[題目網址](https://codeforces.com/problemset/problem/1033/a)\n\n#### 題意:\n有一個nxn的西洋棋盤，棋盤上只有一個皇后與一個國王各在棋盤上的一個位置，國王不會在皇后的移動範圍內，現在希望國王有個目的地，國王能不斷的移而皇后只能移動一次，請問國王能不能到達目的地?\n(國王與皇后的移動範圍與西洋棋相同)\n<!-- more -->\n#### 思路:\n皇后的移動範圍會將棋盤切成四塊區域，只要看國王與目的地是不是在相同區塊跟注意皇后周圍的位置(棋盤最小3x3)就知道可不可以了。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/f869f29d6765dc6fed1899262adc2dfc.js\"></script>","tags":["implementation","dfs and similar","graphs","1000"],"categories":["Codeforces"]},{"title":"Codeforces 948A","url":"/Protect-Sheep/","content":"# Codeforces 948A - Protect Sheep\n[題目網址](https://codeforces.com/problemset/problem/948/A)\n\n#### 題意:\nBob是位農民，他有RxC的牧場，每個空間可以有一隻羊、一隻狗或一隻狼，Bob想要保護所有的羊，所以要放狗進牧場中，羊與狗都不會動，而狼可以上下左右移動，狗可以擋住狼不經過那個位置，Bob有很多狗所以不用在意狗的數量，請問Bob有辦法保護所有羊不被狼吃掉嗎，如果可以，請印出最後牧場的動物分布。\n<!-- more -->\n#### 思路:\n將空地全部填滿狗，記錄所有狼的位置，之後看狼的四個方向有沒有羊就知道可不可以了。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/60375b3b23a494af098727cdf5497dcc.js\"></script>","tags":["implementation","dfs and similar","brute force","graphs","900"],"categories":["Codeforces"]},{"title":"Codeforces 115A","url":"/Party/","content":"# Codeforces 115A - Party\n[題目網址](https://codeforces.com/problemset/problem/115/A)\n\n\n#### 題意:\n一家公司裡有n位員工，每位員工不是沒有直屬經理就是只有一位直屬經理，如果滿足以下至少一項條件，則員工A被認為是另一員工B的「上級」：\n1.員工A是員工B的直屬經理\n2.若員工A是員工C的上級，則員工C也是員工B的直屬經理。\n不會有一名員工是直屬經理的上級。\n<!-- more -->\n這家公司想要辦派對，想要將n位員工分成幾組，每位員工都有組別，但每一組的成員中不會有員工A是員工B的上級，請問「最少」能分成幾組?\n員工1~n，為每位員工輸入他的直屬經理號碼，若員工沒有直屬經理則輸入-1。\n#### 思路:\n對每位員工找出上級-下屬關係最多層的數量就是答案。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/59f4f5856921759acb4957c8700501f1.js\"></script>","tags":["dfs and similar","graphs","trees","900"],"categories":["Codeforces"]},{"title":"Codeforces 60B","url":"/Serial-Time/","content":"# Codeforces 60B - Serial Time!\n[題目網址](https://codeforces.com/problemset/problem/60/B)\n\n\n#### 題意:\nSerial Guy有個立體空間，有k層，每層是nxm的矩形，'.'代表空的，'#'代表障礙物，Serial Guy想要裝水到這個空間裡，有個水龍頭在第一層的(x,y)位置，水能通過空的空間但不能通過障礙物，每個空間裝滿要一分鐘，請問在水龍頭的水能通過的空間裡，要裝滿水需要幾分鐘?\n<!-- more -->\n#### 思路:\n像找路一樣，在一個點上有兩種方法尋找路線:\nDFS: 遇到能走的方向就直接走，但要記住之前走過的地方，遇到死路就原路返回，遇到新路就直接走，重複到所有地方都被走過。\nBFS: 在一個位置上把所有能走的路記起來，從被記起來的新路挑一個走，到下一個地方一樣把所有能走的路記起來，重複直到所有地方被走過。\n(程式碼採BFS方法)\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/60a36daf6059cc6fb76d130a63166a02.js\"></script>","tags":["dfs and similar","dsu","1400"],"categories":["Codeforces"]},{"title":"Codeforces 1113A (dp)","url":"/Sasha-and-His-Trip-v2/","content":"# Codeforces 1113A - Sasha and His Trip (dp)\n[題目網址](https://codeforces.com/problemset/problem/1113/A)\n\n#### 題意:\nSasha喜歡到處旅行，在Sasha的國家裡有n座城市，這n座城市是連成一直線的且每座城市間距離相同，每去一座城市需要1公升的汽油，Sasha想要去這n座城市，Sasha有一台能裝v公升汽油的車，但這台車現在沒有汽油，每座城市都有加油站，第i座城市每一公升需要i的價錢，Sasha希望能花最少的錢完成這趟旅行，請問Sasha「最少」需要花多少錢來完成這趟旅行?\n<!-- more -->\n#### 思路:\n由於不能有加超過油箱v，所以要花最少錢加油的話越早加油越好，所以我們可以先建一個油表來表示到那裡要花多少錢，如果n-m>=1代表油不夠，我們就看差多少距離查油表。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/32811888fa30e8313d3acf0936359d83.js\"></script>","tags":["dp","greedy","math"],"categories":["Codeforces"]},{"title":"ALDS1_1_D - Maximum Profit","url":"/ALDS1-1-D-Maximum-Profit/","content":"# 最大利潤\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/1/ALDS1_1_D)\n\n#### 題意:\n他希望利用換匯率獲得最大的利潤，例如: 1塊買5塊賣可以賺4塊，輸出4塊，而輸入的順序是代表時間軸。\n<!-- more -->\n#### 思路:\n先將第一個數作為最小值，然後與下一個相減看有沒有大於現在的利潤，接著把現在的數字與最小值比較，以確保最小數為值前的。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b456634867aba083d9230d0180c34acc.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_1_C","url":"/ALDS1-1-C-Prime-Numbers/","content":"# 質數\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/1/ALDS1_1_C)\n\n#### 題意:\n編寫一個程序，該程序讀取N個整數的，最後輸出共有幾個質數。\n\n<!-- more -->\n#### 思路:\n先刪除二的倍數後，再以每次加二的方式除x如果可以整除代表不是質數。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/294c4a0563b9993a1c4a798e8cfc7ced.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"AOJ ALDS1_1_B - Greatest Common Divisor","url":"/ALDS1-1-B-Greatest-Common-Divisor/","content":"# 最大公約數\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/1/ALDS1_1_B)\n\n\n#### 題意:\n編寫一個程序，找出兩個自然數a和b的最大公約數。\n<!-- more -->\n#### 思路:\n用遞迴的方式不斷的取於數就可以得到最大公約數。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/6159a659218aad44c6213b1360cc6912.js\"></script>","tags":["implementation","dfs and similar"],"categories":["AOJ"]},{"title":"AOJ ALDS1_1_A - Insertion Sort","url":"/ALDS1-1-A-Insertion-Sort/","content":"# 插入排序\n[題目網址](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/1/ALDS1_1_A)\n\n\n#### 題意:\n編寫一個插入排序算法的程序，該程序按升序對序列A進行排序。\n<!-- more -->\n#### 思路:\n插入排序在每一次都會先刪除起始的數字，然後一直往後排直到有人大於他就插入。\n範例：\n5 3 2 4 | 起始數列\n3 5 2 4 | 3差到5前面\n2 3 5 4 | 2差到3前面\n2 3 4 5 | 4差到5前面\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/2fe34965f5ebae84b864e2f8e54aa299.js\"></script>","tags":["sortings"],"categories":["AOJ"]},{"title":"Codeforces 1113A","url":"/Sasha-and-His-Trip/","content":"# Codeforces 1113A - Sasha and His Trip\n[題目網址](https://codeforces.com/problemset/problem/1113/A)\n\n#### 題意:\nSasha喜歡到處旅行，在Sasha的國家裡有n座城市，這n座城市是連成一直線的且每座城市間距離相同，每去一座城市需要1公升的汽油，Sasha想要去這n座城市，Sasha有一台能裝v公升汽油的車，但這台車現在沒有汽油，每座城市都有加油站，第i座城市每一公升需要i的價錢，Sasha希望能花最少的錢完成這趟旅行，請問Sasha「最少」需要花多少錢來完成這趟旅行?\n<!-- more -->\n#### 思路:\n要花最少錢，則越早加油越好且不能有多餘的汽油，如果路的長度n-1比容量v還小，那n-1就是答案，如果n-1>v，紀錄會剩下多長的路(n-1-v)，從第二個城市開始每次都加一次油(錢)，最後加總就是答案。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/6dfa1886c95cd8ee5d58dfd7509ebbe6.js\"></script>","tags":["dp","greedy","math","900"],"categories":["Codeforces"]},{"title":"Codeforces 368B","url":"/Sereja-and-Suffixes/","content":"# Codeforces 368B - Sereja and Suffixes\n[題目網址](https://codeforces.com/problemset/problem/368/B)\n\n#### 題意:\nSereja有個陣列a，有n個數字a1,a2,...,an，Sereja想要找m次，從陣列中某個位置到最後一個位置共有幾個不同的數字。\n<!-- more -->\n#### 思路:\n用一個陣列來確認一個數字是否出現過，從陣列最後一個位置開始，每次遇到新數字就將答案+1後存成那個位置的答案，如果遇到舊數字就不用+1並且儲存答案。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/ef4c2bf6e76a5ada12fb3d4f203b0cd2.js\"></script>","tags":["dp","1100","data structures"],"categories":["Codeforces"]},{"title":"Codeforces 706B","url":"/Interesting-drink-1/","content":"# Codeforces 706B - Interesting drink\n[題目網址](https://codeforces.com/problemset/problem/706/B)\n\n#### 題意:\nVasiliy喜歡喝Beecola(一種飲料)，在他生活的城市中有n家店有賣，每家價格為x1,x2,...,xn，Vasiliy有q天，每天賺m1,m2,...,mq，請問Vasiliy每天所鑽到的錢可以到其中幾家店買到飲料(每天賺的錢是分開的)?\n<!-- more -->\n#### 思路:\n將店家依價格小到大排序，每天的金額為目標，找出第一個價格大於今天賺到的錢的店家，在此店家前的店家數就是答案。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/c69780f25b64001ce647a44fdd46c13c.js\"></script>","tags":["dp","implementation","binary search","1100"],"categories":["Codeforces"]},{"title":"Codeforces 1323A","url":"/Even-Subset-Sum-Problem/","content":"# Codeforces 1323A - Even Subset Sum Problem\n[題目網址](https://codeforces.com/problemset/problem/1323/A)\n\n#### 題意:\n給你一個陣列a，有n個正整數，找出一個非空的子集合，並且元素加總為偶數，印出共有幾個元素並把元素在陣列a中的位置印出來，如果找不到就印出-1。\n<!-- more -->\n#### 思路:\n共分三種情況:\n1.陣列a中有偶數 (子集合元素為1，並印出偶數在陣列a中的位置)\n2.陣列a中只有一個元素並且為奇數 (印出-1)\n3.陣列a中有一個以上的奇數 (子集合元素為2，位置為1、2)\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/bc4473376e327fee857828cdb1bd46ed.js\"></script>","tags":["dp","implementation","greedy","brute force","800"],"categories":["Codeforces"]},{"title":"Codeforces 732B","url":"/Cormen-—-The-Best-Friend-Of-a-Man/","content":"# Codeforces 732B - Cormen — The Best Friend Of a Man\n[題目網址](https://codeforces.com/problemset/problem/732/B)\n\n\n#### 題意:\nPolycarp養了一隻狗叫Cormen，但Polycarp有個麻煩，Cormen喜歡散步，Cormen在「連續兩天」中至少要散步k次才會開心，如果k=5，而昨天Polycarp帶著Cormen散步2次，那今天必須至少散步3次，再隔一天則至少要散步2次。\nPolycarp分析有n天，n天中每天Polycarp帶著Cormen散步a次，請幫Polycarp確定這n天中每天還需要「最少」多散步幾次Cormen才會開心。\n<!-- more -->\n共增加幾次，並把增加後每天需要散步幾次的結果都印出來。\n#### 思路:\n從第二天開始都要計算與前一天共散步幾次，不夠的話就補上並更改當天次數。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/441fd43738a5b291154d61494bcaaba5.js\"></script>","tags":["dp","greedy","1000"],"categories":["Codeforces"]},{"title":"Codeforces 313B","url":"/Ilya-and-Queries/","content":"# Codeforces 313B - Ilya and Queries\n[題目網址](https://codeforces.com/problemset/problem/313/B)\n\n\n#### 題意:\n給你一個字串s，由字元\".\"和\"#\"組成，共有m個查詢，每個查詢為一組數字(l,r)，代表字串中的位置從左邊l到右邊r，查出此區段間有多少符合s[i] = s[i+1]。\n(依題意，長度為n的字串，其字元對應位置為1~n)。\n<!-- more -->\n#### 思路:\n對每個字元s[i]紀錄從第一個字元s[1]到s[i]符合條件的數量，區間l ~ r的答案就會是1 ~ r的答案減掉1~l的答案。 \n\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/d2ee5f0909948e0231308c62bbcd921e.js\"></script>","tags":["dp","implementation","1100"],"categories":["Codeforces"]},{"title":"Codeforces 363B","url":"/Fence/","content":"# Codeforces 363B - Fence\n[題目網址](https://codeforces.com/problemset/problem/363/B)\n\n#### 題意:\nPolycarpus家門前有個圍欄，由n個寬度相同的木板組成，第i個木板高度為h，Polycarpus買了一台寬度為k的鋼琴，他希望他希望拆掉連續k個木板使鋼琴能搬到家裡，而越高的木板拆除越費力，所以他希望找出最省力位置移除木板，也就是說找出某個木板的位置，向右k-1個木板高度相加會是「最小」的。\n(圍欄是一個面，而不是環繞的; 木板的位置是1~n)\n<!-- more -->\n#### 思路:\n從第一個位置開始將k個木板的高度加總，紀錄高度與位置，每下一個位置，減去上個位置的木板加上下個木板，比較高度，較低的一方紀錄高度與位置，重複到n-k-1的位置，印出被記錄的位置就是答案。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/45797becf15b6e30f58e326843714188.js\"></script>","tags":["dp","1100","Brute force"],"categories":["Codeforces"]},{"title":"Codeforces 1206B","url":"/Make-Product-Equal-One/","content":"# Codeforces 1206B - Make Product Equal One\n[題目網址](https://codeforces.com/problemset/problem/1206/B)\n\n#### 題意:\n給你n個數字，你可以對每個數字進行+1或-1的操作，每次操作就是一次動作，希望最後將所有數字相乘結果為1，請問需要「最少」幾次動作能使所有數字相乘結果為1?\n<!-- more -->\n#### 思路:\n相乘為1就代表n個數字都必須調整成+1或-1，並且-1不能是奇數個，要最少動作，所以正數一定調整成1，負數一定調整成-1，零分開計算，如果有零就不需調整正負值，如果沒有零則最後答案+2(-1變+1是2動作)\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/f403062a1e75f40fb75f6bc72444807f.js\"></script>","tags":["dp","implementation","900"],"categories":["Codeforces"]},{"title":"Codeforces 580A","url":"/Kefa-and-First-Steps/","content":"# Codeforces 580A - Kefa and First Steps\n[題目網址](https://codeforces.com/problemset/problem/580/A)\n\n#### 題意:\n輸入數量為n的數字序列，請問此序列中非降序連續片段的最長長度是多少?<!-- more -->\n非降序序列:a[0] <= a[1] <= a[2] <= a[3]...。\n#### 思路:\n每次輸入一個新數字就跟上一個數字比較，如果新數字比較小，紀錄起點到上一個數字的長度並比較此長度與答案，將最長的存為答案，之後重新設定起點，重複以上動作到結束。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/48cc1a379a795ade9753108910ee212e.js\"></script>","tags":["dp","implementation","Brute force","900"],"categories":["Codeforces"]},{"title":"Codeforces 894A","url":"/QAQ/","content":"# Codeforces 894A - QAQ\n[題目網址](https://codeforces.com/problemset/problem/894/A)\n\n#### 題意:\n輸入一個字串，請問能找到幾組\"QAQ\"的子字串?\n<!-- more -->\n子字串是指完整的字串刪除幾個元素後形成的字串，例如:\"QAQAQYSYIOIWIN\"的子字串可以是\"Q\",\"QAQ\",\"AYS\",\"WIN\",\"QAQAQ\",\"QAQAQYSYIOIWIN\"等。\n#### 思路:\n找出字串中的字元'A'，從這個A的位置向左右尋找各有幾個Q，將左右兩邊的數量相乘，重複以上動作直到把所有A跑過一次，將每次相乘的結果相加就是所有能形成QAQ的數量。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/fdac775e8b16a25fb488b7b77aa24341.js\"></script>","tags":["dp","800","Brute force"],"categories":["Codeforces"]},{"title":"Codeforces 977F","url":"/Consecutive-Subsequence/","content":"# Codeforces 977F - Consecutive Subsequence\n[題目網址](https://codeforces.com/problemset/problem/977/F)\n\n#### 題意:\n輸入長度為n的數字序列，希望找出一個「最長為k」的子序列為[x, x+1,...,x+k-1]並印出「最長長度k」及相符的「元素位置」，如有多個答案印出任一個。\n<!-- more -->\n一個序列中可刪除任一或多個元素形成子序列，也可以不刪除任何元素，例如:序列[5,3,1,2,4]的子序列可以為[3],[5,3,1,2,4],[5,1,4],[3,1,4]等，但[1,2,3]不是子序列。\n#### 思路:\n因為子序列數字是連續的，所以數字x可能的最長長度會是x-1的最長長度+1，例如:\n假設發現某位置x=6有最長長度k=4，代表序列中有其中一個6，他的前面就會有3,4,5，若從此位置往下找發現7，則x=7的最長長度就會是k=5。\n因此利用map來記錄所有數字的最長長度，找出其中長度最長的數字就可以了。\n#### 程式碼:\n<script src=\"https://gist.github.com/zxzxcc112/d3a06af1beaac5bfe4cf1d7493466a11.js\"></script>\n","tags":["dp","1700"],"categories":["Codeforces"]},{"title":"Codeforces 873C","url":"/Strange-Game-On-Matrix/","content":"# Codeforces 873C - Strange Game On Matrix\n\n[Strange Game On Matrix](https://codeforces.com/problemset/problem/873/C)\n\n\n#### 題意:\n給你一個n x m陣列，由0跟1組成。現在對每一個直行計算分數，算法是由上往下找1，找到後計算下面最多k個數字內有幾個1作為分數。現在你還可以花1次行動將任意1個數字從1換成0，問你最多可以得到幾分，和這個分數下最少的行動是幾次？\n<!-- more -->\n#### 思路:\n對每一個直行計算區間高度k的分數，當第一個元素是1時實際計分，並且在脫離時將行動次數加1。跑完每一個直行後加總就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/6647f0ec1e751f77d1d389e3ea63a501.js\"></script>","tags":["greedy","普通","two pointers"],"categories":["Codeforces"]},{"title":"Codeforces 1038C","url":"/Gambling/","content":"# Codeforces 1038C - Gambling\n[Gambling](https://codeforces.com/problemset/problem/1038/C)\n\n\n#### 題意:\n兩個人各持n張牌，在各自的回合都可以做1)拿一張自己的牌算分數；2)移除對手的一張牌，的其中一個動作。假設兩個人都會做當下最自己最有利的一步，問最後a-b的分數是多少？\n<!-- more -->\n#### 思路:\n將兩人的牌都排序，比對雙方最大的牌，自己的大於等於對方的，就自己算分；否則就移除對方的牌。重覆到所有牌用完輸出答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/84aac07557a00f6523dd318516a8b796.js\"></script>","tags":["sortings","greedy","普通"],"categories":["Codeforces"]},{"title":"Codeforces 652B","url":"/z-sort/","content":"# Codeforces 652B - z-sort\n[z-sort](https://codeforces.com/problemset/problem/652/B)\n\n#### 題意:\n給你一個數列，現在希望排成a[0]&lt;a[1]>a[2]&lt;a[3]……的格式，問你有沒有可能？可以的話輸出排序後陣列，不能就輸出Impossible。\n<!-- more -->\n\n#### 思路:\n陣列排序，分成兩半，前半較小，用在小的部分；後半較大，用在大的部分。兩邊都從頭開始取，依照規則填入，可以的話輸出排序後陣列，不能就輸出Impossible。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/126107d2a5707324d18cb1d5b60592a1.js\"></script>","tags":["sortings","普通"],"categories":["Codeforces"]},{"title":"Codeforces 454B","url":"/Little-Pony-and-Sort-by-Shift/","content":"# Codeforces 454B - Little Pony and Sort by Shift\n[Little Pony and Sort by Shift](https://codeforces.com/problemset/problem/454/B)\n\n\n#### 題意:\n給你一個數列，你能做的動作就是將最後一個數字移到第一個，問你要做最少幾次可以將這個數列變成非遞減數列？步能的話輸出-1。\n<!-- more -->\n#### 思路:\n給你一個數列，你能做的動作就是將最後一個數字移到第一個，問你要做最少幾次可以將這個數列變成非遞減數列？步能的話輸出-1。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/a8cd8fe5c79e1c1ac22690e83aed27a7.js\"></script>","tags":["implementation","普通"],"categories":["Codeforces"]},{"title":"Codeforces 476A","url":"/Dreamoon-and-Stairs/","content":"# Codeforces 476A - Dreamoon and Stairs\n[Dreamoon and Stairs](https://codeforces.com/problemset/problem/476/A)\n\n\n#### 題意:\nn個台階，1次能爬1~2階，現在希望爬的次數是m的倍數且最小，請你輸出最小的可能次數，不能就輸出-1？\n<!-- more -->\n#### 思路:\n先計算最少的步數(a)跟最多的步數(b)，如果a可以，輸出a；如果b&lt;m，輸出-1；否則輸出(a/m+1)*m。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/bb6f37bf8be31dcf5e87553e9d731e2e.js\"></script>","tags":["implementation","math","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 918B","url":"/Radio-Station/","content":"# Codeforces 918B - Radio Station\n[Radio Station](https://codeforces.com/problemset/problem/918/B)\n\n#### 題意:\n給你n個伺服器名稱跟ip，再輸入m個命令跟目標ip，要你輸出每個命令跟目標ip加上伺服器名稱。\n<!-- more -->\n#### 思路:\n把伺服器名稱跟ip都先存著，輸入命令時比對ip，並輸出對應伺服器名稱。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/bf0719749e1c4f9b2a5372f84e918992.js\"></script>","tags":["implementation","簡單","strings"],"categories":["Codeforces"]},{"title":"Codeforces 31C","url":"/Schedule/","content":"# Codeforces 31C - Schedule\n[Schedule](https://codeforces.com/problemset/problem/31/c)\n\n#### 題意:\n給你n個課程的開始及結束時間，問你能不能只刪掉一個就讓所有課程的時間不重疊？\n<!-- more -->\n#### 思路:\n紀錄每個時間的開始及結束，排序，找同時有兩堂課重疊的最早及最晚，檢查有沒有課程比這個時間範圍大的，有的話該課程符合條件；沒有兩堂課重疊的話，所有課程都是答案；有三堂課同時重疊的話，沒有答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/397506b1a3517cded062fec9603cbfd6.js\"></script>","tags":["implementation"],"categories":["Codeforces"]},{"title":"Codeforces 219A","url":"/k-String/","content":"# Codeforces 219A - k-String\n[k-String](https://codeforces.com/problemset/problem/219/A)\n\n\n#### 題意:\n輸入k及一個字串，問你能不能將字串重組成重複k次的字串？\n<!-- more -->\n#### 思路:\n計算所有字元的出現次數是不是k的倍數，不是的話輸出-1；是的話將字填回輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/e4e0ff8ee8a7c9e81a3b707850e14d6c.js\"></script>","tags":["implementation","strings"],"categories":["Codeforces"]},{"title":"Codeforces 1225B2","url":"/TV-Subscriptions-Hard-Version/","content":"# Codeforces 1225B2 - TV Subscriptions (Hard Version)\n[TV Subscriptions (Hard Version)](https://codeforces.com/problemset/problem/1225/B2)\n\n\n#### 題意:\n輸入接下來n天預訂撥放的k種節目，問你在某一個連續的d天中，最少會看到幾種節目？\n<!-- more -->\n#### 思路:\n先看開始的d天，紀錄所有節目出現的次數及種類，接著往右移動區間，紀錄新增及減少的節目次數及種類，區間移動結束後輸出答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/23a9e2ddb3244b70ae1670235a68745c.js\"></script>","tags":["implementation","two pointers"],"categories":["Codeforces"]},{"title":"Codeforces 176A","url":"/Trading-Business/","content":"# Codeforces 176A - Trading Business\n[Trading Business](https://codeforces.com/problemset/problem/176/A)\n\n\n#### 題意:\n給你n個星球及各自m種商品的買價、賣價及庫存數量，現在只能在一個星球採購一次，最多共k個商品，然後在一個星球賣掉，扣掉成本後問你最多可以賺多少？\n<!-- more -->\n#### 思路:\n計算在i星球買到j星球賣的所有商品的價差，依利潤排序後根據庫存計算總利潤，跑完所有ij後輸出最高的。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/a091d508a0bf4212e112d56100d4c37b.js\"></script>","tags":["sortings","greedy"],"categories":["Codeforces"]},{"title":"Data Structures and Algorithms tutorials","url":"/Data-Structures-and-Algorithms/","content":"# 推薦清單\n<!-- more -->\n### #資料結構與演算\n+ [台灣師範大學](http://www.csie.ntnu.edu.tw/~u91029/)\n+ [Stanford](http://web.stanford.edu/class/cs97si/)\n+ [Codeforces Data Structures](https://codeforces.com/blog/entry/57282)\n+ [Codeforces Data Structures](https://codeforces.com/blog/entry/13529)\n+ [Codeforces DP](https://codeforces.com/blog/entry/67679)\n\n### #書本\n+ 資料結構\n> Fundamentals of Data Structures in C++ (Ellis Horowitz, Sartaj Sahni, Dinesh Mehta)\n>> Fundamentals of Data Structures in C (Ellis Horowitz, Sartaj Sahni, Susan Anderson-Freed)\n+ 演算法\n>> Introduction to Algorithms(Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein)\n+ 程式設計\n>> 提升程式設計的資料結構力(吳永輝)\n\n### #聖經\n+ 作業系統\n>> Operating System Concepts(Abraham Silberschatz)\n+ 計算機組織\n>> Computer Organization and Design: The Hardware/Software Interface(Hennessy Patterson)\n+ 資料庫系統\n> Fundamentals of Database Systems(Ramez Elmasri, Shamkant B. Navathe)\n>> Fundamentals of Database Systems(Navathe Elmasri)\n+ 組合語言\n>> Assembly Language for x86 Processors(Kip R. Irvine)\n+ 電腦網路\n>> Computer Networking : A Top-Down Approach(James Kurose)\n+ 線性代數\n>> Linear Algebra and Its Applications(David C. Lay / Steven R. Lay / Judi J. McDonald)\n+ 邏輯設計\n>> Fundamentals of Logic Design(Jr. , Larry Kinney, Charles Roth)\n\n### #Online Judge\n+ [Codeforces](https://codeforces.com/)\n+ [Leetcode](https://leetcode.com/)\n+ [UVA](https://uva.onlinejudge.org/)\n+ [AOJ](https://onlinejudge.u-aizu.ac.jp/home)\n\n### #網站\n+ [CHUCS](https://chucs.github.io/)\n+ [OI Wiki](https://oi-wiki.org/)\n\n\n","tags":["tutorials"],"categories":["資工推薦清單"]},{"title":"Two Ponit Tutorials","url":"/C-Two-Ponit-Tutorials/","content":"# C++ Two Ponit Tutorials\n### #雙指標\n+ 用來從陣列中搜尋特定區間\n+ 耗時為O(N)，比暴力法(O(N^2))快\n+ 需要在搜尋的區間跟區間長度有關時才能使用\n+ 使用兩個index作為左邊界跟右邊界\n+ 根據條件，需縮減區間時，左邊界右移\n+ 根據條件，需擴增區間時，右邊界右移\n+ 透過動態的區間內容搜尋所有可能\n\n<!-- more -->\n\n### #範例\n\n以1133C為範例，此題目給你一組數列，要 求你將他們分組，並滿足每組中最大的減最小的差在5以內，問你最多人的一組可以是多少人。\n>先將數列排序，然後依照雙指標的作法\n>> 區間最右邊(最大值)減區間最左邊(最小值)的差在5以內，滿足分組條件，嘗試擴充區間，右邊界右移。\n\n>> 差不在5以內，不滿足分組條件，縮減編組，左邊界右移。\n\n<script src=\"https://gist.github.com/Daviswww/46a2a0419fe4afda45a71ffe94337635.js\"></script>","tags":["tutorials","cpp"],"categories":["C++ tutorials"]},{"title":"String Tutorials","url":"/C-String-Tutorials/","content":"# C++ String Tutorials\n### #字串\n+ C++\n+ #include <string>\n+ using namespace std;\n+ string宣告，是一個class\n+ 可以用cin直接輸入\n+ 跟陣列一樣支援[]存取\n<!-- more -->\n### #常用功能\n\n> length()回傳長度。\n\n> 支援+、+=，可以直接串接字串。\n\n> erase(p, n)，從第p格開始移除n個字。\n\n> substr(p, n)，從第p格開始拿出n個字作為子字串回傳。\n\n> find(str)，找出第一次出現str是在第幾格，以str[0]為回傳位置，找不到會回傳string::npos。\n\n> 要輸入包含空白的字串的話使用getline(cin, str)，跟整數輸入混合使用時要注意getline有可能會擷取到前面輸入的換行。\n\n<script src=\"https://gist.github.com/Daviswww/75d830723ac386c2ab333899af69b9d2.js\"></script>","tags":["tutorials","cpp"],"categories":["C++ tutorials"]},{"title":"Codeforces 985B","url":"/Approximating-a-Constant-Range/","content":"# Codeforces 985B - Approximating a Constant Range\n[Approximating a Constant Range](https://codeforces.com/problemset/problem/602/B)\n\n\n#### 題意:\n給你一個數列，每一項的值都保證會是前一項的加1或減1，現在想找一個區段，其中最大的數字減最小的數字差在1以內，問你符合條件最長的區段是多長？\n<!-- more -->\n\n#### 思路:\n套用雙指標的方法，符合條件時嘗試擴張，尋找更長的區段；不符合時縮減區段，嘗試符合條件。每次擴張或縮減時都記錄上一次出現最大值跟最小值的位置，方便之後快速的更新左邊界。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/e7edb8ece9fa31bf333bfde68c2b7bf1.js\"></script>","tags":["dp","implementation","普通","two pointers"],"categories":["Codeforces"]},{"title":"Codeforces 1251A","url":"/Broken-Keyboard/","content":"# Codeforces 1251A - Broken Keyboard\n[Broken Keyboard](https://codeforces.com/problemset/problem/1251/A)\n\n\n#### 題意:\n現在有一個只會輸入26個英文小寫字母的鍵盤，有些鍵是正常的，有些是壞掉的，壞掉的鍵按一次會輸入兩個字，輸入過程中保證按鍵的好壞狀態不會改變。現在給你一些輸入完的字串，問你根據這個字串能保證是好的鍵有哪些，沒有就輸出空字串，有的話要依照字母順序輸出？\n<!-- more -->\n#### 思路:\n從最前面開始看所有字連續出現的次數，有曾經出現連續奇數次的話就能保證是正常的，記錄起來後輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/a3439ebfaa877a471d3723c30ef9d54b.js\"></script>","tags":["普通","strings","two pointers","brute force"],"categories":["Codeforces"]},{"title":"Codeforces 785B","url":"/Anton-and-Classes/","content":"# Codeforces 785B - Anton and Classes\n[Anton and Classes](https://codeforces.com/problemset/problem/785/B)\n\n#### 題意:\n現在有n個A課程的開始及結束時間，m個B課程的開始及結束時間。現在要在A跟B課程中各挑1個，讓他們中間的間隔時間愈長愈好，問你最長可以是多少？\n<!-- more -->\n#### 思路:\n所以是結束到開始中間的時間愈長愈好，因此輸入時就順便記錄AB各自最大的開始時間跟最小的結束時間，然後看A開始減B結束跟B開始減A結束哪個大就輸出哪個，都是負數就輸出0。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/30e597d386bca33013ab7b1a210d1c36.js\"></script>","tags":["sortings","greedy","普通"],"categories":["Codeforces"]},{"title":"Codeforces 1088B","url":"/Ehab-and-subtraction/","content":"# Codeforces 1088B - Ehab and subtraction\n[Ehab and subtraction](https://codeforces.com/problemset/problem/1088/B)\n\n\n#### 題意:\n給你一個數列，然後執行下列動作k次：先挑出數列中最小的非零正整數，輸出，然後將整個陣列減掉這個數。問你每次輸出的數是多少？\n<!-- more -->\n#### 思路:\n排序，然後從依照題目敘述，每次找最小的非零正整數，輸出，只有減的時候紀錄目前為止減了多少，不用真的減整個陣列，較省時。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/e573aee1ccb5f6ffd757ec02c778c7a6.js\"></script>","tags":["sortings","implementation","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 985B","url":"/Switches-and-Lamps/","content":"# Codeforces 985B - Switches and Lamps\n[Switches and Lamps](https://codeforces.com/problemset/problem/985/B)\n\n\n#### 題意:\n給你n個開關跟排成一排的m個燈，再輸入每個開關會開啟那些燈，開關1會開燈，0無動作，燈一旦開了就不會關，問你能否只用n – 1個開關就將所有燈打開？\n<!-- more -->\n#### 思路:\n輸入後先將開關數累加，紀錄每個燈有幾個開關可以開。然後跑每個開關，看這個開關可以開的燈是否每個都有2個以上的開關接著，是的話表示這個開關是多的，可以拿掉，輸出YES；找不到這樣的開關的話輸出NO。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/fdb447a92830049826ce20745663d70d.js\"></script>","tags":["implementation","普通"],"categories":["Codeforces"]},{"title":"Codeforces 1095B","url":"/Array-Stabilization/","content":"# Codeforces 1095B - Array Stabilization\n[Array Stabilization](https://codeforces.com/problemset/problem/1095/B)\n\n\n#### 題意:\n給你一個數列，問你從中挑出一個刪掉後，剩下的最大值減最小值的差最少可以是多少？\n<!-- more -->\n#### 思路:\n排序，然後比較減去最大值跟最小值後的差，輸出少的。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/c9bd065b6f08ba5c4596fcf80971236b.js\"></script>","tags":["sortings","implementation","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 79B","url":"/Colorful-Field/","content":"# Codeforces 79B - Colorful Field\n[Colorful Field](https://codeforces.com/problemset/problem/79/B)\n\n\n#### 題意:\n給你一塊地及一些浪費的座標位置，其餘的座標從上到下左到右依序種紅蘿蔔、奇異果及葡萄，現在問你某個特定座標是被浪費了還是種了什麼作物？\n<!-- more -->\n#### 思路:\n將所有浪費的座標上到下左到右排序，之後輸入每個查詢座標時去找它前面有幾個浪費的座標，若本身就是浪費的點就不用繼續了，直接輸出；否則先記錄下來，將現在的座標轉為上到下左到右順序的順序數後減去記錄下來的數字，可以得到這座標是第幾個沒被浪費的點，對3取餘數就能知道會種什麼東西。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b0afbe68ce22d745f75b50eb1b16cc6b.js\"></script>","tags":["sortings","implementation","普通"],"categories":["Codeforces"]},{"title":"Codeforces 334B","url":"/Eight-Point-Sets/","content":"# Codeforces 334B - Eight Point Sets\n[Eight Point Sets](https://codeforces.com/problemset/problem/334/B)\n\n\n#### 題意:\n給你8個點，問你這8個點是否能排成一個沒有中心點的九宮格？\n<!-- more -->\n#### 思路:\n按照先x後y的順序小排到大，然後依照規則比對座標的相等跟不相等。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/71f0f6f8ee6989f953238a85941082b8.js\"></script>","tags":["sortings","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 160B","url":"/Unlucky-Ticket/","content":"# Codeforces 160B - Unlucky Ticket\n[Unlucky Ticket](https://codeforces.com/problemset/problem/160/B)\n\n\n#### 題意:\n一張票券上的序號會由偶數個數字組成，如果前半的每個數字，都能不重複地找到一個後半的數字比它大；或是前半的每個數字，都能不重複地找到一個後半的數字比它小，則稱這張票券為不幸運票券。現在輸入票券序號，問你它是否是不幸運票券？\n<!-- more -->\n#### 思路:\n將前半及後半各自排序，然後比對是否每個數字都比較大或每個數字比較小。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/807796ebbf46f2126719277a42631a32.js\"></script>","tags":["sortings","greedy","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 988B","url":"/Substrings-Sort/","content":"# Codeforces 988B - Substrings Sort\n[Substrings Sort](https://codeforces.com/problemset/problem/988/B)\n\n\n#### 題意:\n給你一些字串，問你這些字串能否重新排列成，所以前面的字串都是此字串的子字串。\n<!-- more -->\n#### 思路:\n記錄下每個字串有幾個子字串，依照這個數字從小排到大，然後檢查是否每個字串的子字串數量都大於等於目前前面的字串數量，是的話就OK，否則輸出NO。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/1c28cc0e18778558f044237db1d4d574.js\"></script>","tags":["sortings","普通","strings"],"categories":["Codeforces"]},{"title":"Codeforces 1263B","url":"/PIN-Codes/","content":"# Codeforces 1263B - PIN Codes\n[PIN Codes](https://codeforces.com/problemset/problem/1263/B)\n\n\n#### 題意:\n有許多張卡，每張卡的密碼都是4位數字，現在想要將每張卡的密碼都改成不一樣的，請問最少要改幾個位數的數字？\n<!-- more -->\n#### 思路:\n因為最多只有10張卡，所以其實只需要針對一個位數做變化就能保證全部不一樣了，這邊挑個位數。先針對個位數將用過的0~9記錄下來，然後比對陣列中同樣的密碼，將其中一邊的個位數改成沒用過的數字，記錄下有幾個數字需要改，輸出答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b59af905ca283d646dbe25d93f73d09b.js\"></script>","tags":["implementation","greedy","普通"],"categories":["Codeforces"]},{"title":"Codeforces 697A","url":"/Pineapple-Incident/","content":"# Codeforces 697A - Pineapple Incident\n[Pineapple Incident](https://codeforces.com/problemset/problem/697/A)\n\n\n#### 題意:\n有顆鳳梨會在t秒開始的1秒及之後每s秒開始的2秒像狗一樣叫，現在給你t、s及x，問你第x秒時鳳梨是否有在叫？\n<!-- more -->\n#### 思路:\n依照題目的敘述檢查。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/1cbfb94cced2daad54f097dbe25fefff.js\"></script>","tags":["implementation","math","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 266A","url":"/Stones-on-the-Table/","content":"# Codeforces 266A - Stones on the Table\n[Stones on the Table](https://codeforces.com/problemset/problem/266/A)\n\n#### 題意:\n桌上有3個顏色(RGB)的石頭排成一列，現在希望每個石頭的隔壁都是不同顏色的石頭，在不改變順序只挑除一些石頭的情況下，請問最少挑出幾個石頭就能達到要求？\n<!-- more -->\n#### 思路:\n從第2個石頭開始，遇到跟前一個一樣顏色的石頭就挑掉。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/d9d3881c3007f9e1b2d49a954758a357.js\"></script>","tags":["implementation","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 677A","url":"/Vanya-and-Fence/","content":"# Codeforces 677A - Vanya and Fence\n[Vanya and Fence](https://codeforces.com/contest/677/problem/A)\n\n\n#### 題意:\n輸入n和h分別是有幾個人和圍牆高度，為了不被警衛發現所以人的高度比圍牆高就要彎腰。\n舉例：\n3 7\n4 5 14\n圍牆高度7所以4, 5不需彎腰所以是1，14要彎所以是2，答案就是1+1+2=4。\n<!-- more -->\n#### 思路:\n逐一比較如果h大於等於身高ans+1，其他ans+2。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/bf2ade7ddbf3787c47b6d7bc0ad4f112.js\"></script>","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"Codeforces 231A","url":"/Team/","content":"# Codeforces 231A - Team\n[Team](https://codeforces.com/contest/231/problem/A)\n\n\n#### 題意:\n他們在比一個程式比賽，他們有兩個人確定這個方法可行就寫，題目問他們確定的題數有幾題。\n<!-- more -->\n#### 思路:\n輸入的三個數字相加大於二就把答案加一。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/21ecb8dcb8d98908af0bb155b7063813.js\"></script>","tags":["greedy","新手","brute force"],"categories":["Codeforces"]},{"title":"Codeforces 263A v2","url":"/Beautiful-Matrix-1/","content":"# Codeforces 263A v2 - Beautiful Matrix\n[Beautiful Matrix](https://codeforces.com/problemset/problem/263/A)\n\n\n#### 題意:\n有個5X5得矩陣，裡面有24個0和1個1，問你需要幾步可以把1移到中間。\n<!-- more -->\n#### 思路:\n取得1的位置後將他與中間的位置相減取絕對值並相加，假設1得位置為[1, 1]那麼中間的位置為[3, 3]，相減後可得到行要移動兩格，列要移動兩格才可以到中間。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/92fe6578203256455873d894f5fcd7dc.js\"></script>","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"Codeforces 84B","url":"/Magical-Array/","content":"# Codeforces 84B - Magical Array\n[Magical Array](https://codeforces.com/contest/84/problem/B)\n\n\n#### 題意:\n給你一條數列問你所有連續的子空間為多少，如下列範例：\n4\n2 1 1 4\n可以看到兩個連續的1其他都只有一個\n1的位置: [1;1], [3;3], [2;3]\n其他: [2;2], [4;4]\n<!-- more -->\n#### 思路:\n可以由上面1的例子得到2一樣的數字為1+2個可能，如果3個一樣的話就是1+2+3，所以我們可以先建一個一加到十萬的表，如果數字一樣我們就把計數器加一如果不一樣就查表。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/e9f132ec324b04cf79d2285e8ff962a3.js\"></script>","tags":["implementation","一般","combinatorics"],"categories":["Codeforces"]},{"title":"Codeforces 734A","url":"/Anton-and-Danik/","content":"# Codeforces 734A - Anton and Danik\n[Anton and Danik](https://codeforces.com/contest/734/problem/A)\n\n\n#### 題意:\nAnton 和 Danik 在玩遊戲幫他們計算誰是贏家，出現A代表Anton贏，D代表Danik贏。\n<!-- more -->\n#### 思路:\n輸入時使用char\b這樣就可以一個一個輸入接著每次輸入時把每個字元當成index的值做增加，最後比較陣列內的值就可以得到答案了。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/1b2fec18d40c76e37755a65faec8cae3.js\"></script>","tags":["implementation","strings","新手"],"categories":["Codeforces"]},{"title":"社團網站維護指南","url":"/hexo-tutorials/","content":"# 社團網站維護指南\n### ＃什麼是 Hexo？\n[Hexo](https://hexo.io/) 是一個快速、簡單且強大的網誌框架。[Hexo](https://hexo.io/) 使用 [Markdown](https://chucs.github.io/Markdown/4)（或其他標記語言）解析您的文章，並在幾秒鐘內，透過漂亮的主題產生靜態檔案。\n<!-- more -->\n### 安裝需求\n安裝 Hexo 相當簡單；然而，在安裝前您必須先檢查下列您的電腦是否已經安裝下列軟體：\n● Node.js\n● Git\n\n#### 安裝 Git\n[git](https://git-scm.com/)\n● Windows：下載並安裝 git.\n● Mac：使用 Homebrew, MacPorts 或 安裝程式 安裝。\n● Linux (Ubuntu, Debian)：sudo apt-get install git-core\n● Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n\n#### 安裝 Node.js\n[Node.js](https://nodejs.org/en/)\n\n#### 安裝 Hexo 套件\n```\ngit clone https://github.com/CHUCS/CHUsource.git CHUsource\ncd CHUsource\ngit clone https://github.com/CHUCS/theme-next.git themes/next\nnpm install\n```\n\n### ＃指令\n\n#### 創建一個頁面\n```\n$ hexo new [layout] <title>\n```\n範例：hexo new \"Codeforces12345\"\n\n可以在資料夾內的sources/_posts找到你生成的頁面，上面分別會寫著你的標題、時間和標記你可以隨意更改，而下面空白處則是妳網頁顯示的內容，可以參考[Markdown](https://chucs.github.io/Markdown/4)語法或其他的psot檔撰寫。\n```\n---\ntitle: 我是留言板\ndate: 2019-03-02 10:51:33\nkeywords: 我是, 留言板\ncategories: 留言板\ntags:\n    - 留言板\n---\n```\n\n#### 生成頁面\n生成你所撰寫的網頁使你可以瀏覽。\n```\n$ hexo g\n```\n\n#### 啟動本地伺服器\n你可以瀏覽你所創建的頁面是否與你想要的一樣。\n```\n$ hexo s\n```\n\n#### 發布到網站\n將撰寫完的內容發佈至組織裡使網站更新。\n```\n$ hexo d\n```\n\n##### note:\nQ1: 無法使用hexo指令？\nA1: 你的終端機必須為管理員權限否則找不到指令。\n\nQ2: 為無法發佈？\nA2:首先你必須擁有一個[Github](https://github.com/)帳號，然後由管理員邀請至社團組織內[CHUCS](https://github.com/CHUCS)。\n\n","tags":["tutorials","hexo"],"categories":["社團網站維護指南"]},{"title":"Hexo下的Markdown語法","url":"/Markdown/","content":"# Hexo下的Markdown語法\n### 標題\n```\n# 一級標題        //一級標題 對應 <h1> </h1>\n## 二級標題       //二級標題 對應 <h2> </h2>\n### 三級標題      //三級標題 對應 <h3> </h3>\n#### 四級標題     //四級標題 對應 <h4> </h4>\n##### 五級標題    //五級標題 對應 <h5> </h5>\n###### 六級標題   //六級標題 對應 <h6> </h6>\n####### 七級標題  //六級標題 對應 <h7> </h7>\n```\n\n<!-- more -->\n### 文字強調\n\n```\n**文字** , __文字__                   //加粗\n```\n\n範例: **文字** , __文字__\n\n```\n*文字* , _文字_                       //斜體\n```\n\n範例: *文字* , _文字_  \n\n```\n***文字*** , __文字__ , *__文字__*    //加粗斜體\n```\n\n範例: ***文字*** , __文字__ , *__文字__*\n\n```\n~~文字~~                             //刪除\n```\n\n範例: ~~文字~~ \n\n```\n<code>文字</code>    //文字Mark\n```\n\n範例: <code>文字</code> \n\n### 引用\n\n```\n>文字一\n>>文字二\n>>>文字二\n123\n>>>>文字二\n456\n```\n\n範例:\n>文字一\n>>文字二\n>>>文字二\n123\n>>>>文字二\n456\n\n### 表格\n- 和 | 分割行和列\n: 控制對齊方式\n\n#### 無冒號對齊\n\n```\n   列1   | 列2 | 列3 \n   ----- | --- | ---- \n第1行 | 777  | 777 \n第2行 | 777  | 777  \n第3行 | 777  | 777\n```\n\n範例:\n\n   列1   | 列2 | 列3 \n   ----- | --- | ---- \n第1行 | 777  | 777 \n第2行 | 777  | 777  \n第3行 | 777  | 777\n\n#### 冒號對齊:\n\n```\n| 靠左    |  靠右 | 置中 |\n| :-------- | -------:| :--: |\n| Computer  | 5000 元 |  1台 |\n| Phone     | 1999 元 |  1部 |\n```\n\n範例:\n\n| 靠左       |  靠右   | 置中 |\n| :-------- | -------:| :--: |\n| Computer  | 5000 元 |  1台 |\n| Phone     | 1999 元 |  1部 |\n\n### 鏈接\n\n```\n[首页](連結)\n[關於我](連結)\n[教學](連結)\n```\n\n範例:\n\n[首页](連結)\n[關於我](連結)\n[教學](連結)\n\n### 列表\n\n```\n* 列表展示\n* 列表展示\n * 列表展示 //注意空白\n+ 列表展示\n+ 列表展示\n + 列表展示 //注意空白\n- 列表展示\n- 列表展示\n - 列表展示 //注意空白\n```\n\n範例:\n\n* 列表展示\n* 列表展示\n * 列表展示 //注意空白\n+ 列表展示\n+ 列表展示\n + 列表展示 //注意空白\n- 列表展示\n- 列表展示\n - 列表展示 //注意空白\n\n### 圖片\n\n```\n![我的頭像](圖片地址)\n![我朋友的朋友就是我的頭像](圖片地址)\n```\n\n### 範例:\n![我的頭像](圖片地址)\n![我朋友的朋友就是我的頭像](圖片地址)","tags":["tutorials","hexo"],"categories":["社團網站維護指南"]},{"title":"CodeForces 1174B","url":"/Ehab-Is-an-Odd-Person/","content":"# CodeForces 1174B - Ehab Is an Odd Person\n[Ehab Is an Odd Person](https://codeforces.com/problemset/problem/1174/B)\n\n\n#### 題意:\n給你一個數列，當其中的兩個數奇偶不同的時候，可以將其交換。問你這個數列最小的字典順序為何？\n<!-- more -->\n#### 思路:\n觀察後可以發現，當整個陣列都是奇數或都是偶數時完全無法交換，因此可以直接輸出；另外的情況其實跟可以任意交換是一樣的，因此直接排序後輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/8a048f0981d076ff0257de1ffde0972f.js\"></script>","tags":["sortings","普通"],"categories":["Codeforces"]},{"title":"CodeForces 1011A","url":"/Stages/","content":"# CodeForces 1011A - Stages\n[Stages](https://codeforces.com/problemset/problem/1011/A)\n\n\n#### 題意:\n現在需要組一個由k段構造構成的火箭，每一段的構造都用一個小寫英文字母代表，重量等同他在英文字母中的順序。每一段構造必須從輕的挑起，且一旦被挑過，下一段構造一定要至少比這一段重2以上。現在輸入可以用的段數量、需要的段數以及每一段的編號，問你這火箭最低的總重量是多少，組不出來則輸出-1？\n<!-- more -->\n#### 思路:\n將所有編號排序，從小的開始依規則挑，能挑出k段則輸出答案，不能就輸出-1。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/4f04d5a5ff3b7ab57d56696801f16ba2.js\"></script>","tags":["sortings","implementation","greedy","普通"],"categories":["Codeforces"]},{"title":"CodeForces 1206A","url":"/Choose-Two-Numbers/","content":"# CodeForces 1206A - Choose Two Numbers\n[Choose Two Numbers](https://codeforces.com/problemset/problem/1206/A)\n\n\n#### 題意:\n輸入兩個集合的元素數量及集合中的所有元素，請你從兩個集合中各挑出一個元素，讓這兩個元素的和不在這兩個集合中。\n<!-- more -->\n#### 思路:\n因為元素都是正整數，所以兩個元素的和一定比這兩個元素大，因次只要挑出兩個集合中各自最大的元素相加就一定不在原本的集合中。排序，輸出各自最大的元素。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/d975ad83e445dcad60d027f3b73a057e.js\"></script>","tags":["sortings","math","普通"],"categories":["Codeforces"]},{"title":"CodeForces 368A","url":"/Sereja-and-Coat-Rack/","content":"# CodeForces 368A - Sereja and Coat Rack\n[Sereja and Coat Rack](https://codeforces.com/problemset/problem/368/A)\n\n\n#### 題意:\n餐廳有一個有n個鉤子的衣架，每一個鉤子只能掛一件衣服，且第i個鉤子需要付a_i元。現在每個客人來的時候都會想要掛衣服在最便宜的鉤子上，如果沒有鉤子能掛的話老闆需要賠d元給客人。現在輸入鉤子的數量、一次要賠的錢、所有鉤子要掛衣服時要付的價錢以及客人的數量，問你最後老闆今天靠鉤子會收到多少錢(有可能是負的)？\n<!-- more -->\n#### 思路:\n排序後按照客人數量由最便宜的鉤子開始掛，沒得掛就扣錢，輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/088f66204dfceb4ca145801133690fbe.js\"></script>","tags":["implementation","普通"],"categories":["Codeforces"]},{"title":"CodeForces 450A","url":"/Jzzhu-and-Children/","content":"# CodeForces 450A - Jzzhu and Children\n[Jzzhu and Children](https://codeforces.com/problemset/problem/450/A)\n\n\n#### 題意:\n發糖果，孩子會排隊領取固定顆數的糖果，如果還沒拿到該孩子要拿的顆數，他會再回去排隊；已經達到的話就會直接回家。現在輸入人數、每一次發幾顆糖及每個孩子要拿的顆數，問你最後一個拿到糖的孩子的編號？\n<!-- more -->\n#### 思路:\n邊輸入邊計算每個孩子要排幾次隊，紀錄數字最高且最後一次出現的人的編號，輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/e01c3757ac81898aca72950dec9326d9.js\"></script>","tags":["implementation","普通"],"categories":["Codeforces"]},{"title":"CodeForces 731A","url":"/Night-at-the-Museum/","content":"# CodeForces 731A - Night at the Museum\n[Night at the Museum](https://codeforces.com/problemset/problem/731/A)\n\n\n#### 題意:\n給你一個轉盤式的密碼鎖以及密碼，問你最少需要轉幾個刻度才能輸入完密碼(輸入每個字後不會強制回到a) ？\n<!-- more -->\n#### 思路:\n每次旋轉都挑正反兩個方向中次數少的那邊。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/fabe31e27089cdced4c29c309941d198.js\"></script>","tags":["implementation","簡單","strings"],"categories":["Codeforces"]},{"title":"Sort Tutorials","url":"/C-sort-tutorials/","content":"# C++ sort tutorials\n● C++\n● #include &lt;algorithm>\n● using namespace std;\n● sort(sort_start, sort_end, compare_function);\n● sort_start：排序範圍開頭記憶體位址，通常直接用陣列名稱\n● Sort_end：排序範圍結尾記憶體位址，此位址不參與排序\n<!-- more -->\n### compare_function\n如何排大小的規則函式。若是排序內容是預設基本型態，此參數不輸入會由小排到大，其他需求都要指定此參數。\n\ncompare_function規定：bool [functino_name]([type] [left_name], [type] [right_name])\n\n例如要排整數的話可以使用bool fn(int a, int b)\n回傳值為false時會交換兩個數值再陣列中的位置\n\n### int sort\n將int型態的陣列[0]~[N-1]，從小排到大的範例\n<script src=\"https://gist.github.com/Daviswww/4c8d1bde4175809c360af6d3d94ce31f.js\"></script>\n\n### double sort\n將double型態的陣列[0]~[N-1]，從大排到小的範例\n<script src=\"https://gist.github.com/Daviswww/f5d5d5ad8889dd901c0592c44cc85dd7.js\"></script>\n\n### struct sort\n將P型態的陣列[0]~[49]，照xyz的順序從小排到大的範例\n<script src=\"https://gist.github.com/Daviswww/7b7e077c9a039f41b133bcb5a3ae0d0e.js\"></script>\n\n\n將P型態的陣列[10]~[59]，照yzx的順序排序，y從大到小、z從小到大、x從大到小的範例\n<script src=\"https://gist.github.com/Daviswww/be568787c971a111256929843cb0b5ff.js\"></script>","tags":["tutorials","cpp"],"categories":["C++ tutorials"]},{"title":"CodeForces 1325A","url":"/EhAb-AnD-gCd/","content":"# CodeForces 1325A - EhAb AnD gCd\n[EhAb AnD gCd](https://codeforces.com/problemset/problem/1325/A)\n\n\n#### 題意:\n依照公式GCD(a, b) + LCM(a, b) = x。現在給你x，請輸出一組符合這個式子的a、b？\n<!-- more -->\n#### 思路:\nGCD(1, n) = 1、LCM(1, n) = n，因此GCD(1, n) + LCM(1, n) = 1 + n。現在另x = 1 + n，因此至少有一組1, x – 1符合題目要求，輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/46dd942f5333b36555552d6dd52cfdbe.js\"></script>","tags":["greedy","普通","constructive algorithms","number theory"],"categories":["Codeforces"]},{"title":"CodeForces 363A","url":"/Soroban/","content":"# CodeForces 363A - Soroban\n[Soroban](https://codeforces.com/problemset/problem/363/A)\n\n\n#### 題意:\n算盤，現在用直的表示，左邊的珠子表示5，右邊的珠子每往左1個就表示1，現在輸入一個數字，要你從低到高將每個位數由上至下用算盤的格式表示出來？\n<!-- more -->\n#### 思路:\n從個位數開始直接依照題目的格式表示。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/0a787760d3ba4f0dfb1d8706b0a6b5b3.js\"></script>","tags":["implementation","簡單"],"categories":["Codeforces"]},{"title":"CodeForces 1326B","url":"/Maximums/","content":"# CodeForces 1326B - Maximums\n[Maximums](https://codeforces.com/problemset/problem/1326/B)\n\n\n#### 題意:\n給一個a陣列，創建一個x陣列x_i項是a陣列前i-1項中的最大值，再創建一個b陣列，b_i項是a_i-x_i。現在給你陣列長度n及b陣列的所有內容，問你a陣列的內容為何？\n<!-- more -->\n#### 思路:\n依據給的公式可以推出x_0=0，b_0=a_0-x_0 => a_0 = b_0。在知道a_0之後就能知道x_1 = a_0，知道x_1及b_1後可以推出a_1；然後依序推出x_2、a_2、x_2、a_3…，將a記錄起來就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/62b5e39b9129cdfe55d19ecc3a5208a9.js\"></script>","tags":["implementation","math","簡單"],"categories":["Codeforces"]},{"title":"CodeForces 1324B","url":"/Yet-Another-Palindrome-Problem/","content":"# CodeForces 1324B - Yet Another Palindrome Problem\n[Yet Another Palindrome Problem](https://codeforces.com/problemset/problem/1324/B)\n\n\n#### 題意:\n給你一串數列，問你能不能在其中挑出長度至少為3並且是迴文的子序列？\n<!-- more -->\n#### 思路:\n首先，迴文長度若是偶數，表示中心兩個字是一樣的，那就可以不取其中一個，將迴文長度轉為奇數；其次，若迴文長度是奇數，則最旁邊兩個一定是一樣的，可以一起去掉，讓長度減2且還是奇數。綜合前面兩點，可以得知若有迴文，則一定可以推導成長度3的迴文，因此，目標可以推導成要找出有沒有長度正好是3的迴文。接下來觀察長度正好是3迴文，發現只有兩種模式，aaa和aba，第一種由3個一樣的字組成，第二個由兩個不連續的一樣字夾著一個不一樣的字組成。邊輸入邊記錄所有數字的出現次數和出現位置，若有數字出現3次以上，那就可以形成第一種迴文，輸出YES；若有數字出現兩次了，計算這兩次出現位置是不是不再隔壁，是的話中間就可以隨便挑一個夾著形成第二種迴文，輸出YES；都無法滿足就輸出NO。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/0ad7961413bd4ebb31fcc13a4ab418e5.js\"></script>","tags":["普通","strings","brute force"],"categories":["Codeforces"]},{"title":"CodeForces 1321C","url":"/Remove-Adjacent/","content":"# CodeForces 1321C - Remove Adjacent\n[Remove Adjacent](https://codeforces.com/problemset/problem/1321/C)\n\n#### 題意:\n給你一個泉小寫英文字母字串，你能夠對字串執行的動作是把滿足條件的1個目標字元刪除，條件是要刪除的字元隔壁至少要有一個字元的英文字母順序再此字元前面1位(因此你永遠無法刪除a)，問你最多可以刪除幾個字元？\n<!-- more -->\n#### 思路:\n觀察後可以發現，同樣文字的刪除順序不會影響結果，因此從z開始往a刪除，記錄刪除次數就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/5f31b3e317535b12c8075e8d4764c11e.js\"></script>","tags":["greedy","普通","strings","brute force","constructive algorithms"],"categories":["Codeforces"]},{"title":"CodeForces 1324A","url":"/Yet-Another-Tetris-Problem/","content":"# CodeForces 1324A - Yet Another Tetris Problem\n[Yet Another Tetris Problem](https://codeforces.com/problemset/problem/1324/A)\n\n\n#### 題意:\n給你一個俄羅斯方塊現在每一排的高度，你只能使用高2寬1的方塊，且不能旋轉。問你是否能將所有方塊全部消除？\n<!-- more -->\n#### 思路:\n因為不能旋轉，所以先記錄最高的排高度是多少，然後計算該排跟其他所有排的高度差，如果都能被2整除，那就輸出YES；否則輸出NO。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/42cc0cba34f5e3eb8bdf0709ec72f3d5.js\"></script>","tags":["implementation","簡單","number theory"],"categories":["Codeforces"]},{"title":"CodeForces 509A","url":"/Maximum-in-Table/","content":"# CodeForces 509A - Maximum in Table\n[Maximum in Table](https://codeforces.com/problemset/problem/509/A)\n\n\n#### 題意:\n給你一個矩陣，最上面及最左邊的元素都是1，剩下的元素會等於該元素上面和左邊元素的和。問你這矩陣中最大的元素是多少？\n<!-- more -->\n#### 思路:\n依照此種加法，最大的元素一定出在最右下，因此依照順序從上到下、左到右實際加一遍後，輸出右下的元素就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/06980227327d9159c2d37e937923aa78.js\"></script>","tags":["implementation","簡單","brute force"],"categories":["Codeforces"]},{"title":"CodeForces 711A","url":"/Bus-to-Udayland/","content":"# CodeForces 711A - Bus to Udayland\n[Bus to Udayland](https://codeforces.com/problemset/problem/711/A)\n\n\n#### 題意:\n輸入巴士的座位表，O表示空位；X表示已有人。現在問你是否有兩個不跨走道且相鄰的座位？有的話將輸出YES並將目標改為+輸出座位表，沒有的話輸出NO。\n<!-- more -->\n#### 思路:\n邊輸入邊判斷有沒有連續的兩個O，沒有就輸出NO；有的話將內容改成+，輸出YES後輸出座位表。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/be44b870a1a38cef36ab17aa4baaba14.js\"></script>","tags":["implementation","簡單","brute force"],"categories":["Codeforces"]},{"title":"CodeForces 1284A","url":"/New-Year-and-Naming/","content":"# CodeForces 1284A - New Year and Naming\n[New Year and Naming](https://codeforces.com/problemset/problem/1284/A)\n\n\n#### 題意:\n類似天干地支的年份表示法，現在輸入天干地支各有幾個，問你第N年的干支是什麼？\n<!-- more -->\n#### 思路:\n輸入完記錄起來，用求餘數的方式得知目標年份的天干地支，輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/5a59b212c09feaf8616bf6d40f0104d8.js\"></script>","tags":["implementation","簡單","strings"],"categories":["Codeforces"]},{"title":"CodeForces 1321A","url":"/Contest-for-Robots/","content":"# CodeForces 1321A - Contest for Robots\n[Contest for Robots](http://codeforces.com/problemset/problem/1321/A)\n\n\n#### 題意:\n有兩台機器人要比賽解題，現在你可以對每一題分配一個大於等於1的分數，答對時可以獲得該分數，答錯沒有分數。現在輸入問題數量及每個問題兩邊的機器人是否會答對，問你如果要讓第一台機器人贏的話，所有配分中分數最高的題目，最少分數要是多少？\n<!-- more -->\n#### 思路:\n計算1對2錯的題數(a)及1錯2對的題數(b)，a>b時，不用調整配分，輸出1；a<=b且a!=0時，因為分數要比第二隊多，不能一樣，將b+1分盡量平均分配到a題上，輸出答案；a==0時，怎麼調整都無法達成，輸出-1。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/fb445b42e4ab3b7419d04804ab503890.js\"></script>","tags":["greedy","簡單"],"categories":["Codeforces"]},{"title":"CodeForces 1313A","url":"/Fast-Food-Restaurant/","content":"# CodeForces 1313A - Fast Food Restaurant\n[Fast Food Restaurant](https://codeforces.com/problemset/problem/1313/A)\n\n\n#### 題意:\n輸入3種餐點的數量，依據每個人至少分到1份餐點、每種餐點不能分超過1份、所有人都要分到不一樣的組合，這3個條件。問這些餐點能分給幾個人？\n<!-- more -->\n#### 思路:\n總共只有7種分配方式，先紀錄起來，然後將這7種分配方式的所有分配可能(有128種)全部跑一次，將可能的方式中可以分給最多人的次數記錄起來輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/5d01eeb4d2d5ca796a5387d25f4c133e.js\"></script>","tags":["implementation","greedy","簡單","brute force"],"categories":["Codeforces"]},{"title":"CodeForces 1311A","url":"/Add-Odd-or-Subtract-Even/","content":"# CodeForces 1311A - Add Odd or Subtract Even\n[Add Odd or Subtract Even](https://codeforces.com/problemset/problem/1311/A)\n<!-- more -->\n\n#### 題意:\n輸入a, b兩個數字，現在一個行動可以將a加上任意正奇數，或是減掉任意正偶數。問最少需要幾個行動可以將a變成b？\n\n#### 思路:\n先判斷大小關係，a==b時，輸出0；a &lt; b時，差距是奇數輸出1，偶數輸出2(加1、加差距-1)；a&gt;b時，差距是奇數輸出2(加1減差距+1)，偶數輸出1。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/aac217a151f71cd00e822322c2f960d1.js\"></script>","tags":["implementation","greedy","math","簡單"],"categories":["Codeforces"]},{"title":"CodeForces 1A","url":"/Theatre-Square/","content":"# CodeForces 1A - Theatre Square\n[Theatre Square](https://codeforces.com/contest/1/problem/A)\n\n\n#### 題意:\n他給你一塊面積NxM問你要多少個AxA才能完全覆蓋所有面積，而且石板無法切割\b\n<!-- more -->\n#### 思路:\n將Ｎ/A和Ｍ/A並無條件進位可得長與寬，把他們相乘後就可以以算出完全覆蓋需要幾塊石板了\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/ac6b4d9fb4e730033bbee2a1bf8827b1.js\"></script>","tags":["math","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 1315A","url":"/Dead-Pixel/","content":"# Codeforces 1315A - Dead Pixel\n[Dead Pixel](https://codeforces.com/contest/1315/problem/A)\n\n\n#### 題意:\n在一個網格上放一個壞點，問你如果不覆蓋壞點的矩形最大是多少\n<!-- more -->\n#### 思路:\n先找出最小面積後，把全部面積減去最小面積就可以得到答案了，而r與e要加一的原因是要去掉那一排有壞點的，而max((q*w)- tmp, 1)是因為在只有兩格的情況會變成沒面積所以兩格的話直接輸出1\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/652b04d1e317e2d9a9517f9078aee60f.js\"></script>","tags":["implementation","簡單"],"categories":["Codeforces"]},{"title":"CodeForces 1051D","url":"/Bicolorings/","content":"# CodeForces 1051D - Bicolorings\n[Bicolorings](https://codeforces.com/problemset/problem/1051/D)\n\n\n#### 題意:\n給你一個2xN的網格，每一個只能塗成黑色或白色，所有相鄰的同色都視為同一個元件。現在輸入N及K，問你2xN的網格有正好K個元件時有幾種可能的塗法？\n<!-- more -->\n#### 思路:\n建兩個陣列，紀錄現在最右邊的兩個不同色(A)以及同色(B)時，有x個元件時的塗法。因此當總列數n=1時A[1]=2，其他的A都等於0；B[2]=2，其他的B都等於0。新增一列時，A[i]=A[i]+A[i-1]+2*B[i]，B[i]=B[i]+B[i-2]+2*A[i-1]，增加到N列後A[K]+B[K]就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/33e0bd925d84247f7daa6d6d20291ebc.js\"></script>","tags":["dp","bitmasks"],"categories":["Codeforces"]},{"title":"CodeForces 913C","url":"/Party-Lemonade/","content":"# CodeForces 913C - Party Lemonade\n[Party Lemonade](https://codeforces.com/problemset/problem/913/C)\n\n\n#### 題意:\n輸入n，表示接下來會有n個瓶子，容量是2^(i-1)，價錢是ci。問現在至少需要總容量為L的瓶子，最少需要花多少錢？\n<!-- more -->\n#### 思路:\n每個尺寸最低的價錢就是上一個尺寸的兩倍價錢以及這個尺寸輸入的價錢中較低的那個，先記錄所有尺寸最便宜的價錢。超出最大尺寸的部分直接用最大尺寸的最低價購買，剩下的部分則嘗試所有可能。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/ad4326a9423e9f8e9d836c8b607616cd.js\"></script>","tags":["dp","greedy","bitmasks"],"categories":["Codeforces"]},{"title":"CodeForces 835C","url":"/Star-sky/","content":"# CodeForces 835C - Star sky\n[Star sky](https://codeforces.com/problemset/problem/835/C)\n\n\n#### 題意:\n天上有n個星星座標各自為(xi, yi)，初始亮度為si；還有全部星星共通的最大亮度c。在t時的亮度為x的星星，若x+1&lt;c，在t+1時的亮度為x+1，否則為0。現在你要觀察天空q次，分別在ti時觀察從(x1, y1)到(x2, y2)之間的星星，問這區間的總亮度是多少？\n<!-- more -->\n#### 思路:\n用積分圖(integral image)的方式記錄整個天空的初始亮度跟每個亮度的星星數量，之後快速得到輸入區間每個亮度的星星數量後計算指定時間的亮度後加總就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/8c1b2ffefb29bec87901d412f5db84e8.js\"></script>","tags":["dp","implementation"],"categories":["Codeforces"]},{"title":"CodeForces 1223A","url":"/CME/","content":"# CodeForces 1223A - CME\n[CME](https://codeforces.com/problemset/problem/1223/A)\n\n\n#### 題意:\n現在要用火柴棒拼出正確的A+B=C式子，3個數字都大於0。現在輸入火柴棒的數量，為你需要在買多少火柴棒才能滿足這個條件？\n<!-- more -->\n#### 思路:\n因為要拚出A+B=C的式子，所以需要的是A+B+C=2C根火柴棒，且C>=1，因此需要的是4根以上的偶數火柴棒，不到4就補到4；其他的偶數補0；奇數補1。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/4549203f9d56ce600024c12727f712de.js\"></script>\n\n","tags":["math"],"categories":["Codeforces"]},{"title":"CodeForces 1220A","url":"/Cards/","content":"# CodeForces 1220A - Cards\n[Cards](https://codeforces.com/problemset/problem/1220/A)\n\n\n#### 題意:\n給你一條字串裡面只有 'z', 'e', 'r', 'o' 和 'n'，請將字串裡的英文'zero'和'one'轉成數字1和0並以最大的二進制方式輸出，例如：nznooeeoer有兩個1和一個0，最大的數字為110\b\b\b\b。\n<!-- more -->\n#### 思路:\n先將所有1列印出來再印0，而0和1的英文不一樣的有z, r, n，所以我們可以用此來找出有幾個零與一。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/aacc51a67599af7e1e7f778bf921e76e.js\"></script>","tags":["sortings","implementation","strings","新手"],"categories":["Codeforces"]},{"title":"CodeForces 1186A","url":"/Vus-the-Cossack-and-a-Contest/","content":"# CodeForces 1186A - Vus the Cossack and a Contest\n[Vus the Cossack and a Contest](https://codeforces.com/problemset/problem/1186/A)\n\n\n#### 題意:\n有Ｎ個人Ｍ個筆和Ｋ個筆記本，而每個人一定要拿到一支筆和一本筆記本，如果可以輸出Yes，否則輸出No。\n<!-- more -->\n#### 思路:\n如果筆的數量大於等於人而且筆記本的數量大於等於人就可以知道每個人可不可以拿到一支筆和筆記本。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/de0a33ecc0c63019994a0fdbda7ee181.js\"></script>","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"UVA 12694","url":"/Meeting-Room-Arrangement/","content":"# UVA 12694 - Meeting Room Arrangement\n[Meeting Room Arrangement](https://onlinejudge.org/external/126/12694.pdf)\n\n\n#### 題意:\n幫他牌時程表，他希望裡面牌的會議越多越好。\n第一個輸入代表有幾筆，之後開始輸入會議的區間S和F，直到輸入為\"0 0\"就輸出。\n<!-- more -->\n#### 思路:\n將區間的F由小到大排序，接著檢查右邊會議結束時間有沒有小於等於下一個的開始時間，如果有就把左邊改為它的會議結束時間。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/76dc64ecd51fcede83e0d4edb89eb876.js\"></script>","tags":["greedy","簡單"],"categories":["UVA"]},{"title":"CodeForces 959A","url":"/Mahmoud-and-Ehab-and-the-even-odd-game/","content":"# CodeForces 959A - Mahmoud and Ehab and the even-odd game\n[Mahmoud and Ehab and the even-odd game](http://codeforces.com/problemset/problem/959/A)\n\n\n#### 題意:\n判斷奇數偶數，奇數輸出\"Mahmoud\"，偶數輸出\"Ehab\"。\n<!-- more -->\n#### 思路:\nn%2如果等於0就輸出\"Ehab\"Ehab，否則輸出\"Mahmoud\"。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/3fe88db3924d8e8709f2265be5ce0679.js\"></script>","tags":["math","新手","games"],"categories":["Codeforces"]},{"title":"CodeForces 935A v2","url":"/Fafa-and-his-Company-1/","content":"# CodeForces 935A - Fafa and his Company\n[Fafa and his Company](http://codeforces.com/problemset/problem/935/A)\n\n\n#### 題意:\n幫他分配隊長與員工。\n<!-- more -->\n#### 思路:\n將所有可能跑一遍，N/2是為了避免重複的，如果整除就加一。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/89bfbf21e4fe103a9426a9abd6fb26a9.js\"></script>","tags":["implementation","新手","brute force"],"categories":["Codeforces"]},{"title":"CodeForces 1097A","url":"/Gennady-and-a-Card-Game/","content":"# CodeForces 1097A - Gennady and a Card Game\n[Gennady and a Card Game](http://codeforces.com/problemset/problem/1097/A)\n\n\n#### 題意:\n給你一張牌，如果牌面上有相同花色或是相同數字你才能打牌，請你幫他檢查是否可以打牌。\n<!-- more -->\n#### 思路:\n每次輸入牌面上的牌的時候檢查自己的牌有沒有相同數字或花色，有的話就標記true。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/da4739702939cc464896f1d4edcea431.js\"></script>","tags":["implementation","新手","brute force"],"categories":["Codeforces"]},{"title":"CodeForces 706C","url":"/Hard-problem/","content":"# CodeForces 706C - Hard problem\n[Hard problem](http://codeforces.com/problemset/problem/706/C)\n\n\n#### 題意:\n輸入N(有多少字)、每個字顛倒的成本和每個字，問你不改變這串字的先後順序，藉由顛倒某些字來將這些字排成字典順序最少需要多少成本？\n<!-- more -->\n#### 思路:\n直接將所有字及所有顛倒後的字存起來，然後紀錄後面的字要滿足比前面的字大的最小成本，逐個更新就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/e14147a86c576dffff606a831ef76104.js\"></script>","tags":["dp","strings","一般"],"categories":["Codeforces"]},{"title":"CodeForces 607A","url":"/Chain-Reaction/","content":"# CodeForces 607A - Chain Reaction\n[Chain Reaction](http://codeforces.com/problemset/problem/607/A)\n\n\n#### 題意:\n在同一橫軸上有一些信標，功率b的信標a啟動後會將左邊距離b以內的信標都摧毀，現在給你N個信標的座標跟功率，並允許你在最右邊的信標右邊再增加一個信標，功率隨意，問從右邊開始逐個啟動所有未被摧毀的信標，最後最少會有幾個信標被摧毀？\n<!-- more -->\n#### 思路:\n創一個陣列des紀錄所有信標在[0].右邊信標全數被摧毀(除了額外增加的信標)且當前信標被摧毀的狀況下被毀的最少總信標數，和[1]右邊信標全數被摧毀(除了額外增加的信標)且當前信標被啟動的狀況下被毀的最少總信標數。des[i][0] = min(des[i-1][0],des[i][1])，因為當前信標已毀，所以不影響未摧毀的總數及左邊的狀態，直接對左邊的取最小值；des[i][1] = des[s][1] – 1，由於當前信標未毀，所以會啟動將左邊當前功率內的信標摧毀，然後啟動左邊的信標，因此用二分搜尋找未被摧毀的最右邊信標s，然後將其最少被摧毀的信標數減1(因為當前信標未毀)。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/615f27ffbce7ae56571b5d648e092ae4.js\"></script>","tags":["dp","binary search","一般"],"categories":["Codeforces"]},{"title":"CodeForces 996A","url":"/Hit-the-Lottery/","content":"# CodeForces 996A - Hit the Lottery\n[Hit the Lottery](http://codeforces.com/problemset/problem/996/A)\n\n\n#### 題意:\n給你N元利用他給你的幣值數1, 5, 10, 20, 100換出最少的硬幣數量，例如125元可以換1個100元，1個20元，1個5元，總共換了3個。\n<!-- more -->\n#### 思路:\n先將幣值定義好，接著由大的幣值開始換，換完後再將剩下的錢存起來。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/506667681b6d86205d3ef998c8f1ad80.js\"></script>","tags":["dp","greedy","新手"],"categories":["Codeforces"]},{"title":"CodeForces 1154A","url":"/Restoring-Three-Numbers/","content":"# CodeForces 1154A - Restoring Three Numbers\n[Restoring Three Numbers](http://codeforces.com/problemset/problem/1154/A)\n\n\n#### 題意:\n題目隨機將a+b, a+c, b+c 和 a+b+c亂擺，問你a、b、c分別是多少(答案輸出沒有一定的順序)。\n<!-- more -->\n#### 思路:\n將4個數字排序後將最大的數字減掉前面3個數字分別輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/f15ce3d3ac0784c691779d1f60a5a568.js\"></script>","tags":["math","新手"],"categories":["Codeforces"]},{"title":"CodeForces 1253C","url":"/Sweets-Eating/","content":"# CodeForces 1253C - Sweets Eating\n[Sweets Eating](http://codeforces.com/problemset/problem/1253/C)\n\n\n#### 題意:\n輸入N(有多少個甜點)、M(一天可以吃幾個)和N個甜點的含糖數，在第D天吃下含糖A的甜點時會得到加權含糖數A x D，求吃K(K=1~N)個時的最少加權含糖數是多少？\n<!-- more -->\n#### 思路:\n先由題目需求得知，在吃X個的情況下一定是挑含糖數最少的X個出來，並且由高的開始吃，得出的就是K=X時的最少含糖數，因此先排序得到陣列A。計算累加陣列S，S[i]等於A[0]~A[i]的總和。現在要求陣列K，記錄所有答案，觀察後得知，K[i] = K[i – M] + S[i]，如下一頁所示，將陣列輸出就是答案。\n![A](A.PNG)\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/0a2cb1dad996580b67cf36a5a37bc11c.js\"></script>","tags":["dp","sortings","greedy","math","一般"],"categories":["Codeforces"]},{"title":"CodeForces 1207C","url":"/Gas-Pipeline/","content":"# CodeForces 1207C - Gas Pipeline\n[Gas Pipeline](http://codeforces.com/problemset/problem/1207/C)\n\n\n#### 題意:\n用0/1表示一條街道的一個區段不是/是路口，在路口時管線必須立在離地兩單位高的柱上供路口通行，非路口時則沒有限制。現在輸入N、A、B，表示道路的區段數量、一單位長的管線的成本、一單位高的柱子成本，保證頭尾的區段都是非路口，問在道路頭尾的柱子都是1單位高時花費的最低成本是多少？\n<!-- more -->\n#### 思路:\n用柱子來看，前一根柱子到這一根柱子的成本有四種，高度1到1、高度1到2、高度2到1、高度2到2四種，因此知道前一根柱子的高度1和2的最低成本，就可以算出這根柱子高度1和2時的最低成本。加上第一根根最後一根柱子高度限制為1的條件後，從第一根柱子開始推算就可以得出最後的最低成本。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/f150287a1b3ee14609c68fcfe3aa0131.js\"></script>","tags":["dp","greedy","一般"],"categories":["Codeforces"]},{"title":"UVA 900","url":"/Brick-Wall-Patterns/","content":"# UVA 900 - Brick Wall Patterns\n[Brick Wall Patterns](https://onlinejudge.org/external/9/900.pdf)\n\n\n#### 題意:\n給你N個磚頭，問你有幾種排列方式。\n<!-- more -->\n#### 思路:\n仔細觀察數列時會發現有規律，1的時候1、2的時候2、3的時候3、4的時候5....，第三項會是前兩項的和，因此我們可以先建一個表將所有答案算出來，之後利用查表來輸出答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/d3dd936f31d55be2205f5f8be4576bff.js\"></script>","tags":["dp","新手"],"categories":["Codeforces"]},{"title":"CodeForces 977A v2","url":"/Wrong-Subtraction-1/","content":"# CodeForces 977A v2 - Wrong Subtraction\n[Wrong Subtraction](http://codeforces.com/problemset/problem/977/A)\n\n\n#### 題意:\n他給你一個N然後可以有K次操作。\n操作條件:\n● if the last digit of the number is non-zero, she decreases the number by one.(如果他不為0則減一)\n\n● if the last digit of the number is zero, she divides the number by 10 (i.e. removes the last digit).(如果他為0就除以10)\n<!-- more -->\n#### 思路:\n每次將N模10看看於數是不是0如果不是就減1，其餘除10。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/be92977c98e9f69528282fcd181111e3.js\"></script>","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"CodeForces 791A","url":"/Bear-and-Big-Brother/","content":"# CodeForces 791A - Bear and Big Brother\n[Bear and Big Brother](http://codeforces.com/problemset/problem/791/A)\n\n\n#### 題意:\n一開始給你小熊和牠哥哥的體型，牠每一年增加三倍，而牠哥哥增加兩倍。題目問你說至少要幾年小熊才能超過哥哥的體重。\n<!-- more -->\n#### 思路:\n每過一年看小熊有沒有超過哥哥，如果有就輸出經過了幾年。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/89snnfk561/50b0886876cbe645a45e48babe260d6a.js\"></script>\n","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"CodeForces 1253A","url":"/Single-Push/","content":"# CodeForces 1253A - Single Push\n[Single Push](http://codeforces.com/problemset/problem/1253/A)\n\n\n#### 題意:\n給你兩條字串問你兩條字串是否相等，而你可以將連續的區間加上一個N使的兩個字串相等，例如a=[3,7,1,4,1,2], b=[3,7,3,6,3,2]， 所以你可以把a[2]~a[4]加上2兩條數列就會一樣，可以相等輸出YES否則NO(如果a陣列有數字大於b也是輸出NO)。\n<!-- more -->\n#### 思路:\n將兩數列相減後的結果存在一個陣列內，接著比對前後相不相等，不相等的話ok++，如果ok大於等於2的話代表有超過2次不一樣，所以一定不可能將一個區間加上一個數就可以相等。如果是負的話直接加10讓他超過2。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/a66ce2a9835ca967ca1fa19211c5fd2b.js\"></script>","tags":["implementation","簡單"],"categories":["Codeforces"]},{"title":"CodeForces 788A","url":"/Functions-again/","content":"# CodeForces 788A  - Functions again\n[Functions again](http://codeforces.com/problemset/problem/788/A)\n\n\n#### 題意:\n輸入N及N個數字，求依照公式時最大的區段和是多少？\n<!-- more -->\n#### 思路:\n觀察公式後，得知在區段中每一項差的絕對值會由+-+-+-…的規律加起來，因此除了第一個，要取的話就一次取兩個，不然只取-的會變小。先將所有的差的絕對值存起來，接著對偶數起點和奇數起點都做一次跨度為2的子區段最大和，最後得到的最大值就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/5ea9f2ecdcafdc4a7fdb8dc98a590879.js\"></script>","tags":["dp","普通","two pointers"],"categories":["Codeforces"]},{"title":"CodeForces 414B","url":"/Mashmokh-and-ACM/","content":"# CodeForces 414B - Mashmokh and ACM\n[Mashmokh and ACM](http://codeforces.com/problemset/problem/414/B)\n\n\n#### 題意:\n輸入N、K，指定數列長度K，其中所有元素都在1~N之間，且每一個元素都可以整除下一個元素，問有幾種數列滿足條件？\n<!-- more -->\n#### 思路:\n當數列長度為x，結尾為y時，要增長數列的方法就是在數列尾端增加一個是y的倍數的元素，因此這個數列可以衍伸出y、2y、3y…ty，ty <= N，共t個數列。以這個想法下去建置一個陣列，紀錄當前長度結尾為x(x=1~N)的數列有幾個，逐次增加長度，跑完後就是答案。\n![A](A.PNG)\n![B](B.PNG)\n![C](C.PNG)\n![D](D.PNG)\n![E](E.PNG)\n![F](F.PNG)\n![G](G.PNG)\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/4c631d92b0f0aec4e4e887ca67ded26a.js\"></script>","tags":["dp","普通","number theory","combinatorics"],"categories":["Codeforces"]},{"title":"CodeForces 1030A","url":"/In-Search-of-an-Easy-Problem/","content":"# CodeForces 1030A - In Search of an Easy Problem\n[In Search of an Easy Problem](http://codeforces.com/problemset/problem/1030/A)\n\n#### 題意:\n數列如果出現1就輸出HARD，沒有則輸出EASY。\n<!-- more -->\n#### 思路:\n每次輸入都判斷。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/458756d5630a34eee9f99914c973f7c5.js\"></script>","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"AOJ ITP1_11_A","url":"/Dice-I/","content":"# AOJ ITP1_11_A - Dice I\n[Dice I](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP1_11_A)\n\n\n#### 題意:\n給你一顆骰子，然後翻轉骰子後，問你朝上的那面數字為多少。\n<!-- more -->\n#### 思路:\n先建一個東南西北轉完結果的\"位子表\"，將骰子骰完後的結果存到新的骰子，再將原本色子覆蓋掉重複地做。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/fdd20a2347cfacc7bcc6f8fa78818726.js\"></script>","tags":["implementation","簡單"],"categories":["AOJ"]},{"title":"CodeForces 1176C","url":"/Lose-it/","content":"# CodeForces 1176C - Lose it\n[Lose it](http://codeforces.com/problemset/problem/1176/C)\n\n\n#### 題意:\n找出集合中有幾個序列為[4,8,15,16,23,42]的序列\n<!-- more -->\n#### 思路:\n依照題意，可以得到說順序不能變，故由前向後搜，開始統計每個數字的個數，當碰到前面數字個數>後面字數個數時表示可以形成序列，最後統計有多少個序列後計算n-6*序列數。\n\n例如:\n[4,8,4,15,16,8,23,15,16,42,23,42]\n\n第一個為4，並且4為序列的第一個，故 sequence_count[0]++;\n第二個為8，為序列中第二個，判斷序列中第一個是否有個數，有則 sequence_count[1]++;sequence_count[0]--;將前面的抵銷。\n以此類推\nsequence_count[0]++\nsequence_count[2]++;sequence_count[1]--;\n.\n.\n.\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/d83328cdf1580e2bed0b468b045ac0bd.js\"></script>","tags":["dp","implementation","greedy","簡單"],"categories":["Codeforces"]},{"title":"CodeForces 1256A","url":"/Payment-Without-Change/","content":"# CodeForces 1256A - Payment Without Change\n[Payment Without Change](http://codeforces.com/problemset/problem/1256/A)\n\n\n#### 題意:\n給你4個輸入a, n, b, s，他有a個硬幣幣值為n，b個硬幣幣值為1，題目問你可不可以湊出S這個數字。\n<!-- more -->\n#### 思路:\n先算出S/N看看有A沒有超過最大的換硬幣數量，如果有就把他的最大直設為A，接著再檢查減掉後的數有沒有超過B，沒有超過就代表可以換出來S。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/4bda315b7e12083def4362b3d4eb7b03.js\"></script>","tags":["math","新手"],"categories":["Codeforces"]},{"title":"CodeForces 1250F","url":"/Data-Center/","content":"# CodeForces 1250F - Data Center\n[Data Center](http://codeforces.com/problemset/problem/1250/F)\n\n\n#### 題意:\n給你一個面積找出最小的周長。\n<!-- more -->\n#### 思路:\n將所又可能跑過一遍，每次比較找出最小的周長。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/38b3b785990804ed7b59cea69e1bafc8.js\"></script>","tags":["implementation","新手","brute force"],"categories":["Codeforces"]},{"title":"CodeForces 933A","url":"/A-Twisty-Movement/","content":"# CodeForces 933A - A Twisty Movement\n[A Twisty Movement](https://codeforces.com/problemset/problem/933/A)\n\n#### 題意:\n輸入一串由1和2組成的數列，可以左右翻轉任意的範圍一次，問最長的非遞減子序列是多長？\n<!-- more -->\n#### 思路:\n觀察後得知，題目是在求將數列分成4段之後(每一段的長度可以是0)，第1段1的數量+第2段2的數量+第3段1的數量+第4段2的數量的最大值是多少。因此創個陣列邊輸入邊維持最大值，[1]紀錄只有第1段時的最大值、[2]紀錄只有第1段及第2段時的最大值、[3]跟[4]同理，因次跑完後輸出[4]就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/89snnfk561/7ed0e505140cd7796ab9db94fe515dec.js\"></script>\n\n\n","tags":["dp"],"categories":["Codeforces"]},{"title":"UVA 13178","url":"/Is-it-multiple-of-3/","content":"# UVA 13178 - Is it multiple of 3\n[Is it multiple of 3](https://onlinejudge.org/external/131/13178.pdf)\n\n#### 題意:\n連續的1234567891011這樣的字串幫他檢查是否是3的倍數。\n<!-- more -->\n#### 思路:\n根據規則(k-1) % 3 == 0輸出NO。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/9df8f124a87eff28e2500d52dd3a1a01.js\"></script>","tags":["math"],"categories":["UVA"]},{"title":"UVA 11219","url":"/How-old-are-you/","content":"# UVA 11219 - How old are you\n[How old are you](https://onlinejudge.org/external/112/11219.pdf)\n\n\n#### 題意:\n檢查歲數有沒有問題。\n• ‘Invalid birth date’, if the calculated age is impossible (still going to be born).\n• ‘Check birth date’, if the calculated age is more than 130.\n• the calculated age (years old only), otherwise.\n• If the two dates are the same, the output should be ‘0’.\n<!-- more -->\n#### 思路:\n檢查年月日按照上面規則逐一做出來。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/32722835e89a939908d24db15261995a.js\"></script>\n","tags":["implementation"],"categories":["UVA"]},{"title":"UVA 10929","url":"/You-can-say-11/","content":"# UVA 10929 - You can say 11\n[You can say 11](https://onlinejudge.org/external/109/10929.pdf)\n\n\n#### 題意:\n檢查這數字是否是11的倍數。\n<!-- more -->\n#### 思路:\n奇數項加起來A，偶數項加起來B，檢查abs(A - B) % 11 == 0。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/0f1f31a49fd5a25ee5e9988f57ee4910.js\"></script>","tags":["implementation","math"],"categories":["UVA"]},{"title":"UVA 10107","url":"/One-Two-Three/","content":"# UVA 10107 - One-Two-Three\n[One-Two-Three](https://onlinejudge.org/external/101/10107.pdf)\n\n\n#### 題意:\n找中位數。\n<!-- more -->\n#### 思路:\n每次都排序然後計算，如果是偶數就(ary[k/2-1] + ary[k/2]) / 2，奇數就直接印ary[k/2]。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/e746a371f7628ac2bec3bda186854e9c.js\"></script>","tags":["implementation"],"categories":["UVA"]},{"title":"UVA 11764","url":"/Jumping-Mario/","content":"# UVA 11764 - Jumping Mario\n[Jumping Mario](https://onlinejudge.org/external/117/11764.pdf)\n\n\n#### 題意:\n幫他檢查馬力歐往上跳幾格，往下跳幾格。\n<!-- more -->\n#### 思路:\n一個一個檢查左邊大於右邊h++，小於l++，等於continue。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/829c3118699f58d68f304196da026974.js\"></script>","tags":["implementation"],"categories":["UVA"]},{"title":"UVA 11942","url":"/Lumberjack-Sequencing/","content":"# UVA 11942 - Lumberjack Sequencing\n[Lumberjack Sequencing](https://onlinejudge.org/external/119/11942.pdf)\n\n\n#### 題意:\n幫他檢查數列是否由大到小或小到大排。\n<!-- more -->\n#### 思路:\n由左檢查道右看看左邊有沒有大於右邊，然後再檢查回來。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/512bf476494b003db28eb225e0ffd375.js\"></script>","tags":["implementation"],"categories":["UVA"]},{"title":"AOJ ITP1_8_D","url":"/Ring/","content":"# AOJ ITP1_8_D - Ring\n[Ring](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP1_8_D)\n\n\n#### 題意:\n幫他找出A字串在不再B字串裡面，需要連續的。\n<!-- more -->\n#### 思路:\n先複製一個字串在源自串後面模仿一個環的樣子，然後逐一檢查一樣的話計數器加一，檢查完後檢查計數器的長度是否跟原自串一樣長，一樣就不檢查然後印答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/fa4b745d816d676bac397dcd0d05b2bd.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"UVA 10340","url":"/All-in-All/","content":"# UVA 10340 - All in All\n[All in All](https://onlinejudge.org/external/103/10340.pdf)\n\n#### 題意:\n幫他找出A字串在不再B字串裡面，沒有連續沒關西。\n<!-- more -->\n#### 思路:\n逐一檢查有沒有匹配到相同的字，如果有就換下一個字直到然後次數加一，最後檢查相同的次數等不等於原本的長度，就可以知道答案了。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/8f601b9d5c30cf3a6bd30a1c93650b31.js\"></script>","tags":["implementation"],"categories":["UVA"]},{"title":"UVA 10082","url":"/WERTYU/","content":"# UVA 10082 - WERTYU\n[WERTYU](https://onlinejudge.org/external/100/10082.pdf)\n\n\n#### 題意:\n他請你幫他解密，規則是他敲的鍵盤左邊那個才是原本的答案，例如他敲O你要輸出I這樣。\n<!-- more -->\n#### 思路:\n我們可以先建一個鍵盤的表，然後逐一搜尋，找到一樣的我就取他左邊那個，空白的話就直接印。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/13b38d45451133452556dd4e7fd5cdaa.js\"></script>","tags":["implementation"],"categories":["UVA"]},{"title":"UVA 11636","url":"/Hello-World/","content":"# UVA 11636 - Hello World\n[Hello World](https://onlinejudge.org/external/116/11636.pdf)\n\n\n#### 題意:\n有個人他很懶，他懶得打這麼多個Hello World所以他只用複製的，假如他要印7個Hello World!，他要複製3次，因為第一次他複製他打好的一個Hello World，變2個，然後再複製便4個，然後再複製3個變7個。\n<!-- more -->\n#### 思路:\n我們可以先建出一個答案表提供我們查詢以免超時，i是他需要印的數量，而每次複製我都檢查複製出來的最大值有沒有小於等於複製出來的數量，像是上面範例5、6、7、8都只需要複製3次，因為複製到三次的時候最大值複製數是8個，以此類推往下建表把所有答案都列出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/c9a27cb1bb5ca17fe0914ef6dcc0cfd4.js\"></script>","tags":["implementation"],"categories":["UVA"]},{"title":"AOJ ITP1_5_B","url":"/Print-a-Frame/","content":"# AOJ ITP1_5_B - Print a Frame\n[Print a Frame](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP1_5_B)\n\n#### 題意:\n幫他印出一個N*M的農場\n<!-- more -->\n#### 思路:\n把他切成三塊來印，先印一排#，在印中間部分，最後在印出#，一步一步時做出來。\n#### 程式碼:\n\n<script src=\"https://gist.github.com/Daviswww/5e547e5c108bdb7fa47d5036c02f5f2d.js\"></script>","tags":["implementation"],"categories":["AOJ"]},{"title":"UVA 10055","url":"/Hashmat-the-Brave-Warrior/","content":"# UVA 10055 - Hashmat the Brave Warrior\n[Hashmat the Brave Warrior](https://onlinejudge.org/external/100/10055.pdf)\n\n#### 題意:\n幫忙計算兵力差距\n<!-- more -->\n#### 思路:\n相減加絕對值，記得要long long不然會爆掉。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/c247b18829e24fb33734da0e4fab51b8.js\"></script>","tags":["implementation"],"categories":["Codeforces"]},{"title":"Codeforces 631C","url":"/Report/","content":"# Codeforces 631C - Report\n[Report](https://codeforces.com/problemset/problem/631/C)\n\nEach month Blake gets the report containing main economic indicators of the company \"Blake Technologies\".\n<!-- more -->\n\nThere are n commodities produced by the company. For each of them there is exactly one integer in the final report, that denotes corresponding revenue.\n\nBefore the report gets to Blake, it passes through the hands of m managers. Each of them may reorder the elements in some order. Namely, the i-th manager either sorts first r<sub>i</sub> numbers in non-descending or non-ascending order and then passes the report to the manager i + 1, or directly to Blake (if this manager has number i = m).\n\nEmployees of the \"Blake Technologies\" are preparing the report right now. You know the initial sequence a<sub>i</sub> of length n and the description of each manager, that is value r<sub>i</sub> and his favourite order. You are asked to speed up the process and determine how the final report will look like.\n\n#### Input:\nThe first line of the input contains two integers n and m (1 ≤ n, m ≤ 200,000) — the number of commodities in the report and the number of managers, respectively.\n\nThe second line contains n integers a<sub>i</sub> (|a<sub>i</sub>| ≤ 10<sup>9</sup>) — the initial report before it gets to the first manager.\n\nThen follow m lines with the descriptions of the operations managers are going to perform. The i-th of these lines contains two integers ti and r<sub>i</sub> (t<sub>i</sub> ∈ {1, 2}, 1 ≤ r<sub>i</sub> ≤ n), meaning that the i-th manager sorts the first r<sub>i</sub> numbers either in the non-descending (if t<sub>i</sub> = 1) or non-ascending (if t<sub>i</sub> = 2) order.\n\n#### Output:\nPrint n integers — the final report, which will be passed to Blake by manager number m.\n\n#### 範例:\ninput:\n```\n3 1\n1 2 3\n2 2\n```\noutput:\n```\n2 1 3 \n```\ninput:\n```\n4 2\n1 2 4 3\n2 3\n1 2\n```\noutput:\n```\n2 4 1 3 \n```\n\n#### Note:\nIn the first sample, the initial report looked like: 1 2 3. After the first manager the first two numbers were transposed: 2 1 3. The report got to Blake in this form.\n\nIn the second sample the original report was like this: 1 2 4 3. After the first manager the report changed to: 4 2 1 3. After the second manager the report changed to: 2 4 1 3. This report was handed over to Blake.\n\n#### 題意:\n它會給你一組數列有n個數，而你要依據它的t做判斷是否為升序或降序，再從頭到r做排列，共有m組t和r。\n\n#### 思路:\n找出最大的r做排序，從剩下沒被排序的數先儲存起來，再從剩下的t和r組，找尋最大的r，然後看上一個最大的r和t為升序或者是降序決定儲存方向t[i-1]和長度r[i-1]-r[i]。\n\n*建議直接把程式碼複製執行被註解掉的cout會比較清楚。\n\nex:\n4 2\n1 2 4 3\n2 3\n1 2\n\n4   2   1 |3  :數列\n-> <- <-    :方向t[i-1],和長度r[i-1] - r[i]\n2   3   1     :儲存順序\n\n#### 程式碼:\n<script src=\"https://gist.github.com/89snnfk561/fc83ef23d16f8afc81b2d1fb8c5bb658.js\"></script>\n\n\n","tags":["sortings","data structures"],"categories":["Codeforces"]},{"title":"Codeforces 520B","url":"/Two-Buttons/","content":"# Codeforces 520B - Two Buttons\n[Two Buttons](https://codeforces.com/problemset/problem/520/B)\n\nVasya has found a strange device. On the front panel of a device there are: a red button, a blue button and a display showing some positive integer. \n<!-- more -->\n\nAfter clicking the red button, device multiplies the displayed number by two. After clicking the blue button, device subtracts one from the number on the display. \n\nIf at some point the number stops being positive, the device breaks down. The display can show arbitrarily large numbers. Initially, the display shows number n.\n\n#### Input:\nThe first and the only line of the input contains two distinct integers n and m (1 ≤ n, m ≤ 10<sup>4</sup>), separated by a space .\n\n#### Output:\nPrint a single number — the minimum number of times one needs to push the button required to get the number m out of number n.\n\n#### 範例:\ninput:\n```\n4 6\n```\noutput:\n```\n2\n```\ninput:\n```\n10 1\n```\noutput:\n```\n9\n```\n\n#### Note:\nIn the first example you need to push the blue button once, and then push the red button once.\n\nIn the second example, doubling the number is unnecessary, so we need to push the blue button nine times.\n\n#### 題意:\n它給你兩個按鈕和一個數值n，一個做數值*2的動作，另一個則做數值-1的動作，試問最少需要案幾次按鈕才能到達目標值n。\n\n#### 思路:\n2(2((2n)+1)) = m  -->  n = (((m/2)-1)/2)/2\n使用類似反矩陣的概念，去讓m接近n，因為在n做運算時必定為整數則反之亦然，所以m做運算時絕對不能出現小數點，意思是m做除以2的運算時必須為偶數。\n\n#### 程式碼:\n\n<script src=\"https://gist.github.com/89snnfk561/775e4e0b3a627e88d921dea99c9d424a.js\"></script>\n\n","tags":["implementation","dfs and similar","greedy","math","graphs","shortest paths"],"categories":["Codeforces"]},{"title":"Codeforces 200B","url":"/Duff-in-Love/","content":"# Codeforces 588B - Duff in Love\n[Duff in Love](https://codeforces.com/contest/588/problem/B)\n\nDuff is in love with lovely numbers! A positive integer x is called lovely if and only if there is no such positive integer a > 1 such that a2 is a divisor of x.\n<!-- more -->\n\nMalek has a number store! In his store, he has only divisors of positive integer n (and he has all of them). As a birthday present, Malek wants to give her a lovely number from his store. He wants this number to be as big as possible.\n\nMalek always had issues in math, so he asked for your help. Please tell him what is the biggest lovely number in his store.\n\n#### Input:\nThe first and only line of input contains one integer, n (1 ≤ n ≤ 10<sup>12</sup>).\n\n#### Output:\nPrint the answer in one line.\n\n#### 範例:\ninput:\n```\n10\n```\noutput:\n```\n10\n```\ninput:\n```\n12\n```\noutput:\n```\n6\n```\n\n\n#### Note:\nIn first sample case, there are numbers 1, 2, 5 and 10 in the shop. 10 isn't divisible by any perfect square, so 10 is lovely.\n\nIn second sample case, there are numbers 1, 2, 3, 4, 6 and 12 in the shop. 12 is divisible by 4 = 2<sup>2</sup>, so 12 is not lovely, while 6 is indeed lovely.\n\n#### 題意:\n輸入它給你一個數字n，它因數分解的集合的因數分解不希望有任何可以被開根號的因數。如果有，希望你能把他丟棄，然後再組成新的數。\n\n#### 思路:\nn做出質因數分解，把重複出現的數去除，再把集合裡的數相乘，這樣就不會有可以被開根號的因數了。\n\n#### 程式碼:\n\n<script src=\"https://gist.github.com/89snnfk561/fc37c058fd2adfcffbd5b71e68747a2e.js\"></script>\n\n\n","tags":["math"],"categories":["Codeforces"]},{"title":"Codeforces 287B","url":"/Pipeline/","content":"# Codeforces 287B - Pipeline\n[Pipeline](https://codeforces.com/problemset/problem/287/B)\n\nVova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. \n<!-- more -->\nA pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.\n\nA splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.\n\n![A](A.PNG)\n\nVova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.\n\nVova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.\n\n#### Input:\nThe first line contains two space-separated integers n and k (1 ≤ n ≤ 10<sup>18</sup>, 2 ≤ k ≤ 10<sup>9</sup>).\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n#### Output:\nPrint a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.\n#### 範例:\ninput:\n```\n4 3\n```\noutput:\n```\n2\n```\ninput:\n```\n5 5\n```\noutput:\n```\n1\n```\ninput:\n```\n8 4\n```\noutput:\n```\n-1\n```\n\n#### 題意:\nVova希望在一個叫the Ultimate Thule new shaman的城市建立一條管道，城市中有n座房子，因此Vova希望剛好有n條管道，因此每條這樣的管道都應連接到供水系統。如果有水流出，則可以將管道連接到供水系統。最初，Vova只有一根流水的管道。此外，Vova有幾個分離器。\n\nVova有每種分配器：具有2、3、4，...，k個輸出。幫助Vova使用最少數量的拆分器來構建所需的管道，或者以其他方式聲明這是不可能的。\n\nVova需要管道中有正好n根流出水的管道。其中一些管道可以是分配器的輸出管道。\n\n#### 思路:\n因為分離器是2,3,4,...,k個輸出，則在正常情況下只要不超過所有分離器組合起來的輸出總數就一定能滿足條件，尋找n到k的分離器組合的輸出總數，如超過目標值或等於目標值，則答案為(k-n+1)個。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/89snnfk561/e95472b21f34e1b7ca5440a4a11da55a.js\"></script>\n\n","tags":["math","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 217A","url":"/Ice-Skating/","content":"# Codeforces 217A - Ice Skating\n[Ice Skating](https://codeforces.com/contest/217/problem/A)\n\nBajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.\n<!-- more -->\nWe assume that Bajtek can only heap up snow drifts at integer coordinates.\n\n\n#### Input:\nThe first line of input contains a single integer n (1 ≤ n ≤ 100) — the number of snow drifts. Each of the following n lines contains two integers x<sub>i</sub> and y<sub>i</sub> (1 ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 1000) — the coordinates of the i-th snow drift.\n\nNote that the north direction coinсides with the direction of Oy axis, so the east direction coinсides with the direction of the Ox axis. All snow drift's locations are distinct.\n\n#### Output:\nOutput the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.\n\n#### 範例:\ninput:\n```\n2\n2 1\n1 2\n```\noutput:\n```\n1\n```\ninput:\n```\n2\n2 1\n4 1\n```\noutput:\n```\n0\n```\n\n\n#### 題意:\nBajtek是一個滑雪的初心者，而它只能滑行四個方向(東南西北)，在滑行的途中它無法停下，除非撞到雪堆它才能停下改變行滑行的方向(或不改變)，而他需要堆積額外的雪堆來確保每個雪堆他都能前往。他問最少需要多少額外的雪堆。\n\n#### 思路:\n在輸入時會給你雪堆數和它在平面的座標，而現有的雪堆能組成多個區塊(單一或複數個雪堆，無法前往其他雪堆或能相互前往)，我們需要找出共有幾個區塊並計數，假設共為n個區塊，則最少需要(n-1)個雪堆來組成統一的大區塊，而(n-1)就是我們要的答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/89snnfk561/ec5c3671547a0f0dff77dbacaafbe7ec.js\"></script>\n\n","tags":["dfs and similar","brute force","graphs","dus"],"categories":["Codeforces"]},{"title":"Codeforces 92B","url":"/Binary-Number/","content":"# Codeforces 92B - Binary Number\n[Binary Number](https://codeforces.com/problemset/problem/92/B)\n\nLittle walrus Fangy loves math very much. That's why when he is bored he plays with a number performing some operations.\n<!-- more -->\nFangy takes some positive integer x and wants to get a number one from it. While x is not equal to 1, Fangy repeats the following action: if x is odd, then he adds 1 to it, otherwise he divides x by 2. Fangy knows that for any positive integer number the process ends in finite time.\n\nHow many actions should Fangy perform to get a number one from number x?\n\n\n#### Input:\nThe first line contains a positive integer x in a binary system. It is guaranteed that the first digit of x is different from a zero and the number of its digits does not exceed 106.\n#### Output:\nPrint the required number of actions.\n#### 範例:\ninput:\n```\n1\n```\noutput:\n```\n0\n```\ninput:\n```\n1001001\n```\noutput:\n```\n12\n```\ninput:\n```\n101110\n```\noutput:\n```\n8\n```\n\n#### Note:\nLet's consider the third sample. Number 101110 is even, which means that we should divide it by 2. After the dividing Fangy gets an odd number 10111 and adds one to it. Number 11000 can be divided by 2 three times in a row and get number 11. All that's left is to increase the number by one (we get 100), and then divide it by 2 two times in a row. As a result, we get 1.\n\n#### 題意:\n他給你一個二進制碼，而當他為偶數時除以2，反之加1，直到數字為1為止，計算他總共做了幾次更動。\n\n#### 思路:\n用字串儲存數字，判斷最後的位數如果是1，進位往前直到0，經過的位數做更改，如果進位超出範圍在前面加上1，如果是0消除它，以上做一次判斷計數加1。直到整個字串為1\n\n進階:\n一樣用字串儲存做一次迴圈確認為1的字元大於等於2個，成立在右到左第1個1字元之後的0，確認有幾個加上1再加上整個字串的長度就是答案了。\n不成立則是屬出0的個數就是答案了。\n#### 程式碼:\n<script src=\"https://gist.github.com/89snnfk561/fcb178773a50568b10ba9fe62829f502.js\"></script>\n","tags":["greedy"],"categories":["Codeforces"]},{"title":"UVA 100","url":"/The-3n-1-problem/","content":"# UVA 100 - The 3n + 1 problem\n[The 3n + 1 problem](https://onlinejudge.org/external/1/100.pdf)\n\nProblems in Computer Science are often classified as belonging to a certain class of problems (e.g.,NP, Unsolvable, Recursive). In this problem you will be analyzing a property of an algorithm whose classification is not known for all possible inputs.\n<!-- more -->\nConsider the following algorithm:\n1. input n\n2. print n\n3. if n = 1 then STOP\n4. if n is odd then n ←− 3n + 1\n5. else n ←− n/2\n6. GOTO 2\n\nGiven the input 22, the following sequence of numbers will be printed\n22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1\n\nIt is conjectured that the algorithm above will terminate (when a 1 is printed) for any integral input value. Despite the simplicity of the algorithm, it is unknown whether this conjecture is true. It has been verified, however, for all integers n such that 0 < n < 1, 000, 000 (and, in fact, for many morenumbers than this.)\n\nGiven an input n, it is possible to determine the number of numbers printed before and including the 1 is printed. For a given n this is called the cycle-length of n. In the example above, the cycle length of 22 is 16.\n\nFor any two numbers i and j you are to determine the maximum cycle length over all numbers between and including both i and j.\n\n#### Input:\nThe input will consist of a series of pairs of integers i and j, one pair of integers per line. All integers will be less than 10,000 and greater than 0.\n\nYou should process all pairs of integers and for each pair determine the maximum cycle length over all integers between and including i and j.\n\nYou can assume that no operation overflows a 32-bit integer.\n\n#### Output:\nFor each pair of input integers i and j you should output i, j, and the maximum cycle length for integers between and including i and j. \n\nThese three numbers should be separated by at least one space with all three numbers on one line and with one line of output for each line of input. \n\nThe integers i and j must appear in the output in the same order in which they appeared in the input and should be followed by the maximum cycle length (on the same line).\n\n#### 範例:\ninput:\n```\n1 10\n100 200\n201 210\n900 1000\n```\noutput:\n```\n1 10 20\n100 200 125\n201 210 89\n900 1000 174\n```\n\n#### 題意:\n就在i到j之間經過上面的演算法做一串數列計算它的長度取其中的最大值。\n#### 思路:\n把循環的演算法先寫出來回傳它的長度，在i到j的數計算每個數進入演算法重複的次數，取最大的一個，把i，j和最大的數印出。\n#### 程式碼:\n<script src=\"https://gist.github.com/89snnfk561/63c386f78060c514d21dd5db59bfc802.js\"></script>\n\n","tags":["implementation"],"categories":["UVA"]},{"title":"Codeforces 221B","url":"/Little-Elephant-and-Numbers/","content":"# Codeforces 221B - Little Elephant and Numbers\n[Little Elephant and Numbers](https://codeforces.com/problemset/problem/221/B)\n\nThe Little Elephant loves numbers.\n<!-- more -->\nHe has a positive integer x. The Little Elephant wants to find the number of positive integers d, such that d is the divisor of x, and x and d have at least one common (the same) digit in their decimal representations.\n\nHelp the Little Elephant to find the described number.\n<!-- more -->\n#### Input:\nA single line contains a single integer x (1 ≤ x ≤ 10<sup>9</sup>).\n#### Output:\nIn a single line print an integer — the answer to the problem.\n#### 範例:\ninput:\n```\n1\n```\noutput:\n```\n1\n```\ninput:\n```\n10\n```\noutput:\n```\n2\n```\n\n#### 題意:\n輸入N，問你所有N的因數中，有幾個因數有使用到N本身使用過的數字。\n\n#### 思路:\n找因數只需要找到平方根就好。另一邊的因數可以用除的得知。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/572bf3a7c7b6f81a7a57a5831208c312.js\"></script>\n\n","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"Codeforces 269A","url":"/Magical-Boxes/","content":"# Codeforces 269A - Magical Boxes\n[Magical Boxes](https://codeforces.com/problemset/problem/269/A)\n\nEmuskald is a well-known illusionist. One of his trademark tricks involves a set of magical boxes. The essence of the trick is in packing the boxes inside other boxes.\n<!-- more -->\nFrom the top view each magical box looks like a square with side length equal to 2<sup>k</sup> (k is an integer, k ≥ 0) units. A magical box v can be put inside a magical box u, if side length of v is strictly less than the side length of u. In particular, Emuskald can put 4 boxes of side length 2<sup>k - 1</sup> into one box of side length 2<sup>k</sup>, or as in the following figure:\n\n![A](A.PNG)\nEmuskald is about to go on tour performing around the world, and needs to pack his magical boxes for the trip. He has decided that the best way to pack them would be inside another magical box, but magical boxes are quite expensive to make. Help him find the smallest magical box that can fit all his boxes.\n#### Input:\nThe first line of input contains an integer n (1 ≤ n ≤ 10<sup>5</sup>), the number of different sizes of boxes Emuskald has. Each of following n lines contains two integers k<sub>i</sub> and a<sub>i</sub> (0 ≤ k<sub>i</sub> ≤ 10<sup>9</sup>, 1 ≤ a<sub>i</sub> ≤ 10<sup>9</sup>), which means that Emuskald has ai boxes with side length 2<sup>k<sub>i</sub></sup>. It is guaranteed that all of ki are distinct.\n#### Output:\nOutput a single integer p, such that the smallest magical box that can contain all of Emuskald’s boxes has side length 2<sup>p</sup>.\n#### 範例:\ninput:\n```\n2\n0 3\n1 5\n```\noutput:\n```\n3\n```\ninput:\n```\n1\n0 4\n```\noutput:\n```\n1\n```\ninput:\n```\n2\n1 10\n2 2\n```\noutput:\n```\n3\n```\n#### Note:\nPicture explanation. If we have 3 boxes with side length 2 and 5 boxes with side length 1, then we can put all these boxes inside a box with side length 4, for example, as shown in the picture.\n\nIn the second test case, we can put all four small boxes into a box with side length 2.\n#### 題意:\n輸入N，再輸入N種箱子的尺寸跟數量， 1個箱子可以裝1~4個比自己小一號的箱子，問你需要一個多大的箱子才能裝得下全部的箱子。\n\n\n#### 思路:\n1個箱子可以裝4個比自己小一號的箱子，所以先把輸入的箱子按尺寸大到小排序，記錄現在最大的尺寸，計算可不可以裝得下那些比較小的，要注意的是同一尺寸的箱子最多只會有1000000000個，所以可以裝超過這個數字就不用判斷了，一定裝的下；裝不下的就計算需要幾個目前最大的箱子才裝得下，先記著。\n\n最後跑完全部後再用需要幾個目前最大的箱子來算需要多大的箱子。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/ffe732aec0bdd1ce3ec815518e180d71.js\"></script>\n\n","tags":["sortings","implementation","math","普通"],"categories":["Codeforces"]},{"title":"Codeforces 298A","url":"/Snow-Footprints/","content":"# Codeforces 298A - Snow Footprints\n[Snow Footprints](https://codeforces.com/problemset/problem/298/A)\n\nThere is a straight snowy road, divided into n blocks. The blocks are numbered from 1 to n from left to right. If one moves from the i-th block to the (i + 1)-th block, he will leave a right footprint on the i-th block. Similarly, if one moves from the i-th block to the (i - 1)-th block, he will leave a left footprint on the i-th block. If there already is a footprint on the i-th block, the new footprint will cover the old one.\n<!-- more -->\n![A](A.PNG)\nAt the beginning, there were no footprints. Then polar bear Alice starts from the s-th block, makes a sequence of moves and ends in the t-th block. It is known that Alice never moves outside of the road.\n\nYou are given the description of Alice's footprints. Your task is to find a pair of possible values of s, t by looking at the footprints.\n#### Input:\nThe first line of the input contains integer n (3 ≤ n ≤ 1000).\n\nThe second line contains the description of the road — the string that consists of n characters. Each character will be either \".\" (a block without footprint), or \"L\" (a block with a left footprint), \"R\" (a block with a right footprint).\n\nIt's guaranteed that the given string contains at least one character not equal to \".\". Also, the first and the last character will always be \".\". It's guaranteed that a solution exists.\n#### Output:\nPrint two space-separated integers — the values of s and t. If there are several possible solutions you can print any of them.\n#### 範例:\ninput:\n```\n9\n..RRLL...\n```\noutput:\n```\n3 4\n```\ninput:\n```\n11\n.RRRLLLLL..\n```\noutput:\n```\n7 5\n```\n#### Note:\nThe first test sample is the one in the picture.\n#### 題意:\n輸入一串腳印，問你其中一種可能的起點跟終點是多少？\n\n#### 思路:\n● 分析一下可以得知實際上只會有三種模式\n1. 只有R\n2. 只有L\n3. 左邊任意個R接右邊任意個L。\n\n● 先記錄R區間跟L區間的頭尾，沒有L區間就是模式1，直接輸出答案；沒有R區間就是模式2，直接輸出答案；兩個都有就視為從最左邊走到最右邊再走回來到交界。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/fa722ac9d242d3ee030746ce5cec083c.js\"></script>\n","tags":["implementation","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 39H","url":"/Multiplication-Table/","content":"# Codeforces 39H - Multiplication-Table\n[Multiplication-Table](https://codeforces.com/problemset/problem/39/H)\nPetya studies positional notations. He has already learned to add and subtract numbers in the systems of notations with different radices and has moved on to a more complicated action — multiplication. To multiply large numbers one has to learn the multiplication table. Unfortunately, in the second grade students learn only the multiplication table of decimals (and some students even learn it in the first grade). Help Petya make a multiplication table for numbers in the system of notations with the radix k.\n<!-- more -->\n#### Input:\nThe first line contains a single integer k (2 ≤ k ≤ 10) — the radix of the system.\n#### Output:\nOutput the multiplication table for the system of notations with the radix k. The table must contain k - 1 rows and k - 1 columns. The element on the crossing of the i-th row and the j-th column is equal to the product of i and j in the system of notations with the radix k. Each line may have any number of spaces between the numbers (the extra spaces in the samples are put for clarity).\n#### 範例:\ninput:\n```\n10\n```\noutput:\n```\n1  2  3  4  5  6  7  8  9\n2  4  6  8 10 12 14 16 18\n3  6  9 12 15 18 21 24 27\n4  8 12 16 20 24 28 32 36\n5 10 15 20 25 30 35 40 45\n6 12 18 24 30 36 42 48 54\n7 14 21 28 35 42 49 56 63\n8 16 24 32 40 48 56 64 72\n9 18 27 36 45 54 63 72 81\n```\ninput:\n```\n3\n```\noutput:\n```\n1  2\n2 11\n```\n#### Note:\n\n#### 題意:\n製作一個乘法表，而這個乘法表會是 (k-1)*(k-1) 的形式，而成出的數都是K進位，試著列出乘法表的數 (k不會大於10)。\n\n#### 思路:\n建立乘法表，唯一的難點在轉進位，其他應該沒甚麼問題。\n\n轉進位只需要用10進位不斷的對要轉的進位取餘數之後逆著串起來就行了。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/f1cf5795fd72cf54ac86b3643bcccc45.js\"></script>\n\n","tags":["implementation","普通"],"categories":["Codeforces"]},{"title":"Codeforces 1028C","url":"/Rectangles/","content":"# Codeforces 1028C - Rectangles\n[Rectangles](https://codeforces.com/problemset/problem/1028/C)\n\nYou are given n rectangles on a plane with coordinates of their bottom left and upper right points. Some (n−1) of the given n rectangles have some common point. A point belongs to a rectangle if this point is strictly inside the rectangle or belongs to its boundary.\n<!-- more -->\nFind any point with integer coordinates that belongs to at least (n−1) given rectangles.\n\n#### Input:\nThe first line contains a single integer n (2≤n≤132674) — the number of given rectangles.\n\nEach the next n lines contains four integers x1, y1, x2 and y2 (−10<sup>9</sup>≤x1<x2≤10<sup>9</sup>, −10<sup>9</sup>≤y1<y2≤10<sup>9</sup>) — the coordinates of the bottom left and upper right corners of a rectangle.\n#### Output:\nPrint two integers x and y — the coordinates of any point that belongs to at least (n−1) given rectangles.\n#### 範例:\ninput:\n```\n3\n0 0 1 1\n1 1 2 2\n3 0 4 1\n```\noutput:\n```\n1 1\n```\ninput:\n```\n3\n0 0 1 1\n0 1 1 2\n1 0 2 1\n```\noutput:\n```\n1 1\n```\ninput:\n```\n4\n0 0 5 5\n0 0 4 4\n1 1 4 4\n1 1 4 4\n```\noutput:\n```\n1 1\n```\ninput:\n```\n5\n0 0 10 8\n1 2 6 7\n2 3 5 6\n3 4 4 5\n8 1 9 2\n```\noutput:\n```\n3 4\n```\n#### Note:\nThe picture below shows the rectangles in the first and second samples. The possible answers are highlighted.\n![A](A.PNG)\nThe picture below shows the rectangles in the third and fourth samples.\n![B](B.PNG)\n#### 題意:\n提供n個矩形，其坐標分別為左下角和右上角。 給定的n個矩形中的某些（n-1）個具有一些公共點。 如果某點嚴格位於矩形內或屬於其邊界，則該點屬於矩形。\n\n找具有至少屬於（n-1）個給定矩形的整數坐標的任何點。\n#### 思路:\n要在N−1個矩形中，因此只要一個一個刪去後，判斷剩下的N−1 個矩形有沒有套在一起就可以了。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/9bd6c597f308d42107b1326c4e318330.js\"></script>\n\n","tags":["sortings","implementation","普通","geometry"],"categories":["Codeforces"]},{"title":"Codeforces 185A","url":"/Plant/","content":"# Codeforces 185A - Plant\n[Plant](https://codeforces.com/problemset/problem/185/A)\n\nDwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.\n<!-- more -->\n![A](A.PNG)\nHelp the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.\n#### Input:\nThe first line contains a single integer n (0 ≤ n ≤ 10<sup>18</sup>) — the number of full years when the plant grew.\n\nPlease do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n#### Output:\nPrint a single integer — the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (10<sup>9</sup> + 7).\n#### 範例:\ninput:\n```\n1\n```\noutput:\n```\n3\n```\ninput:\n```\n2\n```\noutput:\n```\n10\n```\n#### Note:\nThe first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.\n\n#### 題意:\n觀察後可以得到N=1時向上的三角形有1+2=3個，N=2時有1+2+3+4=1+2+…+2<sup>2</sup>=10個，因此推導出輸入N時有1+…+2N=((2<sup>N</sup>+1) 2<sup>N</sup>)/2個三角形，因此題目可以等價為求((2<sup>N</sup>+1) 2<sup>N</sup>)/2%1000000007 \n另外一個要知道的數學知識是:\n(a*b*c*d)%e≡((a%e)∙(b%e)∙(c%e)∙(d%e))%e\n\n#### 思路:\n我們現在需要求出2<sup>𝑁</sup>%1000000007是多少，將2<sup>N</sup>分解開並分別求出餘數後用前面的方式求出乘起來後的餘數，然後再算出最後的餘數就是答案，例如2<sup>11</sup>=2<sup>8</sup>∙2<sup>2</sup>∙2<sup>1</sup>  \n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/74951133f40de6bd5ff946f1de27f2f9.js\"></script>\n\n\n","tags":["math","普通"],"categories":["Codeforces"]},{"title":"Codeforces 1197A","url":"/DIY-Wooden-Ladder/","content":"# Codeforces 1197A - DIY Wooden Ladder\n[DIY Wooden Ladder](http://codeforces.com/problemset/problem/1197/A)\n\nLet's denote a k-step ladder as the following structure: exactly k+2 wooden planks, of which\n<!-- more -->\n● two planks of length at least k+1 — the base of the ladder;\n● k planks of length at least 1 — the steps of the ladder;\n\nNote that neither the base planks, nor the steps planks are required to be equal.\n\nFor example, ladders 1 and 3 are correct 2-step ladders and ladder 2 is a correct 1-step ladder. On the first picture the lengths of planks are [3,3] for the base and [1] for the step. On the second picture lengths are [3,3] for the base and [2] for the step. On the third picture lengths are [3,4] for the base and [2,3] for the steps.\n\n![A](A.PNG)\nYou have n planks. The length of the i-th planks is a<sub>i</sub>. You don't have a saw, so you can't cut the planks you have. Though you have a hammer and nails, so you can assemble the improvised \"ladder\" from the planks.\n\nThe question is: what is the maximum number k such that you can choose some subset of the given planks and assemble a k-step ladder using them?\n#### Input:\nThe first line contains a single integer T (1≤T≤100) — the number of queries. The queries are independent.\n\nEach query consists of two lines. The first line contains a single integer n (2≤n≤10<sup>5</sup>) — the number of planks you have.\n\nThe second line contains n integers a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (1≤a<sub>i</sub>≤10<sup>5</sup>) — the lengths of the corresponding planks.\n\nIt's guaranteed that the total number of planks from all queries doesn't exceed 105.\n#### Output:\nPrint T integers — one per query. The i-th integer is the maximum number k, such that you can choose some subset of the planks given in the i-th query and assemble a k-step ladder using them.\n\nPrint 0 if you can't make even 1-step ladder from the given set of planks.\n#### 範例:\ninput:\n```\n4\n4\n1 3 1 3\n3\n3 3 2\n5\n2 3 3 4 2\n3\n1 1 2\n```\noutput:\n```\n2\n1\n2\n0\n```\n\n#### Note:\n\n#### 題意:\n第一個輸入為T個木梯\n第二個輸入為N個木條\n接著輸入a<sub>1</sub>....a<sub>n</sub>個木條長度\n\n題目問你他要請你幫他隨便造出一個木梯，但是因為沒有工具，所以木頭不行切割，利用這些木頭可以造出幾個階梯的木梯?(木頭間格距離為1)\n#### 思路:\n在輸入的過程中尋找第一長的木條max1與第二長的木條max2，將第二長的木條長度減去1，因為最上面木梯不能建階梯，接著我們把第二長木條長度和剩餘的木條數相比,如果木條數較小,代表他無法把階梯建造完全,會在中途用光木條數,此時木條數就是最多可以造出幾個階梯數,如果木條數大於第二常木條長度,表示他可以完全建造完畢,所以此時第二長的木條長度-1即是可以造出的階梯數.\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/6b5a155e8e6747f7dd817d186437a46c.js\"></script>\n\n","tags":["sortings","greedy","math"],"categories":["Codeforces"]},{"title":"Codeforces 1106C","url":"/Lunar-New-Year-and-Number-Division/","content":"# Codeforces 1106C - Lunar New Year and Number Division\n[Lunar New Year and Number Division](https://codeforces.com/problemset/problem/1106/C)\n\nLunar New Year is approaching, and Bob is struggling with his homework – a number division problem.\n<!-- more -->\nThere are n positive integers a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> on Bob's homework paper, where n is always an even number. Bob is asked to divide those numbers into groups, where each group must contain at least 2 numbers. Suppose the numbers are divided into m groups, and the sum of the numbers in the j-th group is s<sub>j</sub>. Bob's aim is to minimize the sum of the square of s<sub>j</sub>.\nBob is puzzled by this hard problem. Could you please help him solve it?\n\n#### Input:\nThe first line contains an even integer n (2≤n≤3⋅10<sup>5</sup>), denoting that there are n integers on Bob's homework paper.\n\nThe second line contains n integers a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (1≤a<sub>i</sub>≤104), describing the numbers you need to deal with.\n#### Output:\nA single line containing one integer, denoting the minimum of the sum of the square of s<sub>j</sub>.\n#### 範例:\ninput:\n```\n4\n8 5 2 3\n```\noutput:\n```\n164\n```\n\ninput:\n```\n6\n1 1 1 2 2 2\n```\noutput:\n```\n27\n```\n#### Note:\nIn the first sample, one of the optimal solutions is to divide those 4 numbers into 2 groups {2,8},{5,3}. Thus the answer is (2+8)<sup>2</sup>+(5+3)<sup>2</sup>=164.\n\nIn the second sample, one of the optimal solutions is to divide those 6 numbers into 3 groups {1,2},{1,2},{1,2}. Thus the answer is (1+2)<sup>2</sup>+(1+2)<sup>2</sup>+(1+2)<sup>2</sup>=27.\n#### 題意:\n把最大跟最小的數字家再一起然後平方。\n#### 思路:\n收先就是排序，排序完後就把頭跟尾的數字相加並平方直到N/2。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/9523718e99c9196b294b8f269eb4d696.js\"></script>\n\n","tags":["sortings","implementation","greedy","math"],"categories":["Codeforces"]},{"title":"Codeforces 707B","url":"/Bakery/","content":"# Codeforces 707B - Bakery\n[Bakery](https://codeforces.com/problemset/problem/707/B)\n\nMasha wants to open her own bakery and bake muffins in one of the n cities numbered from 1 to n. There are m bidirectional roads, each of whose connects some pair of cities.\n<!-- more -->\nTo bake muffins in her bakery, Masha needs to establish flour supply from some storage. There are only k storages, located in different cities numbered a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>k</sub>.\n\nUnforunately the law of the country Masha lives in prohibits opening bakery in any of the cities which has storage located in it. She can open it only in one of another n - k cities, and, of course, flour delivery should be paid — for every kilometer of path between storage and bakery Masha should pay 1 ruble.\n\nFormally, Masha will pay x roubles, if she will open the bakery in some city b (a<sub>i</sub> ≠ b for every 1 ≤ i ≤ k) and choose a storage in some city s (s = aj for some 1 ≤ j ≤ k) and b and s are connected by some path of roads of summary length x (if there are more than one path, Masha is able to choose which of them should be used).\n\nMasha is very thrifty and rational. She is interested in a city, where she can open her bakery (and choose one of k storages and one of the paths between city with bakery and city with storage) and pay minimum possible amount of rubles for flour delivery. Please help Masha find this amount.\n\n#### Input:\nThe first line of the input contains three integers n, m and k (1 ≤ n, m ≤ 10<sup>5</sup>, 0 ≤ k ≤ n) — the number of cities in country Masha lives in, the number of roads between them and the number of flour storages respectively.\n\nThen m lines follow. Each of them contains three integers u, v and l (1 ≤ u, v ≤ n, 1 ≤ l ≤ 10<sup>9</sup>, u ≠ v) meaning that there is a road between cities u and v of length of l kilometers .\n\nIf k > 0, then the last line of the input contains k distinct integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>k</sub> (1 ≤ a<sub>i</sub> ≤ n) — the number of cities having flour storage located in. If k = 0 then this line is not presented in the input.\n\n#### Output:\nPrint the minimum possible amount of rubles Masha should pay for flour delivery in the only line.\n\nIf the bakery can not be opened (while satisfying conditions) in any of the n cities, print  - 1 in the only line.\n\n#### 範例:\ninput:\n```\n5 4 2\n1 2 5\n1 2 3\n2 3 4\n1 4 10\n1 5\n```\noutput:\n```\n3\n```\ninput:\n```\n3 1 1\n1 2 3\n3\n```\noutput:\n```\n-1\n```\ninput:\n```\n2 5\n5 4 3 2 1\n```\noutput:\n```\n1\n```\ninput:\n```\n3 9\n42 42 42 42 42 42 42 42 42\n```\noutput:\n```\n3\n```\n#### Note:\n![A](A.PNG)\n\n#### 題意:\n輸入N個人跟M包食物，再輸入這M包食物的種類。現在規定每個人指定一種食物，每天只能吃一樣種類的食物，沒有每個人都要指定一樣或不一樣的種類，問你這些食物最多能吃幾天？\n\n#### 思路:\n用二分搜尋法搜尋天數d，判斷食物夠不夠吃d天。先統計食物的出現次數，出現次數除以天數就等於能給幾個人吃d天，加總所有食物能供給的人數，若是大於等於N就表示這些食物可以吃d天。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/fcc80ed825820de5d02df437d0351496.js\"></script>\n","tags":["簡單","graphs"],"categories":["Codeforces"]},{"title":"Codeforces 1011B","url":"/Planning-The-Expedition/","content":"# Codeforces 1011B - Planning The Expedition\n[Planning The Expedition](https://codeforces.com/problemset/problem/1011/B)\n\nNatasha is planning an expedition to Mars for n people. One of the important tasks is to provide food for each participant.\n<!-- more -->\nThe warehouse has m daily food packages. Each package has some food type a<sub>i</sub>.\n\nEach participant must eat exactly one food package each day. Due to extreme loads, each participant must eat the same food type throughout the expedition. Different participants may eat different (or the same) types of food.\n\nFormally, for each participant j Natasha should select his food type b<sub>j</sub> and each day j-th participant will eat one food package of type b<sub>j</sub>. The values b<sub>j</sub> for different participants may be different.\n\nWhat is the maximum possible number of days the expedition can last, following the requirements above?\n\n#### Input:\nThe first line contains two integers n and m (1≤n≤100, 1≤m≤100) — the number of the expedition participants and the number of the daily food packages available.\n\nThe second line contains sequence of integers a<sub>1</sub>,a<sub>2</sub>,…,a<sub>m</sub>(1≤a<sub>i</sub>≤100), where ai is the type of i-th food package.\n\n#### Output:\nPrint the single integer — the number of days the expedition can last. If it is not possible to plan the expedition for even one day, print 0.\n\n#### 範例:\ninput:\n```\n4 10\n1 5 2 1 1 1 2 5 7 2\n```\noutput:\n```\n2\n```\ninput:\n```\n100 1\n1\n```\noutput:\n```\n0\n```\ninput:\n```\n2 5\n5 4 3 2 1\n```\noutput:\n```\n1\n```\ninput:\n```\n3 9\n42 42 42 42 42 42 42 42 42\n```\noutput:\n```\n3\n```\n#### Note:\nIn the first example, Natasha can assign type 1 food to the first participant, the same type 1 to the second, type 5 to the third and type 2 to the fourth. In this case, the expedition can last for 2 days, since each participant can get two food packages of his food type (there will be used 4 packages of type 1, two packages of type 2 and two packages of type 5).\n\nIn the second example, there are 100 participants and only 1 food package. In this case, the expedition can't last even 1 day.\n\n#### 題意:\n輸入N個人跟M包食物，再輸入這M包食物的種類。現在規定每個人指定一種食物，每天只能吃一樣種類的食物，沒有每個人都要指定一樣或不一樣的種類，問你這些食物最多能吃幾天？\n\n#### 思路:\n用二分搜尋法搜尋天數d，判斷食物夠不夠吃d天。先統計食物的出現次數，出現次數除以天數就等於能給幾個人吃d天，加總所有食物能供給的人數，若是大於等於N就表示這些食物可以吃d天。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/df2e49ff2e71f26223bf4be6dce43c51.js\"></script>\n","tags":["implementation","普通","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 739A","url":"/Alyona-and-Mex/","content":"# Codeforces 739A - Alyona and Mex\n[Alyona and Mex](https://codeforces.com/problemset/problem/739/A)\n\nAlyona's mother wants to present an array of n non-negative integers to Alyona. The array should be special.\n<!-- more -->\nAlyona is a capricious girl so after she gets the array, she inspects m of its subarrays. Subarray is a set of some subsequent elements of the array. The i-th subarray is described with two integers l<sub>i</sub> and r<sub>i</sub>, and its elements are a\\[l<sub>i</sub>], a[l<sub>i</sub> + 1], ..., a\\[r<sub>i</sub>].\n\nAlyona is going to find mex for each of the chosen subarrays. Among these m mexes the girl is going to find the smallest. She wants this minimum mex to be as large as possible.\n\nYou are to find an array a of n elements so that the minimum mex among those chosen by Alyona subarrays is as large as possible.\n\nThe mex of a set S is a minimum possible non-negative integer that is not in S.\n\n#### Input:\nThe first line contains two integers n and m (1 ≤ n, m ≤ 10<sup>5</sup>).\n\nThe next m lines contain information about the subarrays chosen by Alyona. The i-th of these lines contains two integers l<sub>i</sub> and r<sub>i</sub> (1 ≤ l<sub>i</sub> ≤ r<sub>i</sub> ≤ n), that describe the subarray a\\[l<sub>i</sub>], a[l<sub>i</sub> + 1], ..., a\\[r<sub>i</sub>].\n#### Output:\nIn the first line print single integer — the maximum possible minimum mex.\n\nIn the second line print n integers — the array a. All the elements in a should be between 0 and 10<sup>9</sup>.\n\nIt is guaranteed that there is an optimal answer in which all the elements in a are between 0 and 10<sup>9</sup>.\n\nIf there are multiple solutions, print any of them.\n#### 範例:\ninput:\n```\n5 3\n1 3\n2 5\n4 5\n```\noutput:\n```\n2\n1 0 2 1 0\n```\ninput:\n```\n4 2\n1 4\n2 4\n```\noutput:\n```\n3\n5 2 0 1\n```\n\n#### Note:\nThe first example: the mex of the subarray (1, 3) is equal to 3, the mex of the subarray (2, 5) is equal to 3, the mex of the subarray (4, 5) is equal to 2 as well, thus the minumal mex among the subarrays chosen by Alyona is equal to 2.\n#### 題意:\n給你一個陣列，現在可以對每一個元素分別將他變小，最後選出沒在陣列中出現過的正數中最小的，問你這個數值的最大值是多少？\n\n#### 思路:\n輸入完後從小排到大，先將答案設為1，然後跑整個陣列，若是當前數字大於等於答案，則表示這個數字能變成答案，那就表示可以將沒出現的數字(答案)加1，跑完陣列後輸出答案即可。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/64e67f626854df2b130243b23d4b678f.js\"></script>\n","tags":["sortings","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 450B","url":"/Jzzhu-and-Sequences/","content":"# Codeforces 450B - Jzzhu and Sequences\n[Jzzhu and Sequences](https://codeforces.com/problemset/problem/450/B)\n\nJzzhu has invented a kind of sequences, they meet the following property:\n<!-- more -->\n![A](A.PNG)\nYou are given x and y, please calculate f<sub>n</sub> modulo 1000000007 (10<sup>9</sup> + 7).\n\n#### Input:\nThe first line contains two integers x and y (|x|, |y| ≤ 10<sup>9</sup>). The second line contains a single integer n (1 ≤ n ≤ 2·10<sup>9</sup>).\n\n#### Output:\nOutput a single integer representing f<sub>n</sub> modulo 1000000007 (10<sup>9</sup> + 7).\n\n#### 範例:\ninput:\n```\n2 3\n3\n```\noutput:\n```\n1\n```\ninput:\n```\n0 -1\n2\n```\noutput:\n```\n1000000006\n```\n#### Note:\nIn the first sample, f<sub>2</sub> = f<sub>1</sub> + f<sub>3</sub>, 3 = 2 + f<sub>3</sub>, f<sub>3</sub> = 1.\n\nIn the second sample, f<sub>2</sub> =  - 1;  - 1 modulo (10<sup>9</sup> + 7) equals (10<sup>9</sup> + 6).\n#### 題意:\n輸入X跟Y作為一個數列的前兩項，並給你數列的規則，問你第N項對100000007取餘數後的值是多少？\n\n#### 思路:\n將規則用X跟Y繼續列舉，發現每6項數值會有一個循環，因此先將前6項計算好，再計算第N項是6項中的第幾項後就可以取餘數了，要注意的是餘數是負數的時候要加回正數。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/050a756b7c15a39d45e2148f120cc259.js\"></script>\n","tags":["implementation","math","普通"],"categories":["Codeforces"]},{"title":"Codeforces 581B","url":"/Luxurious-Houses/","content":"# Codeforces 581B - Luxurious Houses\n[Luxurious Houses](https://codeforces.com/problemset/problem/581/B)\n\nThe capital of Berland has n multifloor buildings. The architect who built up the capital was very creative, so all the houses were built in one row.\n<!-- more -->\nLet's enumerate all the houses from left to right, starting with one. A house is considered to be luxurious if the number of floors in it is strictly greater than in all the houses with larger numbers. In other words, a house is luxurious if the number of floors in it is strictly greater than in all the houses, which are located to the right from it. In this task it is assumed that the heights of floors in the houses are the same.\n\nThe new architect is interested in n questions, i-th of them is about the following: \"how many floors should be added to the i-th house to make it luxurious?\" (for all i from 1 to n, inclusive). You need to help him cope with this task.\n\nNote that all these questions are independent from each other — the answer to the question for house i does not affect other answers (i.e., the floors to the houses are not actually added).\n\n#### Input:\nThe first line of the input contains a single number n (1 ≤ n ≤ 10<sup>5</sup>) — the number of houses in the capital of Berland.\n\nThe second line contains n space-separated positive integers h<sub>i (1 ≤ h<sub>i</sub> ≤ 10<sup>9</sup>), where hi equals the number of floors in the i-th house. \n\n#### Output:\nPrint n integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, where number a<sub>i</sub> is the number of floors that need to be added to the house number i to make it luxurious. If the house is already luxurious and nothing needs to be added to it, then a<sub>i</sub> should be equal to zero.\n\nAll houses are numbered from left to right, starting from one.\n\n#### 範例:\ninput:\n```\n5\n1 2 3 1 2\n```\noutput:\n```\n3 2 0 2 0 \n```\ninput:\n```\n4\n3 2 1 4\n```\noutput:\n```\n2 3 4 0 \n```\n#### 題意:\n給你N間房子的高度，從左到右。一間房子若是比他右邊所有的房子都要高的話就能稱為奢華，問你每一間房子各自若要變的奢華的話還要再增高多少？\n\n#### 思路:\n從最右邊開始，記錄到目前為止最高的高度，然後若是自己比最高的高度還矮或是一樣，就加高，不然不用加。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/50eceb9a682e44901b10ccabb961c6a8.js\"></script>\n","tags":["implementation","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 1141A","url":"/Game-23/","content":"# Codeforces 1141A - Game 23\n[Game 23](https://codeforces.com/problemset/problem/1141/A)\n\nPolycarp plays \"Game 23\". Initially he has a number n and his goal is to transform it to m. In one move, he can multiply n by 2 or multiply n by 3. He can perform any number of moves.\n<!-- more -->\nPrint the number of moves needed to transform n\nto m. Print -1 if it is impossible to do so.\n\nIt is easy to prove that any way to transform n to m contains the same number of moves (i.e. number of moves doesn't depend on the way of transformation).\n\n#### Input:\nThe only line of the input contains two integers n and m (1≤n≤m≤5⋅108).\n\n#### Output:\nPrint the number of moves to transform n to m, or -1 if there is no solution.\n\n#### 範例:\ninput:\n```\n120 51840\n```\noutput:\n```\n7\n```\ninput:\n```\n42 42\n```\noutput:\n```\n0\n```\ninput:\n```\n48 72\n```\noutput:\n```\n-1\n```\n#### Note:\nIn the first example, the possible sequence of moves is: 120→240→720→1440→4320→12960→25920→51840. The are 7 steps in total.\n\nIn the second example, no moves are needed. Thus, the answer is 0.\n\nIn the third example, it is impossible to transform 48 to 72.\n#### 題意:\n輸入n、m，你現在每一步可以將n乘以2或3，問你需要幾步可以將n變成m？不能的話輸出-1。\n\n#### 思路:\n先判斷能不能n整除m，不能就輸出-1，可以的話直接除，然後將商質因數分解，看有幾個2跟3，有2跟3以外的因數就輸出-1，不然個數加起來就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/55eb8af27dbbcb1e6383f0c1fbe38cf1.js\"></script>\n","tags":["implementation","math","新手"],"categories":["Codeforces"]},{"title":"Codeforces 599A","url":"/Patrick-and-Shopping/","content":"# Codeforces 599A - Patrick and Shopping\n[Patrick and Shopping](https://codeforces.com/problemset/problem/599/A)\n\nToday Patrick waits for a visit from his friend Spongebob. To prepare for the visit, Patrick needs to buy some goodies in two stores located near his house. There is a d1 meter long road between his house and the first shop and a d2 meter long road between his house and the second shop. Also, there is a road of length d3 directly connecting these two shops to each other. Help Patrick calculate the minimum distance that he needs to walk in order to go to both shops and return to his house.\n<!-- more -->\n![A](A.PNG)\nPatrick always starts at his house. He should visit both shops moving only along the three existing roads and return back to his house. He doesn't mind visiting the same shop or passing the same road multiple times. The only goal is to minimize the total distance traveled.\n\n#### Input:\nThe first line of the input contains three integers d<sub>1</sub>, d<sub>2</sub>, d<sub>3</sub> (1 ≤ d<sub>1</sub>, d<sub>2</sub>, d<sub>3</sub> ≤ 10<sup>8</sup>) — the lengths of the paths.\n\n>>● d<sub>1</sub> is the length of the path connecting Patrick's house and the first shop.\n>>● d<sub>2</sub> is the length of the path connecting Patrick's house and the second shop.\n>>● d<sub>3</sub> is the length of the path connecting both shops. \n#### Output:\nPrint the minimum distance that Patrick will have to walk in order to visit both shops and return to his house.\n\n#### 範例:\ninput:\n```\n10 20 30\n```\noutput:\n```\n60\n```\ninput:\n```\n1 1 5\n```\noutput:\n```\n4\n```\n#### Note:\nThe first sample is shown on the picture in the problem statement. One of the optimal routes is: house -> first -> shop -> second -> shop house.\n\nIn the second sample one of the optimal routes is: house -> first -> shop -> house -> second -> shop -> house.\n#### 題意:\n輸入家到商店1、家到商店2和商店1到商店2的距離，問你從家開始，去過兩間商店，在回到家中的最短距離是多少？可以重複經過同一條路或同一個點。\n\n#### 思路:\n比較繞一圈或不走其中一條路的走法哪個最短即可。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/6b0632575d93f2313d96708316709aa8.js\"></script>\n\n","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"Codeforces 705A","url":"/Hulk/","content":"# Codeforces 705A - Hulk\n[Hulk](https://codeforces.com/problemset/problem/705/A)\n\nDr. Bruce Banner hates his enemies (like others don't). As we all know, he can barely talk when he turns into the incredible Hulk. That's why he asked you to help him to express his feelings.\n<!-- more -->\nHulk likes the Inception so much, and like that his feelings are complicated. They have n layers. The first layer is hate, second one is love, third one is hate and so on...\n\nFor example if n = 1, then his feeling is \"I hate it\" or if n = 2 it's \"I hate that I love it\", and if n = 3 it's \"I hate that I love that I hate it\" and so on.\n\nPlease help Dr. Banner.\n\n#### Input:\nThe only line of the input contains a single integer n (1 ≤ n ≤ 100) — the number of layers of love and hate.\n\n#### Output:\nPrint Dr.Banner's feeling in one line.\n\n#### 範例:\ninput:\n```\n1\n```\noutput:\n```\nI hate it\n```\ninput:\n```\n2\n```\noutput:\n```\nI hate that I love it\n```\ninput:\n```\n3\n```\noutput:\n```\nI hate that I love that I hate it\n```\n\n#### 題意:\n輸入的數字n，依照n輸出指定層的字串，第一層是hate，第二層是love，第三層是hate，以此類推。\n\n#### 思路:\n依照規則輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/0ae912ae1970a1db2ecb903b3427de1c.js\"></script>\n","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"Codeforces 1055A","url":"/Metro/","content":"# Codeforces 1055A - Metro\n[Metro](https://codeforces.com/problemset/problem/1055/A)\n\nAlice has a birthday today, so she invited home her best friend Bob. Now Bob needs to find a way to commute to the Alice's home.\n<!-- more -->\nIn the city in which Alice and Bob live, the first metro line is being built. This metro line contains n\nstations numbered from 1 to n. Bob lives near the station with number 1, while Alice lives near the station with number s. The metro line has two tracks. Trains on the first track go from the station 1 to the station n\n\nand trains on the second track go in reverse direction. Just after the train arrives to the end of its track, it goes to the depot immediately, so it is impossible to travel on it after that.\n\nSome stations are not yet open at all and some are only partially open — for each station and for each track it is known whether the station is closed for that track or not. If a station is closed for some track, all trains going in this track's direction pass the station without stopping on it.\n\nWhen the Bob got the information on opened and closed stations, he found that traveling by metro may be unexpectedly complicated. Help Bob determine whether he can travel to the Alice's home by metro or he should search for some other transport.\n\n#### Input:\nThe first line contains two integers n and s (2≤s≤n≤1000) — the number of stations in the metro and the number of the station where Alice's home is located. Bob lives at station 1.\n\nNext lines describe information about closed and open stations.\n\nThe second line contains n integers a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (a<sub>i</sub>=0 or a<sub>i</sub>=1). If a<sub>i</sub>=1, then the i-th station is open on the first track (that is, in the direction of increasing station numbers). Otherwise the station is closed on the first track.\n\nThe third line contains n integers b<sub>1</sub>,b<sub>2</sub>,…,b<sub>n</sub> (b<sub>i</sub>=0 or b<sub>i</sub>=1). If b<sub>i</sub>=1, then the i-th station is open on the second track (that is, in the direction of decreasing station numbers). Otherwise the station is closed on the second track.\n\n#### Output:\nPrint \"YES\" (quotes for clarity) if Bob will be able to commute to the Alice's home by metro and \"NO\" (quotes for clarity) otherwise.\n\nYou can print each letter in any case (upper or lower).\n\n#### 範例:\ninput:\n```\n5 3\n1 1 1 1 1\n1 1 1 1 1\n```\noutput:\n```\nYES\n```\ninput:\n```\n5 4\n1 0 0 0 1\n0 1 1 1 1\n```\noutput:\n```\nYES\n```\ninput:\n```\n5 2\n0 1 1 1 1\n1 1 1 1 1\n```\noutput:\n```\nNO\n```\n#### Note:\nIn the first example, all stations are opened, so Bob can simply travel to the station with number 3.\n\nIn the second example, Bob should travel to the station 5\nfirst, switch to the second track and travel to the station 4 then.\n\nIn the third example, Bob simply can't enter the train going in the direction of Alice's home.\n\n#### 題意:\n給你兩條軌道各自會停靠的站點，一條只能往後，一條只能往前，問你能不能從第1站搭到第S站？\n\n#### 思路:\n先看第一條能不能直達第S站，不能的話找第k站，第一條從第k站轉搭第二條到第S站。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/493c55ecd43681443a4363ceda9a1f69.js\"></script>\n","tags":["greedy","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 888C","url":"/K-Dominant-Character/","content":"# Codeforces 888C - K-Dominant Character\n[K-Dominant Character](https://codeforces.com/problemset/problem/888/C)\n\nYou are given a string s consisting of lowercase Latin letters. Character c is called k-dominant iff each substring of s with length at least k contains this character c.\n<!-- more -->\nYou have to find minimum k such that there exists at least one k-dominant character.\n\n#### Input:\nThe first line contains string s consisting of lowercase Latin letters (1 ≤ |s| ≤ 100000).\n\n#### Output:\nPrint one number — the minimum value of k such that there exists at least one k-dominant character.\n\n#### 範例:\ninput:\n```\nabacaba\n```\noutput:\n```\n2\n```\ninput:\n```\nzzzzz\n```\noutput:\n```\n1\n```\ninput:\n```\nabcde\n```\noutput:\n```\n3\n```\n\n#### 題意:\n給你一個字串，當所有長度為K的子字串都有至少一個共同字元c時，則c在此字串中稱為K-Dominant 。現在c未定，但至少要有一個c存在K-Dominant ，問你K最小可以是多少？\n\n#### 思路:\n用二分搜尋法依照規則搜尋子字串長度。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/a14ccf51ce05c20cd0948abbd3425b79.js\"></script>\n","tags":["implementation","普通","two pointers","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 246A","url":"/Buggy-Sorting/","content":"# Codeforces 246A - Buggy Sorting\n[Buggy Sorting](https://codeforces.com/problemset/problem/246/A)\n\nLittle boy Valera studies an algorithm of sorting an integer array. After studying the theory, he went on to the practical tasks. As a result, he wrote a program that sorts an array of n integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> in the non-decreasing order. The pseudocode of the program, written by Valera, is given below. The input of the program gets number n and array a.\n<!-- more -->\n```\nloop integer variable i from 1 to n - 1\n    loop integer variable j from i to n - 1\n        if (aj > aj + 1), then swap the values of elements aj and aj + 1\n```\nBut Valera could have made a mistake, because he hasn't yet fully learned the sorting algorithm. If Valera made a mistake in his program, you need to give a counter-example that makes his program work improperly (that is, the example that makes the program sort the array not in the non-decreasing order). If such example for the given value of n doesn't exist, print -1.\n\n#### Input:\nYou've got a single integer n (1 ≤ n ≤ 50) — the size of the sorted array.\n\n#### Output:\nPrint n space-separated integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ 100) — the counter-example, for which Valera's algorithm won't work correctly. If the counter-example that meets the described conditions is impossible to give, print -1.\n\nIf there are several counter-examples, consisting of n numbers, you are allowed to print any of them.\n#### 範例:\ninput:\n```\n1\n```\noutput:\n```\n-1\n```\n\n#### 題意:\n給你一個排序法，目標是將陣列排序成非遞減的格式，但是這排序法有錯誤，現在輸入陣列長度，你是否能舉例出一個會排序錯誤的陣列？\n\n#### 思路:\n陣列從位置0排到最後，但是卻先移除位置0，因此長度在3以上時，最後一個一定移不到位置0，因此長度在3以上時將最後一個輸出最小的，其他情況輸出-1即可。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/bb7804303d64985fd6da2a32dcff7dfe.js\"></script>\n","tags":["sortings","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 378B","url":"/Semifinals/","content":"# Codeforces 378B - Semifinals\n[Semifinals](https://codeforces.com/problemset/problem/378/B)\n\nTwo semifinals have just been in the running tournament. Each semifinal had n participants. There are n participants advancing to the finals, they are chosen as follows: from each semifinal, we choose k people (0 ≤ 2k ≤ n) who showed the best result in their semifinals and all other places in the finals go to the people who haven't ranked in the top k in their semifinal but got to the n - 2k of the best among the others.\n<!-- more -->\nThe tournament organizers hasn't yet determined the k value, so the participants want to know who else has any chance to get to the finals and who can go home.\n\n#### Input:\nThe first line contains a single integer n (1 ≤ n ≤ 10<sup>5</sup>) — the number of participants in each semifinal.\n\nEach of the next n lines contains two integers a<sub>i</sub> and b<sub>i</sub> (1 ≤ a<sub>i</sub>, b<sub>i</sub> ≤ 10<sup>9</sup>) — the results of the i-th participant (the number of milliseconds he needs to cover the semifinals distance) of the first and second semifinals, correspondingly. All results are distinct. Sequences a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> and b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>n</sub> are sorted in ascending order, i.e. in the order the participants finished in the corresponding semifinal.\n\n#### Output:\nPrint two strings consisting of n characters, each equals either \"0\" or \"1\". The first line should correspond to the participants of the first semifinal, the second line should correspond to the participants of the second semifinal. The i-th character in the j-th line should equal \"1\" if the i-th participant of the j-th semifinal has any chances to advance to the finals, otherwise it should equal a \"0\".\n\n#### 範例:\ninput:\n```\n4\n9840 9920\n9860 9980\n9930 10020\n10040 10090\n```\noutput:\n```\n1110\n1100\n```\ninput:\n```\n4\n9900 9850\n9940 9930\n10000 10020\n10060 10110\n```\noutput:\n```\n1100\n1100\n```\n\n#### Note:\nConsider the first sample. Each semifinal has 4 participants. The results of the first semifinal are 9840, 9860, 9930, 10040. The results of the second semifinal are 9920, 9980, 10020, 10090.\n\n>>● If k = 0, the finalists are determined by the time only, so players 9840, 9860, 9920 and 9930 advance to the finals.\n>>● If k = 1, the winners from both semifinals move to the finals (with results 9840 and 9920), and the other places are determined by the time (these places go to the sportsmen who run the distance in 9860 and 9930 milliseconds).\n>>●If k = 2, then first and second places advance from each seminfial, these are participants with results 9840, 9860, 9920 and 9980 milliseconds. \n\n#### 題意:\n給你兩次比賽的成績，兩邊可以各錄取K名進入決賽(0≤2K≤N)，剩下的名次用成績決定(不會有一樣的成績)，現在K未定，問你那些人是有機會進入決賽的？\n\n#### 思路:\n兩邊的前N/2名都有可能，剩下的名次則是到總成績的第N名有可能，將兩種綜合即可。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/aa4d5499ee399a951c3844b6cd5db293.js\"></script>\n","tags":["sortings","implementation","普通"],"categories":["Codeforces"]},{"title":"Codeforces 37A","url":"/Towers/","content":"# Codeforces 37A - Towers\n[Towers](https://codeforces.com/problemset/problem/37/A)\n\nLittle Vasya has received a young builder’s kit. The kit consists of several wooden bars, the lengths of all of them are known. The bars can be put one on the top of the other if their lengths are the same.\n<!-- more -->\nVasya wants to construct the minimal number of towers from the bars. Help Vasya to use the bars in the best way possible.\n\n#### Input:\nThe first line contains an integer N (1 ≤ N ≤ 1000) — the number of bars at Vasya’s disposal. The second line contains N space-separated integers l<sub>i</sub> — the lengths of the bars. All the lengths are natural numbers not exceeding 1000.\n\n#### Output:\nIn one line output two numbers — the height of the largest tower and their total number. Remember that Vasya should use all the bars.\n\n#### 範例:\ninput:\n```\n3\n1 2 3\n```\noutput:\n```\n1 3\n```\ninput:\n```\n4\n6 5 6 7\n```\noutput:\n```\n2 3\n```\n\n#### 題意:\n給你N根木棒，長度一樣的會疊在一起，每一疊稱為一座塔，問你最高的塔是多高和總共有幾座塔？\n\n#### 思路:\n排序後計算每個數字各出現幾次，紀錄最大值；計算出現幾種數字。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/fa84e180769bcd1b2ba6b72bd859c455.js\"></script>\n","tags":["sortings","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 276A","url":"/Lunch-Rush/","content":"# Codeforces 276A - Lunch Rush\n[Lunch Rush](https://codeforces.com/problemset/problem/276/A)\n\nHaving written another programming contest, three Rabbits decided to grab some lunch. The coach gave the team exactly k time units for the lunch break.\n<!-- more -->\nThe Rabbits have a list of n restaurants to lunch in: the i-th restaurant is characterized by two integers f<sub>i</sub> and t<sub>i</sub>. Value t<sub>i</sub> shows the time the Rabbits need to lunch in the i-th restaurant. If time t<sub>i</sub> exceeds the time k that the coach has given for the lunch break, then the Rabbits' joy from lunching in this restaurant will equal f<sub>i</sub> - (t<sub>i</sub> - k). Otherwise, the Rabbits get exactly f<sub>i</sub> units of joy.\n\nYour task is to find the value of the maximum joy the Rabbits can get from the lunch, depending on the restaurant. The Rabbits must choose exactly one restaurant to lunch in. Note that the joy value isn't necessarily a positive value. \n\n#### Input:\nThe first line contains two space-separated integers — n (1 ≤ n ≤ 10<sup>4</sup>) and k (1 ≤ k ≤ 10<sup>9</sup>) — the number of restaurants in the Rabbits' list and the time the coach has given them to lunch, correspondingly. Each of the next n lines contains two space-separated integers — f<sub>i</sub> (1 ≤ f<sub>i</sub> ≤ 10<sup>9</sup>) and ti (1 ≤ t<sub>i</sub> ≤ 10<sup>9</sup>) — the characteristics of the i-th restaurant.\n\n#### Output:\nIn a single line print a single integer — the maximum joy value that the Rabbits will get from the lunch. \n\n#### 範例:\ninput:\n```\n2 5\n3 3\n4 5\n```\noutput:\n```\n4\n```\ninput:\n```\n4 6\n5 8\n3 6\n2 3\n2 2\n```\noutput:\n```\n3\n```\ninput:\n```\n1 5\n1 7\n```\noutput:\n```\n-1\n```\n\n#### 題意:\n有休息時間K可以去吃午餐，只能選一間餐廳，每間餐廳需花費t<sub>i</sub>時間吃飯，得到f<sub>i</sub>的快樂值，若是時間不夠的話則是得到f<sub>i</sub>-(t<sub>i</sub>-K)的快樂值，問你快樂值最大是多少？\n\n#### 思路:\n根據公式紀錄最大值，要注意的是會超過int的值域以及有可能會有負數。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/912deec3e5ca92ecb803eaa07b4b6fef.js\"></script>\n","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"Codeforces 510A","url":"/Fox-And-Snake/","content":"# Codeforces 510A - Fox And Snake\n[Fox And Snake](https://codeforces.com/problemset/problem/510/A)\n\nFox Ciel starts to learn programming. The first task is drawing a fox! However, that turns out to be too hard for a beginner, so she decides to draw a snake instead.\n<!-- more -->\nA snake is a pattern on a n by m table. Denote c-th cell of r-th row as (r, c). The tail of the snake is located at (1, 1), then it's body extends to (1, m), then goes down 2 rows to (3, m), then goes left to (3, 1) and so on.\n\nYour task is to draw this snake for Fox Ciel: the empty cells should be represented as dot characters ('.') and the snake cells should be filled with number signs ('#').\n\nConsider sample tests in order to understand the snake pattern.\n\n#### Input:\nThe only line contains two integers: n and m (3 ≤ n, m ≤ 50).\n\nn is an odd number.\n\n#### Output:\nOutput n lines. Each line should contain a string consisting of m characters. Do not output spaces.\n\n#### 範例:\ninput:\n```\n3 3\n```\noutput:\n```\n###\n..#\n###\n```\ninput:\n```\n3 4\n```\noutput:\n```\n####\n...#\n####\n```\ninput:\n```\n5 3\n```\noutput:\n```\n###\n..#\n###\n#..\n###\n```\ninput:\n```\n9 9\n```\noutput:\n```\n#########\n........#\n#########\n#........\n#########\n........#\n#########\n#........\n#########\n```\n\n#### 題意:\n輸入NxM的大小，請你依照蛇行的規則畫蛇出來。\n\n#### 思路:\n照規則畫。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/0cd43d28896aa503e19becd092fef0bd.js\"></script>\n","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"Codeforces 1146A","url":"/LOVE-A/","content":"# Codeforces 1146A - LOVE A\n[LOVE A](https://codeforces.com/contest/1146/problem/A)\n\nAlice has a string s. She really likes the letter \"a\". She calls a string good if strictly more than half of the characters in that string are \"a\"s. For example \"aaabb\", \"axaa\" are good strings, and \"baca\", \"awwwa\", \"\" (empty string) are not.\n<!-- more -->\nAlice can erase some characters from her string s. She would like to know what is the longest string remaining after erasing some characters (possibly zero) to get a good string. It is guaranteed that the string has at least one \"a\" in it, so the answer always exists.\n\n#### Input:\nThe first line contains a string s (1≤|s|≤50) consisting of lowercase English letters. It is guaranteed that there is at least one \"a\" in s.\n\n#### Output:\nPrint a single integer, the length of the longest good string that Alice can get after erasing some characters from s.\n\n#### 範例:\ninput:\n```\nxaxxxxa\n```\noutput:\n```\n3\n```\ninput:\n```\naaabaa\n```\noutput:\n```\n6\n```\n#### Note:\nIn the first example, it's enough to erase any four of the \"x\"s. The answer is 3 since that is the maximum number of characters that can remain.\n\nIn the second example, we don't need to erase any characters.\n#### 題意:\n可以刪掉字元，問當前字串要有超過一半的字元是a的話最長是多長？\n\n#### 思路:\n先計算a的數量，再取最長為2 * a - 1的長度即可。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/f14306201ff1412f10cfd80800e55d46.js\"></script>\n","tags":["sortings","implementation","新手"],"categories":["Codeforces"]},{"title":"Codeforces 1042A","url":"/Benches/","content":"# Codeforces 1042A - Benches\n[Benches](https://codeforces.com/problemset/problem/1042/A)\n\nThere are n benches in the Berland Central park. It is known that ai people are currently sitting on the i-th bench. Another m people are coming to the park and each of them is going to have a seat on some bench out of n available.\n<!-- more -->\nLet k be the maximum number of people sitting on one bench after additional m people came to the park. Calculate the minimum possible k and the maximum possible k.\n\nNobody leaves the taken seat during the whole process.\n\n#### Input:\nThe first line contains a single integer n (1≤n≤100) — the number of benches in the park.\n\nThe second line contains a single integer m (1≤m≤10000) — the number of people additionally coming to the park.\n\nEach of the next n lines contains a single integer a<sub>i</sub> (1≤a<sub>i</sub>≤100) — the initial number of people on the i-th bench.\n\n#### Output:\nPrint the minimum possible k and the maximum possible k, where k is the maximum number of people sitting on one bench after additional m people came to the park.\n\n#### 範例:\ninput:\n```\n4\n6\n1\n1\n1\n1\n```\noutput:\n```\n3 7\n```\ninput:\n```\n1\n10\n5\n```\noutput:\n```\n15 15\n```\ninput:\n```\n3\n6\n1\n6\n5\n```\noutput:\n```\n6 12\n```\ninput:\n```\n3\n7\n1\n6\n5\n```\noutput:\n```\n7 13\n```\n#### Note:\nIn the first example, each of four benches is occupied by a single person. The minimum k is 3. For example, it is possible to achieve if two newcomers occupy the first bench, one occupies the second bench, one occupies the third bench, and two remaining — the fourth bench. The maximum k is 7. That requires all six new people to occupy the same bench.\n\nThe second example has its minimum k equal to 15 and maximum k equal to 15, as there is just a single bench in the park and all 10 people will occupy it.\n\n#### 題意:\n有n張椅子，上面各有ai個人，現在又來了m個人，問你所有人都坐上椅子後，最多人的椅子最少跟最多會有多少人？\n\n#### 思路:\n先記錄原本最多人的椅子(假設有x人)，在加入m個人後，最多人的椅子最少不可能比原本最多的少(x)，最多就是m個人都做到原本最多人的椅子上(x+m)。因此用二分搜尋法搜尋x~x+m，紀錄最小值。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/5aaf8dd05e85a842d69a5733a2277a67.js\"></script>\n","tags":["implementation","普通","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 911B","url":"/Two-Cakes/","content":"# Codeforces 911B - Two Cakes\n[Two Cakes](https://codeforces.com/problemset/problem/911/B)\n\nIt's New Year's Eve soon, so Ivan decided it's high time he started setting the table. Ivan has bought two cakes and cut them into pieces: the first cake has been cut into a pieces, and the second one — into b pieces.\n<!-- more -->\nIvan knows that there will be n people at the celebration (including himself), so Ivan has set n plates for the cakes. Now he is thinking about how to distribute the cakes between the plates. Ivan wants to do it in such a way that all following conditions are met:\n\n>>1. Each piece of each cake is put on some plate;\n>>2. Each plate contains at least one piece of cake;\n>>3. No plate contains pieces of both cakes.\n\nTo make his guests happy, Ivan wants to distribute the cakes in such a way that the minimum number of pieces on the plate is maximized. Formally, Ivan wants to know the maximum possible number x such that he can distribute the cakes according to the aforementioned conditions, and each plate will contain at least x pieces of cake.\n\nHelp Ivan to calculate this number x!\n\n#### Input:\nThe first line contains three integers n, a and b (1 ≤ a, b ≤ 100, 2 ≤ n ≤ a + b) — the number of plates, the number of pieces of the first cake, and the number of pieces of the second cake, respectively.\n\n#### Output:\nPrint the maximum possible number x such that Ivan can distribute the cake in such a way that each plate will contain at least x pieces of cake.\n\n#### 範例:\ninput:\n```\n5 2 3\n```\noutput:\n```\n1\n```\ninput:\n```\n4 7 10\n```\noutput:\n```\n3\n```\n#### Note:\nIn the first example there is only one way to distribute cakes to plates, all of them will have 1 cake on it.\n\nIn the second example you can have two plates with 3 and 4 pieces of the first cake and two plates both with 5 pieces of the second cake. Minimal number of pieces is 3.\n\n#### 題意:\n現在有兩大塊蛋糕各自分成a片和b片，要分給n個人，有3個條件，(1)每片蛋糕都要分出去；(2)每個人至少有1片蛋糕；(3)一個人只能有一種蛋糕。問你被分到最少片蛋糕的那個人，他最多能拿到幾片蛋糕？\n\n#### 思路:\n因為一塊蛋糕最多分成100片，因此用二分搜尋找1~100，記住最大值輸出。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/514ffd6016100eaa0ee60e4e42edc292.js\"></script>\n","tags":["implementation","普通","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 34B","url":"/Sale/","content":"# Codeforces 34B - Sale\n[Sale](https://codeforces.com/problemset/problem/34/B)\n\nOnce Bob got to a sale of old TV sets. There were n TV sets at that sale. TV set with index i costs ai bellars. Some TV sets have a negative price — their owners are ready to pay Bob if he buys their useless apparatus. Bob can «buy» any TV sets he wants. Though he's very strong, Bob can carry at most m TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn.\n<!-- more -->\n#### Input:\nThe first line contains two space-separated integers n and m (1 ≤ m ≤ n ≤ 100) — amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains n space-separated integers ai ( - 1000 ≤ a<sub>i</sub> ≤ 1000) — prices of the TV sets.\n\n#### Output:\nOutput the only number — the maximum sum of money that Bob can earn, given that he can carry at most m TV sets.\n\n#### 範例:\ninput:\n```\n5 3\n-6 0 35 -2 4\n```\noutput:\n```\n8\n```\ninput:\n```\n4 2\n7 0 0 -7\n```\noutput:\n```\n7\n```\n\n#### 題意:\n有n個商品及售價，你最多拿得動m個，問你最多可以賺多少？\n\n#### 思路:\n因為只有負的可以賺，所以從小的開始拿最多m個負的累加即可。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/31b38649f55b7f93e7e46ccafe952bee.js\"></script>\n","tags":["sortings","greedy","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 230A","url":"/Dragons/","content":"# Codeforces 230A - Dragons\n[Dragons](https://codeforces.com/problemset/problem/230/A)\n\nKirito is stuck on a level of the MMORPG he is playing now. To move on in the game, he's got to defeat all n dragons that live on this level. Kirito and the dragons have strength, which is represented by an integer. In the duel between two opponents the duel's outcome is determined by their strength. Initially, Kirito's strength equals s.\n<!-- more -->\nIf Kirito starts duelling with the i-th (1 ≤ i ≤ n) dragon and Kirito's strength is not greater than the dragon's strength x<sub>i</sub>, then Kirito loses the duel and dies. But if Kirito's strength is greater than the dragon's strength, then he defeats the dragon and gets a bonus strength increase by y<sub>i</sub>.\n\nKirito can fight the dragons in any order. Determine whether he can move on to the next level of the game, that is, defeat all dragons without a single loss.\n\n#### Input:\nThe first line contains two space-separated integers s and n (1 ≤ s ≤ 10<sup>4</sup>, 1 ≤ n ≤ 10<sup>3</sup>). Then n lines follow: the i-th line contains space-separated integers xi and yi (1 ≤ x<sub>i</sub> ≤ 10<sup>4</sup>, 0 ≤ y<sub>i</sub> ≤ 10<sup>4</sup>) — the i-th dragon's strength and the bonus for defeating it.\n\n#### Output:\nOn a single line print \"YES\" (without the quotes), if Kirito can move on to the next level and print \"NO\" (without the quotes), if he can't.\n\n#### 範例:\ninput:\n```\n2 2\n1 99\n100 0\n```\noutput:\n```\nYES\n```\ninput:\n```\n10 1\n100 100\n```\noutput:\n```\nNO\n```\n#### Note:\nIn the first sample Kirito's strength initially equals 2. As the first dragon's strength is less than 2, Kirito can fight it and defeat it. After that he gets the bonus and his strength increases to 2 + 99 = 101. Now he can defeat the second dragon and move on to the next level.\n\nIn the second sample Kirito's strength is too small to defeat the only dragon and win.\n\n#### 題意:\n給你一開始的力量跟每頭龍的力量和打倒後增加的力量，當你的力量大於龍的力量時可以打倒他並增加力量，問你能不能打倒所有龍？\n\n#### 思路:\n從力量小的龍開始打，能打到最後就可以，否則不行。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/01d749d51e34af8688dac86000dff39e.js\"></script>\n","tags":["sortings","greedy","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 899B","url":"/Months-and-Years/","content":"# Codeforces 899B - Months and Years\n[Months and Years](https://codeforces.com/problemset/problem/899/B)\n\nEverybody in Russia uses Gregorian calendar. In this calendar there are 31 days in January, 28 or 29 days in February (depending on whether the year is leap or not), 31 days in March, 30 days in April, 31 days in May, 30 in June, 31 in July, 31 in August, 30 in September, 31 in October, 30 in November, 31 in December.\n<!-- more -->\nA year is leap in one of two cases: either its number is divisible by 4, but not divisible by 100, or is divisible by 400. For example, the following years are leap: 2000, 2004, but years 1900 and 2018 are not leap.\n\nIn this problem you are given n (1 ≤ n ≤ 24) integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, and you have to check if these integers could be durations in days of n consecutive months, according to Gregorian calendar. Note that these months could belong to several consecutive years. In other words, check if there is a month in some year, such that its duration is a<sub>1</sub> days, duration of the next month is a<sub>2</sub> days, and so on.\n\n#### Input:\nThe first line contains single integer n (1 ≤ n ≤ 24) — the number of integers.\n\nThe second line contains n integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (28 ≤ a<sub>i</sub> ≤ 31) — the numbers you are to check.\n\n#### Output:\nIf there are several consecutive months that fit the sequence, print \"YES\" (without quotes). Otherwise, print \"NO\" (without quotes).\n\nYou can print each letter in arbitrary case (small or large).\n\n#### 範例:\ninput:\n```\n4\n31 31 30 31\n```\noutput:\n```\nYes\n```\ninput:\n```\n2\n30 30\n```\noutput:\n```\nNo\n```\ninput:\n```\n5\n29 31 30 31 30\n```\noutput:\n```\nYes\n```\ninput:\n```\n3\n31 28 30\n```\noutput:\n```\nNo\n```\ninput:\n```\n3\n31 31 28\n```\noutput:\n```\nYes\n```\n#### Note:\nIn the first example the integers can denote months July, August, September and October.\n\nIn the second example the answer is no, because there are no two consecutive months each having 30 days.\n\nIn the third example the months are: February (leap year) — March — April – May — June.\n\nIn the fourth example the number of days in the second month is 28, so this is February. March follows February and has 31 days, but not 30, so the answer is NO.\n\nIn the fifth example the months are: December — January — February (non-leap year).\n\n#### 題意:\n給你一個連續的月份天數，問你這個連續的月份有沒有可能出現？\n\n#### 思路:\n先創一個正常年份的天數陣列，接著是閏年的2月處理，因為只輸入最多24個月(2年)，因此不可能出現兩個閏年，因此紀錄29天的次數，超過1次就不可能。其他情況可以把閏年順移到平年，因此直接把29當28處理，接著將所有月份當起點試試能不能滿足輸入即可。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/a21f1a4f07f6179796e9e9878219b838.js\"></script>\n","tags":["implementation","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 976B","url":"/Lara-Croft-and-the-New-Game/","content":"# Codeforces 976B - Lara Croft and the New Game\n[Lara Croft and the New Game](https://codeforces.com/problemset/problem/976/B)\n\nYou might have heard about the next game in Lara Croft series coming out this year. You also might have watched its trailer. Though you definitely missed the main idea about its plot, so let me lift the veil of secrecy.\n<!-- more -->\nLara is going to explore yet another dangerous dungeon. Game designers decided to use good old 2D environment. The dungeon can be represented as a rectangle matrix of n rows and m columns. Cell (x, y) is the cell in the x-th row in the y-th column. Lara can move between the neighbouring by side cells in all four directions.\n\nMoreover, she has even chosen the path for herself to avoid all the traps. She enters the dungeon in cell (1, 1), that is top left corner of the matrix. Then she goes down all the way to cell (n, 1) — the bottom left corner. Then she starts moving in the snake fashion — all the way to the right, one cell up, then to the left to the cell in 2-nd column, one cell up. She moves until she runs out of non-visited cells. n and m given are such that she always end up in cell (1, 2).\n\nLara has already moved to a neighbouring cell k times. Can you determine her current position?\n\n#### Input:\nThe only line contains three integers n, m and k (2 ≤ n, m ≤ 10<sup>9</sup>, n is always even, 0 ≤ k < n·m). Note that k doesn't fit into 32-bit integer type!\n\n#### Output:\nPrint the cell (the row and the column where the cell is situated) where Lara ends up after she moves k times.\n\n#### 範例:\ninput:\n```\n4 3 0\n```\noutput:\n```\n1 1\n```\ninput:\n```\n4 3 11\n```\noutput:\n```\n1 2\n```\ninput:\n```\n4 3 11\n```\noutput:\n```\n1 2\n```\n#### Note:\nHere is her path on matrix 4 by 3:\n![A](A.PNG)\n#### 題意:\n給你一個矩形棋盤，走法是先走最左邊一排，再蛇行往上。問你在第k步時的座標是多少？\n\n#### 思路:\n先計算是不是在最左邊那排，不是的話再計算他從最下面往上走了幾排又幾格。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/86b71f83f8144585dee9e5ae223c527b.js\"></script>\n\n","tags":["implementation","math","簡單"],"categories":["Codeforces"]},{"title":"Codeforces 38A","url":"/Army/","content":"# Codeforces 38A - Army\n[Army](https://codeforces.com/problemset/problem/38/A)\n\nThe Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.\n<!-- more -->\nOne needs exactly di years to rise from rank i to rank i + 1. Reaching a certain rank i having not reached all the previous i - 1 ranks is impossible.\n\nVasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.\n\n#### Input:\nThe first input line contains an integer n (2 ≤ n ≤ 100). The second line contains n - 1 integers d<sub>i</sub> (1 ≤ d<sub>i</sub> ≤ 100). The third input line contains two integers a and b (1 ≤ a < b ≤ n). The numbers on the lines are space-separated.\n\n#### Output:\nPrint the single number which is the number of years that Vasya needs to rise from rank a to rank b.\n\n#### 範例:\ninput:\n```\n3\n5 6\n1 2\n```\noutput:\n```\n5\n```\ninput:\n```\n3\n5 6\n1 3\n```\noutput:\n```\n11\n```\n#### 題意:\n給你所有階級升級的需要年數，問你從a階升到b階要多少年？\n\n#### 思路:\n直接累加。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/c83a93cdf39d598e109761dbb0bd09f1.js\"></script>\n","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"Codeforces 1077A","url":"/Frog-Jumping/","content":"# Codeforces 1077A - Frog Jumping\n[Frog Jumping](https://codeforces.com/problemset/problem/1077/A)\n\nA frog is currently at the point 0 on a coordinate axis Ox. It jumps by the following algorithm: the first jump is a units to the right, the second jump is b units to the left, the third jump is a units to the right, the fourth jump is b units to the left, and so on.\n<!-- more -->\nFormally:\n>>● if the frog has jumped an even number of times (before the current jump), it jumps from its current position x to position x+a;\n>>● otherwise it jumps from its current position x to position x−b.\nYour task is to calculate the position of the frog after k jumps.\n\nBut... One more thing. You are watching t different frogs so you have to answer t independent queries.\n\n#### Input:\nThe first line of the input contains one integer t (1≤t≤1000) — the number of queries.\n\nEach of the next t lines contain queries (one query per line).\n\nThe query is described as three space-separated integers a,b,k (1≤a,b,k≤10<sup>9</sup>) — the lengths of two types of jumps and the number of jumps, respectively.\n\n#### Output:\nPrint t integers. The i-th integer should be the answer for the i-th query.\n\n#### 範例:\ninput:\n```\n6\n5 2 3\n100 1 4\n1 10 5\n1000000000 1 6\n1 1 1000000000\n1 1 999999999\n```\noutput:\n```\n8\n198\n-17\n2999999997\n0\n1\n```\n\n#### Note:\nIn the first query frog jumps 5 to the right, 2 to the left and 5 to the right so the answer is 5−2+5=8.\n\nIn the second query frog jumps 100 to the right, 1 to the left, 100 to the right and 1 to the left so the answer is 100−1+100−1=198.\n\nIn the third query the answer is 1−10+1−10+1=−17.\n\nIn the fourth query the answer is 10<sup>9</sup>−1+10<sup>9</sup>−1+10<sup>9</sup>−1=2999999997.\n\nIn the fifth query all frog's jumps are neutralized by each other so the answer is 0.\n\nThe sixth query is the same as the fifth but without the last jump so the answer is 1.\n#### 題意:\n青蛙第一次會向右跳a，第二次會向右跳b，問你跳k伺候青蛙位在多少？\n\n#### 思路:\n兩次一組，往右跳a-b。因此偶數就直接算有幾組，奇數就再多加一次往右。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/c8eb39f4bd6f8f38e7543246ec609cf9.js\"></script>\n","tags":["math","新手"],"categories":["Codeforces"]},{"title":"Codeforces 344A","url":"/Magnets/","content":"# Codeforces 344A - Magnets\n[Magnets](https://codeforces.com/problemset/problem/344/A)\n\nMad scientist Mike entertains himself by arranging rows of dominoes. He doesn't need dominoes, though: he uses rectangular magnets instead. Each magnet has two poles, positive (a \"plus\") and negative (a \"minus\"). If two magnets are put together at a close distance, then the like poles will repel each other and the opposite poles will attract each other.\n<!-- more -->\nMike starts by laying one magnet horizontally on the table. During each following step Mike adds one more magnet horizontally to the right end of the row. Depending on how Mike puts the magnet on the table, it is either attracted to the previous one (forming a group of multiple magnets linked together) or repelled by it (then Mike lays this magnet at some distance to the right from the previous one). We assume that a sole magnet not linked to others forms a group of its own.\n![A](A.PNG)\nMike arranged multiple magnets in a row. Determine the number of groups that the magnets formed.\n\n#### Input:\nThe first line of the input contains an integer n (1 ≤ n ≤ 100000) — the number of magnets. Then n lines follow. The i-th line (1 ≤ i ≤ n) contains either characters \"01\", if Mike put the i-th magnet in the \"plus-minus\" position, or characters \"10\", if Mike put the magnet in the \"minus-plus\" position.\n\n#### Output:\nOn the single line of the output print the number of groups of magnets.\n\n#### 範例:\ninput:\n```\n6\n10\n10\n10\n01\n10\n10\n```\noutput:\n```\n3\n```\ninput:\n```\n4\n01\n01\n10\n10\n```\noutput:\n```\n2\n```\n#### Note:\nThe first testcase corresponds to the figure. The testcase has three groups consisting of three, one and two magnets.\n\nThe second testcase has two groups, each consisting of two magnets.\n\n#### 題意:\n輸入N段的磁鐵，相連的可能會吸引在一起，問最後排成一列的磁鐵有幾段？\n\n#### 思路:\n輸入時判斷跟前一個是否一樣，不一樣的不會吸在一起，段數加1。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/7a91611f2f7f3efad84d67e8014ab433.js\"></script>\n","tags":["implementation","新手"],"categories":["Codeforces"]},{"title":"Codeforces 785A","url":"/Anton-and-Polyhedrons/","content":"# Codeforces 785A - Anton and Polyhedrons\n[Anton and Polyhedrons](https://codeforces.com/problemset/problem/785/A)\n\nAnton's favourite geometric figures are regular polyhedrons. Note that there are five kinds of regular polyhedrons:\n<!-- more -->\n>>● Tetrahedron. Tetrahedron has 4 triangular faces.\n>>● Cube. Cube has 6 square faces.\n>>● Octahedron. Octahedron has 8 triangular faces.\n>>● Dodecahedron. Dodecahedron has 12 pentagonal faces.\n>>● Icosahedron. Icosahedron has 20 triangular faces.\nAll five kinds of polyhedrons are shown on the picture below:\n![A](A.PNG)\nAnton has a collection of n polyhedrons. One day he decided to know, how many faces his polyhedrons have in total. Help Anton and find this number!\n\n#### Input:\nThe first line of the input contains a single integer n (1 ≤ n ≤ 200 000) — the number of polyhedrons in Anton's collection.\nEach of the following n lines of the input contains a string s<sub>i</sub> — the name of the i-th polyhedron in Anton's collection. \nThe string can look like this:\n>>● \"Tetrahedron\" (without quotes), if the i-th polyhedron in Anton's collection is a tetrahedron.\n>>● \"Cube\" (without quotes), if the i-th polyhedron in Anton's collection is a cube.\n>>● \"Octahedron\" (without quotes), if the i-th polyhedron in Anton's collection is an octahedron.\n>>● \"Dodecahedron\" (without quotes), if the i-th polyhedron in Anton's collection is a dodecahedron.\n>>● \"Icosahedron\" (without quotes), if the i-th polyhedron in Anton's collection is an icosahedron.\n\n#### Output:\nOutput one number — the total number of faces in all the polyhedrons in Anton's collection.\n\n#### 範例:\ninput:\n```\n4\nIcosahedron\nCube\nTetrahedron\nDodecahedron\n```\noutput:\n```\n42\n```\ninput:\n```\n3\nDodecahedron\nOctahedron\nOctahedron\n```\noutput:\n```\n28\n```\n\n#### Note:\nIn the first sample Anton has one icosahedron, one cube, one tetrahedron and one dodecahedron. Icosahedron has 20 faces, cube has 6faces, tetrahedron has 4 faces and dodecahedron has 12 faces. In total, they have 20 + 6 + 4 + 12 = 42 faces.\n\n#### 題意:\n計算輸入的多面體總共面數是多少？\n\n#### 思路:\n根據輸入的字串累加對應的面即可。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/549840b54864ea08c6b80c319837adee.js\"></script>\n","tags":["implementation","strings","新手"],"categories":["Codeforces"]},{"title":"Codeforces 302B","url":"/Eugeny-and-Play-List/","content":"# Codeforces 302B - Eugeny and Play List\n[Eugeny and Play List](https://codeforces.com/problemset/problem/302/B)\n\nEugeny loves listening to music. He has n songs in his play list. We know that song number i has the duration of t<sub>i</sub> minutes. Eugeny listens to each song, perhaps more than once. He listens to song number i c<sub>i</sub> times. Eugeny's play list is organized as follows: first song number 1 plays c<sub>1</sub> times, then song number 2 plays c<sub>2</sub> times, ..., in the end the song number n plays cn times.\n<!-- more -->\nEugeny took a piece of paper and wrote out m moments of time when he liked a song. Now for each such moment he wants to know the number of the song that played at that moment. The moment x means that Eugeny wants to know which song was playing during the x-th minute of his listening to the play list.\n\nHelp Eugeny and calculate the required numbers of songs.\n\n#### Input:\nThe first line contains two integers n, m (1 ≤ n, m ≤ 10<sup>5</sup>). The next n lines contain pairs of integers. The i-th line contains integers c<sub>i</sub>, t<sub>i</sub> (1 ≤ c<sub>i</sub>, t<sub>i</sub> ≤ 10<sup>9</sup>) — the description of the play list. It is guaranteed that the play list's total duration doesn't exceed 10<sup>9</sup>.\n\nThe next line contains m positive integers v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>m</sub>, that describe the moments Eugeny has written out. It is guaranteed that there isn't such moment of time v<sub>i</sub>, when the music doesn't play any longer. It is guaranteed that v<sub>i</sub> < v<sub>i</sub> + 1 (i < m).\n\nThe moment of time v<sub>i</sub> means that Eugeny wants to know which song was playing during the v<sub>i</sub>-th munite from the start of listening to the playlist.\n\n#### Output:\nPrint m integers — the i-th number must equal the number of the song that was playing during the v<sub>i</sub>-th minute after Eugeny started listening to the play list.\n\n#### 範例:\ninput:\n```\n1 2\n2 8\n1 16\n```\noutput:\n```\n1\n1\n```\ninput:\n```\n4 9\n1 2\n2 1\n1 1\n2 2\n1 2 3 4 5 6 7 8 9\n```\noutput:\n```\n1\n1\n2\n2\n3\n4\n4\n4\n4\n```\n\n#### 題意:\n現在有n首歌，每首歌會撥放ci次，每次ti分鐘長，當聽到喜歡的歌時會做下筆記。現在有m次做下筆記的時間，問你這m次分別是第幾首歌？\n\n#### 思路:\n先做出每首歌的累加長度陣列，再對每次的筆記在陣列中做二分搜尋即可。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/a131929a6eff93a0bb4e3e48f44ce349.js\"></script>\n\n","tags":["CodeForces","普通","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 195A","url":"/Let-s-Watch-Football/","content":"# Codeforces 195A - Let's Watch Football\n[Let's Watch Football](https://codeforces.com/problemset/problem/195/A)\n\nValeric and Valerko missed the last Euro football game, so they decided to watch the game's key moments on the Net. They want to start watching as soon as possible but the connection speed is too low. If they turn on the video right now, it will \"hang up\" as the size of data to watch per second will be more than the size of downloaded data per second.\n<!-- more -->\nThe guys want to watch the whole video without any pauses, so they have to wait some integer number of seconds for a part of the video to download. After this number of seconds passes, they can start watching. Waiting for the whole video to download isn't necessary as the video can download after the guys started to watch.\n\nLet's suppose that video's length is c seconds and Valeric and Valerko wait t seconds before the watching. Then for any moment of time t<sub>0</sub>, t ≤ t<sub>0</sub> ≤ c + t, the following condition must fulfill: the size of data received in t<sub>0</sub> seconds is not less than the size of data needed to watch t<sub>0</sub> - t seconds of the video.\n\nOf course, the guys want to wait as little as possible, so your task is to find the minimum integer number of seconds to wait before turning the video on. The guys must watch the video without pauses.\n\n#### Input:\nThe first line contains three space-separated integers a, b and c (1 ≤ a, b, c ≤ 1000, a > b). The first number (a) denotes the size of data needed to watch one second of the video. The second number (b) denotes the size of data Valeric and Valerko can download from the Net per second. The third number (c) denotes the video's length in seconds.\n\n#### Output:\nPrint a single number — the minimum integer number of seconds that Valeric and Valerko must wait to watch football without pauses.\n\n#### 範例:\ninput:\n```\n4 1 1\n```\noutput:\n```\n3\n```\ninput:\n```\n10 3 2\n```\noutput:\n```\n5\n```\ninput:\n```\n13 12 1\n```\noutput:\n```\n1\n```\n#### Note:\nIn the first sample video's length is 1 second and it is necessary 4 units of data for watching 1 second of video, so guys should download 4 · 1 = 4 units of data to watch the whole video. The most optimal way is to wait 3 seconds till 3 units of data will be downloaded and then start watching. While guys will be watching video 1 second, one unit of data will be downloaded and Valerik and Valerko will have 4 units of data by the end of watching. Also every moment till the end of video guys will have more data then necessary for watching.\n\nIn the second sample guys need 2 · 10 = 20 units of data, so they have to wait 5 seconds and after that they will have 20 units before the second second ends. However, if guys wait 4 seconds, they will be able to watch first second of video without pauses, but they will download 18 units of data by the end of second second and it is less then necessary.\n\n#### 題意:\n現在想看網路影片，但是撥放需要的流量(每秒A)比下載需要的流量(每秒B)還大，但是他們可以先等t秒，然後再開始看總長C秒的影片，問你t最少是多少？\n\n#### 思路:\n要找的是當(A*C <= B* (C + t))的最小t，因此用二分搜尋找0~(A * C / B + 1)就好。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/0d3a4bd6acd4ec4bf08cf6f7bb206f7c.js\"></script>\n\n","tags":["CodeForces","普通","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 967B","url":"/Watering-System/","content":"# Codeforces 967B - Watering System\n[Watering System](https://codeforces.com/problemset/problem/967/B)\n\nArkady wants to water his only flower. Unfortunately, he has a very poor watering system that was designed for n flowers and so it looks like a pipe with n holes. Arkady can only use the water that flows from the first hole.\n<!-- more -->\nArkady can block some of the holes, and then pour A liters of water into the pipe. After that, the water will flow out from the non-blocked holes proportionally to their sizes s<sub>1</sub>,s<sub>2</sub>,…,s<sub>n</sub>. In other words, if the sum of sizes of non-blocked holes is S, and the i-th hole is not blocked, (s<sub>i</sub>*A)/S liters of water will flow out of it.\n\nWhat is the minimum number of holes Arkady should block to make at least B liters of water flow out of the first hole?\n\n#### Input:\nThe first line contains three integers n, A, B (1≤n≤100000, 1≤B≤A≤10<sup>4</sup>) — the number of holes, the volume of water Arkady will pour into the system, and the volume he wants to get out of the first hole.\n\nThe second line contains n integers s<sub>1</sub>,s<sub>2</sub>,…,s<sub>n</sub> (1≤s<sub>i</sub>≤10<sup>4</sup>) — the sizes of the holes.\n\n#### Output:\nPrint a single integer — the number of holes Arkady should block.\n\n#### 範例:\ninput:\n```\n4 10 3\n2 2 2 2\n```\noutput:\n```\n1\n```\ninput:\n```\n4 80 20\n3 2 1 4\n```\noutput:\n```\n0\n```\ninput:\n```\n5 10 10\n1000 1 1 1 1\n```\noutput:\n```\n4\n```\n#### Note:\nIn the first example Arkady should block at least one hole. After that, (10*2)/6≈3.333 liters of water will flow out of the first hole, and that suits Arkady.\n\nIn the second example even without blocking any hole, (80*3)/10=24 liters will flow out of the first hole, that is not less than 20.\n\nIn the third example Arkady has to block all holes except the first to make all water flow out of the first hole.\n\n#### 題意:\n現在有A公升的水，會流到n個洞中，每個洞的流量會根據佔洞口的總尺寸比例而佔據等比例的流量，現在問你假設1號洞要流過B公升以上的水時，最少要把幾個洞堵起來？\n\n#### 思路:\n為了讓1號洞的流量上升，就必須要把其他洞堵起來，而堵的洞愈大，就會因為佔總面積愈大上升的愈多，因此將2~n號洞排序後由大的開始堵。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/90d9bdcc8d2015c0ddf60c339600b94f.js\"></script>\n\n","tags":["sortings","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 992A","url":"/Nastya-and-an-Array/","content":"# Codeforces 992A - Nastya and an Array\n[Nastya and an Array](https://codeforces.com/problemset/problem/992/A)\n\nNastya owns too many arrays now, so she wants to delete the least important of them. However, she discovered that this array is magic! Nastya now knows that the array has the following properties:\n<!-- more -->\nIn one second we can add an arbitrary (possibly negative) integer to all elements of the array that are not equal to zero.\nWhen all elements of the array become equal to zero, the array explodes.\nNastya is always busy, so she wants to explode the array as fast as possible. Compute the minimum time in which the array can be exploded.\n\n#### Input:\nThe first line contains a single integer n (1 ≤ n ≤ 10<sup>5</sup>) — the size of the array.\n\nThe second line contains n integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> ( - 10<sup>5</sup> ≤ a<sub>i<sub> ≤ 10<sup>5</sup>) — the elements of the array.\n\n#### Output:\nPrint a single integer — the minimum number of seconds needed to make all elements of the array equal to zero.\n\n#### 範例:\ninput:\n```\n5\n1 1 1 1 1\n```\noutput:\n```\n1\n```\ninput:\n```\n3\n2 0 -1\n```\noutput:\n```\n2\n```\ninput:\n```\n4\n5 -6 -5 1\n```\noutput:\n```\n4\n```\n#### Note:\nIn the first example you can add  - 1 to all non-zero elements in one second and make them equal to zero.\n\nIn the second example you can add  - 2 on the first second, then the array becomes equal to [0, 0,  - 3]. On the second second you can add 3 to the third (the only non-zero) element.\n\n#### 題意:\n現在一次行動可以將一個陣列的非0數字都加上某個數字，問你需要幾次行動才能將陣列全部歸0？\n\n#### 思路:\n題目等於是判斷現在陣列裡面有幾種數字，因此將陣列排序後，判斷非0的數字有幾種。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/7560d8637db8515e9a9320738b5bcace.js\"></script>\n\n","tags":["sortings","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 313A","url":"/Ilya-and-Bank-Account/","content":"# Codeforces 313A - Ilya and Bank Account\n[Ilya and Bank Account](https://codeforces.com/problemset/problem/313/A)\n\nIlya is a very clever lion, he lives in an unusual city ZooVille. In this city all the animals have their rights and obligations. Moreover, they even have their own bank accounts. The state of a bank account is an integer. The state of a bank account can be a negative number. This means that the owner of the account owes the bank money.\n<!-- more -->\nIlya the Lion has recently had a birthday, so he got a lot of gifts. One of them (the gift of the main ZooVille bank) is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once. For example, if the state of Ilya's bank account is -123, then Ilya can delete the last digit and get his account balance equal to -12, also he can remove its digit before last and get the account balance equal to -13. Of course, Ilya is permitted not to use the opportunity to delete a digit from the balance.\n\nIlya is not very good at math, and that's why he asks you to help him maximize his bank account. Find the maximum state of the bank account that can be obtained using the bank's gift.\n\n#### Input:\nThe single line contains integer n (10 ≤ |n| ≤ 10<sup>9</sup>) — the state of Ilya's bank account.\n\n#### Output:\nIn a single line print an integer — the maximum state of the bank account that Ilya can get.\n\n#### 範例:\ninput:\n```\n2230\n```\noutput:\n```\n2230\n```\ninput:\n```\n-10\n```\noutput:\n```\n0\n```\ninput:\n```\n-100003\n```\noutput:\n```\n-10000\n```\n#### Note:\nIn the first test sample Ilya doesn't profit from using the present.\n\nIn the second test sample you can delete digit 1 and get the state of the account equal to 0.\n\n#### 題意:\n現在可以將一個數字的最後一位或最後第二位去掉，問你最後數字最大的可能性是多少？\n\n#### 思路:\n大於0的就不用去掉了，不會比較大；負的就兩種都試，挑大的。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/aedaa10ae14ccf681566a4ffaaf98a53.js\"></script>\n\n","tags":["implementation","CodeForces","新手"],"categories":["Codeforces"]},{"title":"Codeforces 136A","url":"/Presents/","content":"# Codeforces 136A - Presents\n[Presents](https://codeforces.com/problemset/problem/136/A)\n\nLittle Petya very much likes gifts. Recently he has received a new laptop as a New Year gift from his mother. He immediately decided to give it to somebody else as what can be more pleasant than giving somebody gifts. And on this occasion he organized a New Year party at his place and invited n his friends there.\n<!-- more -->\nIf there's one thing Petya likes more that receiving gifts, that's watching others giving gifts to somebody else. Thus, he safely hid the laptop until the next New Year and made up his mind to watch his friends exchanging gifts while he does not participate in the process. He numbered all his friends with integers from 1 to n. Petya remembered that a friend number i gave a gift to a friend number p<sub>i</sub>. He also remembered that each of his friends received exactly one gift.\n\nNow Petya wants to know for each friend i the number of a friend who has given him a gift.\n\n#### Input:\nThe first line contains one integer n (1 ≤ n ≤ 100) — the quantity of friends Petya invited to the party. The second line contains n space-separated integers: the i-th number is p<sub>i</sub> — the number of a friend who gave a gift to friend number i. It is guaranteed that each friend received exactly one gift. It is possible that some friends do not share Petya's ideas of giving gifts to somebody else. Those friends gave the gifts to themselves.\n\n#### Output:\nPrint n space-separated integers: the i-th number should equal the number of the friend who gave a gift to friend number i.\n\n#### 範例:\ninput:\n```\n4\n2 3 4 1\n```\noutput:\n```\n4 1 2 3\n```\ninput:\n```\n3\n1 3 2\n```\noutput:\n```\n1 3 2\n```\ninput:\n```\n2\n1 2\n```\noutput:\n```\n1 2\n```\n\n#### 題意:\n每個人都會送禮給人，可以送給自己，並保證每個人都會收到一份禮物，現在問收到的禮物是誰送的？\n\n#### 思路:\n創一個陣列紀錄來源就好。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/6781fdcf78ff6632f995a1b145d9bb3e.js\"></script>\n\n","tags":["implementation","CodeForces","新手"],"categories":["Codeforces"]},{"title":"Codeforces 1099B","url":"/Squares-and-Segments/","content":"# Codeforces 1099B - Squares and Segments\n[Squares and Segments](https://codeforces.com/problemset/problem/1099/B)\n\nLittle Sofia is in fourth grade. Today in the geometry lesson she learned about segments and squares. On the way home, she decided to draw n squares in the snow with a side length of 1. For simplicity, we assume that Sofia lives on a plane and can draw only segments of length 1, parallel to the coordinate axes, with vertices at integer points.\n<!-- more -->\nIn order to draw a segment, Sofia proceeds as follows. If she wants to draw a vertical segment with the coordinates of the ends (x,y)and (x,y+1). Then Sofia looks if there is already a drawn segment with the coordinates of the ends (x′,y) and (x′,y+1) for some x′. If such a segment exists, then Sofia quickly draws a new segment, using the old one as a guideline. If there is no such segment, then Sofia has to take a ruler and measure a new segment for a long time. Same thing happens when Sofia wants to draw a horizontal segment, but only now she checks for the existence of a segment with the same coordinates x, x+1 and the differing coordinate y.\n\nFor example, if Sofia needs to draw one square, she will have to draw two segments using a ruler: \n![A](A.png)\nAfter that, she can draw the remaining two segments, using the first two as a guide: \n![B](B.PNG)\nIf Sofia needs to draw two squares, she will have to draw three segments using a ruler: \n![C](C.PNG)\nAfter that, she can draw the remaining four segments, using the first three as a guide: \n![D](D.PNG)\nSofia is in a hurry, so she wants to minimize the number of segments that she will have to draw with a ruler without a guide. Help her find this minimum number.\n\n#### Input:\nThe only line of input contains a single integer n (1≤n≤10<sup>9</sup>), the number of squares that Sofia wants to draw.\n\n#### Output:\nPrint single integer, the minimum number of segments that Sofia will have to draw with a ruler without a guide in order to draw n squares in the manner described above.\n\n#### 範例:\ninput:\n```\n1\n```\noutput:\n```\n2\n```\ninput:\n```\n2\n```\noutput:\n```\n3\n```\ninput:\n```\n4\n```\noutput:\n```\n4\n```\n\n#### Note:\n\n#### 題意:\n現在可以用手畫長度為1的垂直或水平線段，並且畫了之後可以用工具複製它的平行線段，當現在要畫n個正方形的時候問你最少需要用手畫幾條線段？\n\n#### 思路:\n可以用二分搜尋法或是用數學方法求解。\n\n二分搜尋法:\n先求得𝐾=2⌈√𝑛⌉，即是搜尋上限，接著以二分搜尋法搜尋0~K，mid為偶數時最多有個(𝑚𝑖𝑑/2)<sup>2</sup>方形，奇數時最多有個𝑚𝑖𝑑/2×(𝑚𝑖𝑑+1)/2方形。\n\n數學方法:\n線段跟方形的增加關係如下圖，因此題測資不夠大，可以直接硬解。\n![E](E.png)\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/040f422ce2524c8cbb5ca11da07ec0e4.js\"></script>\n\n","tags":["math","CodeForces","普通","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 706B","url":"/Interesting-drink/","content":"# Codeforces 706B - Interesting drink\n[Interesting drink](https://codeforces.com/problemset/problem/706/B)\n\nVasiliy likes to rest after a hard work, so you may often meet him in some bar nearby. As all programmers do, he loves the famous drink \"Beecola\", which can be bought in n different shops in the city. It's known that the price of one bottle in the shop i is equal to x<sub>i</sub> coins.\n<!-- more -->\nVasiliy plans to buy his favorite drink for q consecutive days. He knows, that on the i-th day he will be able to spent m<sub>i</sub> coins. Now, for each of the days he want to know in how many different shops he can buy a bottle of \"Beecola\".\n\n#### Input:\nThe first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of shops in the city that sell Vasiliy's favourite drink.\n\nThe second line contains n integers xi (1 ≤ x<sub>i</sub> ≤ 100 000) — prices of the bottles of the drink in the i-th shop.\n\nThe third line contains a single integer q (1 ≤ q ≤ 100 000) — the number of days Vasiliy plans to buy the drink.\n\nThen follow q lines each containing one integer mi (1 ≤ m<sub>i</sub> ≤ 10<sup>9</sup>) — the number of coins Vasiliy can spent on the i-th day.\n#### Output:\nPrint q integers. The i-th of them should be equal to the number of shops where Vasiliy will be able to buy a bottle of the drink on the i-th day.\n#### 範例:\ninput:\n```\n5\n3 10 8 6 11\n4\n1\n10\n3\n11\n```\noutput:\n```\n0\n4\n1\n5\n```\n\n#### Note:\nOn the first day, Vasiliy won't be able to buy a drink in any of the shops.\n\nOn the second day, Vasiliy can buy a drink in the shops 1, 2, 3 and 4.\n\nOn the third day, Vasiliy can buy a drink only in the shop number 1.\n\nFinally, on the last day Vasiliy can buy a drink in any shop.\n\n#### 題意:\n現在有n間商店，各自賣蜜蜂可樂xi元，你知道你接下來q天會各自有mi元，沒花完不會累積，問每一天有幾間商店是買得起的？\n\n#### 思路:\n先將n間商店依售價從小排到大，接下來輸入每個mi時做二分搜尋法即可。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/a67e4431ea72f8dae5ebc9b935fa6b50.js\"></script>\n","tags":["sortings","CodeForces","普通","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 1138A","url":"/Sushi-for-Two/","content":"# Codeforces 1138A - Sushi for Two\n[Sushi for Two](https://codeforces.com/problemset/problem/1138/A)\n\nArkady invited Anna for a dinner to a sushi restaurant. The restaurant is a bit unusual: it offers n pieces of sushi aligned in a row, and a customer has to choose a continuous subsegment of these sushi to buy.\n<!-- more -->\nThe pieces of sushi are of two types: either with tuna or with eel. Let's denote the type of the i-th from the left sushi as t<sub>i</sub>, where t<sub>i</sub>=1 means it is with tuna, and t<sub>i</sub>=2 means it is with eel.\n\nArkady does not like tuna, Anna does not like eel. Arkady wants to choose such a continuous subsegment of sushi that it has equal number of sushi of each type and each half of the subsegment has only sushi of one type. For example, subsegment [2,2,2,1,1,1] is valid, but subsegment [1,2,1,2,1,2] is not, because both halves contain both types of sushi.\n\nFind the length of the longest continuous subsegment of sushi Arkady can buy.\n\n#### Input:\nThe first line contains a single integer n (2≤n≤100000) — the number of pieces of sushi.\n\nThe second line contains nintegers t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>n</sub> (t<sub>i</sub>=1, denoting a sushi with tuna or t<sub>i</sub>=2, denoting a sushi with eel), representing the types of sushi from left to right.\n\nIt is guaranteed that there is at least one piece of sushi of each type. Note that it means that there is at least one valid continuous segment.\n#### Output:\nPrint a single integer — the maximum length of a valid continuous segment.\n\n#### 範例:\ninput:\n```\n7\n2 2 2 1 1 2 2\n```\noutput:\n```\n4\n```\ninput:\n```\n6\n1 2 1 2 1 2\n```\noutput:\n```\n2\n```\ninput:\n```\n9\n2 2 1 1 1 2 2 2 2\n```\noutput:\n```\n6\n```\n#### Note:\nIn the first example Arkady can choose the subsegment [2,2,1,1] or the subsegment [1,1,2,2] with length 4.\n\nIn the second example there is no way but to choose one of the subsegments [2,1] or [1,2] with length 2.\n\nIn the third example Arkady's best choice is the subsegment [1,1,1,2,2,2].\n\n#### 題意:\n2個人去吃壽司，台上只有一排n個的壽司，有鮪魚和鰻魚兩種，壽司店只願意賣連續的一組壽司。其中一個人只想吃鮪魚，另一個人只想吃鰻魚，而且還希望能剛好每個半邊都是一樣的壽司方便分配，問你他們可以買的壽司最長是幾個？\n\n#### 思路:\n用二分搜尋法搜尋寬度，要注意的是長度必須是偶數，因此先將搜尋上限調整至大於等於n的2的冪次方較方便。確定可不可以的時候使用雙指標的方法搜尋較為快速。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/88d3e3247eccead6d05d0232156e110e.js\"></script>\n\n","tags":["CodeForces","普通","two pointers","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 261A","url":"/Maxim-and-Discounts/","content":"# Codeforces 261A - Maxim and Discounts\n[Maxim and Discounts](https://codeforces.com/problemset/problem/261/A)\n\nMaxim always goes to the supermarket on Sundays. Today the supermarket has a special offer of discount systems.\n<!-- more -->\nThere are m types of discounts. We assume that the discounts are indexed from 1 to m. To use the discount number i, the customer takes a special basket, where he puts exactly q<sub>i</sub> items he buys. Under the terms of the discount system, in addition to the items in the cart the customer can receive at most two items from the supermarket for free. The number of the \"free items\" (0, 1 or 2) to give is selected by the customer. The only condition imposed on the selected \"free items\" is as follows: each of them mustn't be more expensive than the cheapest item out of the q<sub>i</sub> items in the cart.\n\nMaxim now needs to buy n items in the shop. Count the minimum sum of money that Maxim needs to buy them, if he use the discount system optimally well.\n\nPlease assume that the supermarket has enough carts for any actions. Maxim can use the same discount multiple times. Of course, Maxim can buy items without any discounts.\n\n#### Input:\nThe first line contains integer m (1 ≤ m ≤ 105) — the number of discount types. The second line contains m integers: q1, q2, ..., qm (1 ≤ qi ≤ 105).\n\nThe third line contains integer n (1 ≤ n ≤ 105) — the number of items Maxim needs. The fourth line contains n integers: a1, a2, ..., an (1 ≤ ai ≤ 104) — the items' prices.\n\nThe numbers in the lines are separated by single spaces.\n\n#### Output:\nIn a single line print a single integer — the answer to the problem.\n\n#### 範例:\ninput:\n```\n1\n2\n4\n50 50 100 100\n```\noutput:\n```\n200\n```\ninput:\n```\n2\n2 3\n5\n50 50 50 50 50\n```\noutput:\n```\n150\n```\ninput:\n```\n1\n1\n7\n1 1 1 1 1 1 1\n```\noutput:\n```\n3\n```\n#### Note:\nIn the first sample Maxim needs to buy two items that cost 100 and get a discount for two free items that cost 50. In that case, Maxim is going to pay 200.\n\nIn the second sample the best strategy for Maxim is to buy 3 items and get 2 items for free using the discount. In that case, Maxim is going to pay 150.\n\n#### 題意:\n現在有m種折扣，可以在買了qi個東西後免費拿最多2個各自單價不超過這qi個東西中最低單價東西的東西，折扣可以重複使用。想買的東西有n個，各自的單價是ai，問你買這n個東西最少的花費是多少？\n\n#### 思路:\n因為折扣可以重複使用，所以只要挑一個需要買最少的就好了，然後將n個東西從貴排到便宜，依序購買即可。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/284debb4252f7dc5f76255af89e079de.js\"></script>\n\n","tags":["sortings","greedy","CodeForces","普通","CHU Training"],"categories":["Codeforces"]},{"title":"Codeforces 1015C","url":"/Songs-Compression/","content":"# Codeforces 1015C - Songs Compression\n[Songs Compression](https://codeforces.com/problemset/problem/1015/C)\n\nIvan has n songs on his phone. The size of the i-th song is a<sub>i</sub> bytes. Ivan also has a flash drive which can hold at most m bytes in total. Initially, his flash drive is empty.\n<!-- more -->\nIvan wants to copy all n songs to the flash drive. He can compress the songs. If he compresses the i-th song, the size of the i-th song reduces from a<sub>i</sub> to b<sub>i</sub> bytes (b<sub>i</sub> < a<sub>i</sub>).\n\nIvan can compress any subset of the songs (possibly empty) and copy all the songs to his flash drive if the sum of their sizes is at most m. He can compress any subset of the songs (not necessarily contiguous).\n\nIvan wants to find the minimum number of songs he needs to compress in such a way that all his songs fit on the drive (i.e. the sum of their sizes is less than or equal to m).\n\nIf it is impossible to copy all the songs (even if Ivan compresses all the songs), print \"-1\". Otherwise print the minimum number of songs Ivan needs to compress.\n\n#### Input:\nThe first line of the input contains two integers n and m (1≤n≤10<sup>5</sup>,1≤m≤10<sup>9</sup>) — the number of the songs on Ivan's phone and the capacity of Ivan's flash drive.\n\nThe next n lines contain two integers each: the i-th line contains two integers ai and bi (1≤a<sub>i</sub>,b<sub>i</sub>≤10<sup>9</sup>, a<sub>i</sub>>b<sub>i</sub>) — the initial size of the i-th song and the size of the i-th song after compression.\n\n#### Output:\nIf it is impossible to compress a subset of the songs in such a way that all songs fit on the flash drive, print \"-1\". Otherwise print the minimum number of the songs to compress.\n\n#### 範例:\ninput:\n```\n4 21\n10 8\n7 4\n3 1\n5 4\n```\noutput:\n```\n2\n```\ninput:\n```\n4 16\n10 8\n7 4\n3 1\n5 4\n```\noutput:\n```\n-1\n```\n\n#### Note:\nIn the first example Ivan can compress the first and the third songs so after these moves the sum of sizes will be equal to 8+7+1+5=21≤21. Also Ivan can compress the first and the second songs, then the sum of sizes will be equal 8+4+3+5=20≤21. Note that compressing any single song is not sufficient to copy all the songs on the flash drive (for example, after compressing the second song the sum of sizes will be equal to 10+4+3+5=22>21).\n\nIn the second example even if Ivan compresses all the songs the sum of sizes will be equal 8+4+1+4=17>16\n.\n#### 題意:\n現在有n首歌，要放進容量為m的隨身碟裡，考慮到容量問題，歌可以進行壓縮，從原本的容量ai壓縮成bi，現在問你最少要壓縮幾首歌才能將歌全部塞進隨身碟中，或是不可能塞進去？\n\n#### 思路:\n先將a加總，得到未壓縮的總容量max；將b加總，得到全壓縮的總容量min。當max<=m時無須壓縮；當min>m時不可能；剩下的情況將每1首歌的壓縮容量差距記起來，依差距從大排到小，從差距大的開始壓縮，壓縮到容量可以後停止就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/d228c2a19a77b9da421e25e87cd3e3d9.js\"></script>\n\n","tags":["sortings","greedy","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 216B","url":"/Teams-Forming/","content":"# Codeforces 216B - Teams Forming\n[Teams Forming](https://codeforces.com/problemset/problem/216/B)\n\nOne day n students come to the stadium. They want to play football, and for that they need to split into teams, the teams must have an equal number of people.\n<!-- more -->\nWe know that this group of people has archenemies. Each student has at most two archenemies. Besides, if student A is an archenemy to student B, then student B is an archenemy to student A.\n\nThe students want to split so as no two archenemies were in one team. If splitting in the required manner is impossible, some students will have to sit on the bench.\n\nDetermine the minimum number of students you will have to send to the bench in order to form the two teams in the described manner and begin the game at last.\n\n#### Input:\nThe first line contains two integers n and m (2 ≤ n ≤ 100, 1 ≤ m ≤ 100) — the number of students and the number of pairs of archenemies correspondingly.\n\nNext m lines describe enmity between students. Each enmity is described as two numbers ai and bi (1 ≤ a<sub>i</sub>, b<sub>i</sub> ≤ n, a<sub>i</sub> ≠ b<sub>i</sub>) — the indexes of the students who are enemies to each other. Each enmity occurs in the list exactly once. It is guaranteed that each student has no more than two archenemies.\n\n#### Output:\nPrint a single integer — the minimum number of students you will have to send to the bench in order to start the game.\n\n#### 範例:\ninput:\n```\n5 4\n1 2\n2 4\n5 3\n1 4\n```\noutput:\n```\n1\n```\ninput:\n```\n6 2\n1 4\n3 4\n```\noutput:\n```\n0\n```\ninput:\n```\n6 6\n1 2\n2 3\n3 1\n4 5\n5 6\n6 4\n```\noutput:\n```\n2\n```\n\n#### 題意:\nn個學生要分成n/2組，每1組保證正好2個人，每個人都有各自的程式技能等級ai，你可以挑1個人來解掉1題題目讓他的程式技能等級提升1級，現在問你最少要讓學生總共解掉多少題目來使得每一組的2個人間彼此的程式技能等級都是一樣的？\n\n#### 思路:\n把所有人依技能等級從大到小排序，兩兩一組，把低的拉到跟高的一樣，加總差距就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/bc6568329876e43c5ddbf19948035b6f.js\"></script>\n\n","tags":["sortings","greedy","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 812A","url":"/Sagheer-and-Crossroads/","content":"# Codeforces 812A - Sagheer and Crossroads\n[Sagheer and Crossroads](https://codeforces.com/problemset/problem/812/A)\n\nSagheer is walking in the street when he comes to an intersection of two roads. Each road can be represented as two parts where each part has 3 lanes getting into the intersection (one for each direction) and 3 lanes getting out of the intersection, so we have 4 parts in total. Each part has 4 lights, one for each lane getting into the intersection (l — left, s — straight, r — right) and a light p for a pedestrian crossing. \n<!-- more -->\n![A](A.PNG)\nAn accident is possible if a car can hit a pedestrian. This can happen if the light of a pedestrian crossing of some part and the light of a lane that can get to or from that same part are green at the same time.\n\nNow, Sagheer is monitoring the configuration of the traffic lights. Your task is to help him detect whether an accident is possible.\n\n#### Input:\nThe input consists of four lines with each line describing a road part given in a counter-clockwise order.\n\nEach line contains four integers l, s, r, p — for the left, straight, right and pedestrian lights, respectively. The possible values are 0 for red light and 1 for green light.\n\n#### Output:\nOn a single line, print \"YES\" if an accident is possible, and \"NO\" otherwise.\n\n#### 範例:\ninput:\n```\n1 0 0 1\n0 1 0 0\n0 0 1 0\n0 0 0 1\n```\noutput:\n```\nYES\n```\ninput:\n```\n0 1 1 0\n1 0 1 0\n1 1 0 0\n0 0 0 1\n```\noutput:\n```\nNO\n```\ninput:\n```\n1 0 0 0\n0 0 0 1\n0 0 0 0\n1 0 1 0\n```\noutput:\n```\nNO\n```\n\n#### Note:\nIn the first example, some accidents are possible because cars of part 1 can hit pedestrians of parts 1 and 4. Also, cars of parts 2 and 3 can hit pedestrians of part 4.\n\nIn the second example, no car can pass the pedestrian crossing of part 4 which is the only green pedestrian light. So, no accident can occur.\n\n#### 題意:\n有個十字路口，每個路口都用l、r、s、p的4個狀態表示3個車道加1個行人穿越道的燈號狀態，1表示綠燈；0表示紅燈。從南開始逆時針依序輸入四個路口的燈號狀態，問你有沒有路口有可能發生人跟車的事故？\n\n#### 思路:\n依序比較每個方向的每個車道跟目的地的行人穿越道的燈號就可以了。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/7144cb5d6c8af5c7db3a1405a970a185.js\"></script>\n","tags":["implementation","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 124A","url":"/The-number-of-positions/","content":"# Codeforces 124A - The number of positions\n[The number of positions](https://codeforces.com/problemset/problem/124/A)\n\nPetr stands in line of n people, but he doesn't know exactly which position he occupies. He can say that there are no less than a people standing in front of him and no more than b people standing behind him. Find the number of different positions Petr can occupy.\n<!-- more -->\n#### Input:\nThe only line contains three integers n, a and b (0 ≤ a, b < n ≤ 100).\n\n#### Output:\nPrint the single number — the number of the sought positions.\n\n#### 範例:\ninput:\n```\n3 1 1\n```\noutput:\n```\n2\n```\ninput:\n```\n5 2 3\n```\noutput:\n```\n3\n```\n\n#### Note:\nThe possible positions in the first sample are: 2 and 3 (if we number the positions starting with 1).\n\nIn the second sample they are 3, 4 and 5.\n\n#### 題意:\n在n個人的隊列中，他前面有不小於a個的人；後面有不多於b個的人，問你他有幾個可能的位置？\n\n#### 思路:\n將隊列以編號[1,n]來看，則前面有不小於a個的人表示他在[a+1,n]的位置；後面有不多於b個的人表示他在[n-b,n]的位置，取兩者的交集即可。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/7d368f649a7201e7031fea98970cb0bf.js\"></script>\n\n","tags":["math","CodeForces","新手"],"categories":["Codeforces"]},{"title":"Codeforces 426A","url":"/Sereja-and-Mugs/","content":"# Codeforces 426A - Sereja and Mugs\n[Sereja and Mugs](https://codeforces.com/problemset/problem/426/A)\n\nSereja showed an interesting game to his friends. The game goes like that. Initially, there is a table with an empty cup and n water mugs on it. Then all players take turns to move. During a move, a player takes a non-empty mug of water and pours all water from it into the cup. If the cup overfills, then we assume that this player lost.\n<!-- more -->\nAs soon as Sereja's friends heard of the game, they wanted to play it. Sereja, on the other hand, wanted to find out whether his friends can play the game in such a way that there are no losers. You are given the volumes of all mugs and the cup. Also, you know that Sereja has (n - 1) friends. Determine if Sereja's friends can play the game so that nobody loses. \n\n#### Input:\nThe first line contains integers n and s (2 ≤ n ≤ 100; 1 ≤ s ≤ 1000) — the number of mugs and the volume of the cup. The next line contains n integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ 10). Number ai means the volume of the i-th mug.\n\n#### Output:\nIn a single line, print \"YES\" (without the quotes) if his friends can play in the described manner, and \"NO\" (without the quotes) otherwise.\n\n#### 範例:\n\ninput:\n```\n3 4\n1 1 1\n```\noutput:\n```\nYES\n```\ninput:\n```\n3 4\n3 1 3\n```\noutput:\n```\nYES\n```\ninput:\n```\n3 4\n4 4 4\n```\noutput:\n```\nNO\n```\n\n#### 題意:\nn個杯子，n-1個人各選一個，總容量要不超過s，問有可能達成嗎？\n\n#### 思路:\n只問有沒有可能，不是一定要，所以只要考慮n-1個數的最小值就好，因此把最大的拿掉後看看行不行就是答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/0df5bb1e098e637055883d57254a1812.js\"></script>\n\n","tags":["implementation","CodeForces","新手"],"categories":["Codeforces"]},{"title":"Codeforces 935A","url":"/Fafa-and-his-Company/","content":"# Codeforces 935A - Fafa and his Company\n[Fafa and his Company](https://codeforces.com/problemset/problem/935/A)\n\nFafa owns a company that works on huge projects. There are n employees in Fafa's company. Whenever the company has a new project to start working on, Fafa has to divide the tasks of this project among all the employees.\n<!-- more -->\nFafa finds doing this every time is very tiring for him. So, he decided to choose the best l employees in his company as team leaders. Whenever there is a new project, Fafa will divide the tasks among only the team leaders and each team leader will be responsible of some positive number of employees to give them the tasks. To make this process fair for the team leaders, each one of them should be responsible for the same number of employees. Moreover, every employee, who is not a team leader, has to be under the responsibility of exactly one team leader, and no team leader is responsible for another team leader.\n\nGiven the number of employees n, find in how many ways Fafa could choose the number of team leaders l in such a way that it is possible to divide employees between them evenly.\n\n#### Input:\nThe input consists of a single line containing a positive integer n (2 ≤ n ≤ 10<sup>5</sup>) — the number of employees in Fafa's company.\n\n#### Output:\nPrint a single integer representing the answer to the problem.\n\n#### 範例:\n\ninput:\n```\n2\n```\noutput:\n```\n1\n```\ninput:\n```\n10\n```\noutput:\n```\n3\n```\n\n#### Note:\nIn the second sample Fafa has 3 ways:\n\n>>● choose only 1 employee as a team leader with 9 employees under his responsibility.\n>>● choose 2 employees as team leaders with 4 employees under the responsibility of each of them.\n>>● choose 5 employees as team leaders with 1 employee under the responsibility of each of them. \n#### 題意:\n現在有n個員工，要被分成小組，一個小組一定要有1個組長和1個以上的組員，而且每一組的人數必須一樣，問現在有幾種分法？\n\n#### 思路:\n題目等同於問n有幾個2以上的因數，1不行不用管；n一定是，先加1；從2開始，能整除就加2，因為因數是成對出現的，這樣可以只檢查到平方根就好；例外的平方根要注意，平方根能整除也只加1。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/dec4d3138b5eb87b0df108f844503fcb.js\"></script>\n\n","tags":["implementation","math","CodeForces","新手","CHU Training"],"categories":["Codeforces"]},{"title":"Codeforces 760B","url":"/Frodo-and-pillows/","content":"# Codeforces 760B - Frodo and pillows\n[Frodo and pillows](https://codeforces.com/problemset/problem/760/B)\n\nn hobbits are planning to spend the night at Frodo's house. Frodo has n beds standing in a row and m pillows (n ≤ m). Each hobbit needs a bed and at least one pillow to sleep, however, everyone wants as many pillows as possible. Of course, it's not always possible to share pillows equally, but any hobbit gets hurt if he has at least two pillows less than some of his neighbors have.\n<!-- more -->\nFrodo will sleep on the k-th bed in the row. What is the maximum number of pillows he can have so that every hobbit has at least one pillow, every pillow is given to some hobbit and no one is hurt?\n\n#### Input:\nThe only line contain three integers n, m and k (1 ≤ n ≤ m ≤ 10<sup>9</sup>, 1 ≤ k ≤ n) — the number of hobbits, the number of pillows and the number of Frodo's bed.\n\n#### Output:\nPrint single integer — the maximum number of pillows Frodo can have so that no one is hurt.\n\n#### 範例:\ninput:\n```\n4 6 2\n```\noutput:\n```\n2\n```\ninput:\n```\n3 10 3\n```\noutput:\n```\n4\n```\ninput:\n```\n3 6 1\n```\noutput:\n```\n3\n```\n\n#### Note:\nIn the first example Frodo can have at most two pillows. In this case, he can give two pillows to the hobbit on the first bed, and one pillow to each of the hobbits on the third and the fourth beds.\n\nIn the second example Frodo can take at most four pillows, giving three pillows to each of the others.\n\nIn the third example Frodo can take three pillows, giving two pillows to the hobbit in the middle and one pillow to the hobbit on the third bed.\n\n#### 題意:\n有n個哈比人要睡在Frodo的家中，現在有排成一列的n張床和m個枕頭，每個哈比人都需要1張床和至少1個枕頭，但他們都想要盡量多的枕頭，卻又會因為假如隔壁的哈比人比他多2個以上的枕頭而傷心。Frodo睡在第k床上，他最多可以拿到幾個枕頭又沒有讓任何一個哈比人傷心？\n\n#### 思路:\nm個枕頭分配給n個哈比人，至少每人1個一定是可以的，最多不可能超過m個，因此在0~m中搜尋Frodo的枕頭數量。\u000b這題的重點除了基本的二分搜尋法概念以外，就是該如何計算枕頭總數，如果用累加的有可能會因為測資較大而超時，因此要用數學方式計算總數。\n\n假設k拿3個，則分布可能會如下面的圖，則計算總數的方式分為4個區段：\na~b：計算方式同長方形，高度為1。\nb~c：計算方式同梯型。\nc~d：計算方式同梯型\nd~e：計算方式同長方形，高度為1。\n![A](A.PNG)\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b3b1589cfc0f43b71fc38eb642ee2b4e.js\"></script>\n\n\n","tags":["math","CodeForces","普通","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 507A","url":"/Amr-and-Music/","content":"# Codeforces 507A - Amr and Music\n[Amr and Music](https://codeforces.com/problemset/problem/507/A)\n\nAmr is a young coder who likes music a lot. He always wanted to learn how to play music but he was busy coding so he got an idea.\n<!-- more -->\nAmr has n instruments, it takes a<sub>i</sub> days to learn i-th instrument. Being busy, Amr dedicated k days to learn how to play the maximum possible number of instruments.\n\nAmr asked for your help to distribute his free days between instruments so that he can achieve his goal.\n\n#### Input:\nThe first line contains two numbers n, k (1 ≤ n ≤ 100, 0 ≤ k ≤ 10 000), the number of instruments and number of days respectively.\n\nThe second line contains n integers ai (1 ≤ a<sub>i</sub> ≤ 100), representing number of days required to learn the i-th instrument.\n\n#### Output:\nIn the first line output one integer m representing the maximum number of instruments Amr can learn.\n\nIn the second line output m space-separated integers: the indices of instruments to be learnt. You may output indices in any order.\n\nif there are multiple optimal solutions output any. It is not necessary to use all days for studying.\n\n#### 範例:\n\ninput:\n```\n4 10\n4 3 1 2\n```\noutput:\n```\n4\n1 2 3 4\n```\ninput:\n```\n5 6\n4 3 1 1 2\n```\noutput:\n```\n3\n1 3 4\n```\ninput:\n```\n1 3\n4\n```\noutput:\n```\n0\n```\n\n#### Note:\nIn the first test Amr can learn all 4 instruments.\n\nIn the second test other possible solutions are: {2, 3, 5} or {3, 4, 5}.\n\nIn the third test Amr doesn't have enough time to learn the only presented instrument.\n\n#### 題意:\n現在有k天的時間，他想要盡量學一些樂器，學第i種樂器的時間需要a<sub>i</sub>天，請問最多可以學幾種樂器，分別是哪幾種？\n\n#### 思路:\n因為需要印出是哪幾種，所以不能直接排序，新建一個struct，存編號跟天數，然後再依據天數由小排到大。然後一直減k，直到沒得減了或k小於0了為止，最後輸出答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/9f680592a720d787b000254aefbb2d03.js\"></script>\n\n","tags":["sortings","greedy","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 165B","url":"/Burning-Midnight-Oil/","content":"# Codeforces 165B - Burning Midnight Oil\n[Burning Midnight Oil](https://codeforces.com/problemset/problem/165/B)\n\nOne day a highly important task was commissioned to Vasya — writing a program in a night. The program consists of n lines of code. Vasya is already exhausted, so he works like that: first he writes v lines of code, drinks a cup of tea, then he writes as much as ⌊v/k⌋ lines, drinks another cup of tea, then he writes ⌊v/k<sup>2</sup>⌋ lines and so on: ⌊v/k<sup>3</sup>⌋ , ⌊v/k<sup>4</sup>⌋ , ⌊v/k<sup>5</sup>⌋ , ...\n<!-- more -->\nThe expression ⌊a/b⌋is regarded as the integral part from dividing number a by number b.\n\nThe moment the current value ⌊v/k<sup>p</sup>⌋ equals 0, Vasya immediately falls asleep and he wakes up only in the morning, when the program should already be finished.\n\nVasya is wondering, what minimum allowable value v can take to let him write not less than n lines of code before he falls asleep.\n\n#### Input:\nThe input consists of two integers n and k, separated by spaces — the size of the program in lines and the productivity reduction coefficient, 1 ≤ n ≤ 10<sup>9</sup>, 2 ≤ k ≤ 10.\n\n#### Output:\nPrint the only integer — the minimum value of v that lets Vasya write the program in one night.\n\n#### 範例:\n\ninput:\n```\n7 2\n```\noutput:\n```\n4\n```\ninput:\n```\n59 9\n```\noutput:\n```\n54\n```\n#### Note:\nIn the first sample the answer is v = 4. Vasya writes the code in the following portions: first 4 lines, then 2, then 1, and then Vasya falls asleep. Thus, he manages to write 4 + 2 + 1 = 7 lines in a night and complete the task.\n\nIn the second sample the answer is v = 54. Vasya writes the code in the following portions: 54, 6. The total sum is 54 + 6 = 60, that's even more than n = 59.\n\n#### 題意:\n他現在快睡著了，寫了v行程式碼之後就必須喝一杯茶，然後就能繼續寫⌊𝑣/𝑘⌋行程式碼；再喝一杯茶，能再寫⌊𝑣/𝑘<sup>2</sup>⌋行程式碼，當⌊𝑣/𝑘<sup>𝑝</sup>⌋等於0的時候就會立刻睡著。現在問你假如他必須寫出至少n行程式碼的話，v最少要是多少？\n\n#### 思路:\n需要n行，因此v=0時一定不行，v=n時一定可以，所以在0~n中做二分搜尋法必定可以找到答案。\n● 若是v=mid時算出來的行數等於n，則mid就是最小值。\n● 若是v=mid時算出來的行數大於n，則mid有可能是答案，將最小值記起來再減少上限找看看有沒有可能更小。\n● 若是v=mid時算出來的行數小於n，則mid不可能是答案，增加下限找看看有沒有可能的答案。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/9316d78bd8016b0996ffd5fceeb75ffd.js\"></script>\n\n\n","tags":["implementation","CodeForces","普通","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 609A","url":"/USB-Flash-Drives/","content":"# Codeforces 609A - USB Flash Drives\n[USB Flash Drives](https://codeforces.com/problemset/problem/609/A)\n\nSean is trying to save a large file to a USB flash drive. He has n USB flash drives with capacities equal to a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> megabytes. The file size is equal to m megabytes.\n<!-- more -->\nFind the minimum number of USB flash drives needed to write Sean's file, if he can split the file between drives.\n\n#### Input:\nThe first line contains positive integer n (1 ≤ n ≤ 100) — the number of USB flash drives.\n\nThe second line contains positive integer m (1 ≤ m ≤ 10<sup>5</sup>) — the size of Sean's file.\n\nEach of the next n lines contains positive integer a<sub>i</sub> (1 ≤ a<sub>i</sub> ≤ 1000) — the sizes of USB flash drives in megabytes.\n\nIt is guaranteed that the answer exists, i. e. the sum of all a<sub>i</sub> is not less than m.\n\n#### Output:\nPrint the minimum number of USB flash drives to write Sean's file, if he can split the file between drives.\n\n#### 範例:\ninput:\n```\n3\n5\n2\n1\n3\n```\noutput:\n```\n2\n```\ninput:\n```\n3\n6\n2\n3\n2\n```\noutput:\n```\n3\n```\ninput:\n```\n2\n5\n5\n10\n```\noutput:\n```\n1\n```\n\n#### Note:\nIn the first example Sean needs only two USB flash drives — the first and the third.\n\nIn the second example Sean needs all three USB flash drives.\n\nIn the third example Sean needs only one USB flash drive and he can use any available USB flash drive — the first or the second.\n\n#### 題意:\n有n個隨身碟的容量是a<sub>1</sub>、a<sub>2</sub>、…、a<sub>n</sub>，有筆資料的容量是m，問你最少要幾個隨身碟才裝得下？\n\n#### 思路:\n排序後由大的開始扣，容量扣完或全部用完了的時候就結束。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/796d0bc74e046275763493f76b904146.js\"></script>\n\n\n","tags":["sortings","greedy","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 1118A","url":"/Water-Buying/","content":"# Codeforces 1118A - Water Buying\n[Water Buying](https://codeforces.com/contest/1118/problem/A)\n\nPolycarp wants to cook a soup. To do it, he needs to buy exactly n liters of water.\n<!-- more -->\nThere are only two types of water bottles in the nearby shop — 1-liter bottles and 2-liter bottles. There are infinitely many bottles of these two types in the shop.\n\nThe bottle of the first type costs a burles and the bottle of the second type costs b burles correspondingly.\n\nPolycarp wants to spend as few money as possible. Your task is to find the minimum amount of money (in burles) Polycarp needs to buy exactly n\nliters of water in the nearby shop if the bottle of the first type costs a burles and the bottle of the second type costs b burles.\n\nYou also have to answer q independent queries.\n\n#### Input:\nThe first line of the input contains one integer q (1≤q≤500) — the number of queries.\n\nThe next n lines contain queries. The i-th query is given as three space-separated integers n<sub>i</sub>, a<sub>i</sub> and b<sub>i</sub> (1≤n<sub>i<sub>≤10<sup>12</sup>,1≤a<sub>i</sub>,b<sub>i</sub>≤1000) — how many liters Polycarp needs in the i-th query, the cost (in burles) of the bottle of the first type in the i-th query and the cost (in burles) of the bottle of the second type in the i-th query, respectively.\n\n#### Output:\nPrint q integers. The i-th integer should be equal to the minimum amount of money (in burles) Polycarp needs to buy exactly n<sub>i</sub> liters of water in the nearby shop if the bottle of the first type costs a<sub>i</sub> burles and the bottle of the second type costs b<sub>i</sub> burles.\n\n#### 範例:\ninput:\n```\n4\n10 1 3\n7 3 2\n1 1000 1\n1000000000000 42 88\n```\noutput:\n```\n10\n9\n1000\n42000000000000\n```\n\n#### 題意:\n現在想買正好n公升的水，只有賣兩種瓶裝水 – 1公升裝跟2公升裝的，分別是a元與b元，請問最少要花多少才買得到n公升的水？\n\n#### 思路:\n先判斷n是奇數還是偶數，奇數的話就先買一罐1公升的把n變成偶數。剩下的就以2公升為單位買，看是2罐一公升的便宜還是1罐2公升的便宜。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/8c6fc90e3bb7af3af4a1f2cb3744b6ff.js\"></script>\n\n\n","tags":["implementation","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 200B","url":"/Drinks/","content":"# Codeforces 200B - Drinks\n[Drinks](https://codeforces.com/problemset/problem/200/B)\n\nLittle Vasya loves orange juice very much. That's why any food and drink in his kitchen necessarily contains orange juice. There are n drinks in his fridge, the volume fraction of orange juice in the i-th drink equals p<sub>i</sub> percent.\n<!-- more -->\nOne day Vasya decided to make himself an orange cocktail. He took equal proportions of each of the n drinks and mixed them. Then he wondered, how much orange juice the cocktail has.\n\nFind the volume fraction of orange juice in the final drink.\n\n#### Input:\nThe first input line contains a single integer n (1 ≤ n ≤ 100) — the number of orange-containing drinks in Vasya's fridge. The second line contains n integers pi (0 ≤ p<sub>i</sub> ≤ 100) — the volume fraction of orange juice in the i-th drink, in percent. The numbers are separated by a space.\n#### Output:\nPrint the volume fraction in percent of orange juice in Vasya's cocktail. The answer will be considered correct if the absolute or relative error does not exceed 10<sup>-4</sup>.\n#### 範例:\ninput:\n```\n3\n50 50 100\n```\noutput:\n```\n66.666666666667\n```\ninput:\n```\n4\n0 25 50 75\n```\noutput:\n```\n37.500000000000\n```\n\n#### Note:\n![A](A.PNG)\n\n#### 題意:\n有n種飲料，第i種飲料的柳橙汁含量比例是百分之p<sub>i</sub>。現在將n種飲料等比例的混合做成綜合柳橙汁，最後的柳橙汁含量百分比是多少？\n\n#### 思路:\n加總平均。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b9a845e27cfb68cdf7fc52926580f9bc.js\"></script>\n","tags":["implementation","CodeForces","新手","CHU Training"],"categories":["Codeforces"]},{"title":"Codeforces 230B","url":"/T-primes/","content":"# Codeforces 230B - T-primes\n[T-primes](https://codeforces.com/problemset/problem/230/B)\n\nWe know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer t Т-prime, if t has exactly three distinct positive divisors.\n<!-- more -->\nYou are given an array of n positive integers. For each of them determine whether it is Т-prime or not.\n\n#### Input:\nThe first line contains a single positive integer, n (1 ≤ n ≤ 10<sup>5</sup>), showing how many numbers are in the array. The next line contains n space-separated integers x<sub>i</sub> (1 ≤ x<sub>i</sub> ≤ 10<sup>12</sup>).\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.\n\n#### Output:\nPrint n lines: the i-th line should contain \"YES\" (without the quotes), if number xi is Т-prime, and \"NO\" (without the quotes), if it isn't.\n\n#### 範例:\n\ninput:\n```\n3\n4 5 6\n```\noutput:\n```\nYES\nNO\nNO\n```\n\n#### Note:\nThe given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is \"YES\". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is \"NO\".\n\n#### 題意:\n題目定義一個數只有三個不同的因數，叫做T-Prime。現在給你N個數，問你他們各自是不是T-Prime。\n\n#### 思路:\n因為只有三個因數，1跟自己就佔了兩個，所以剩下的一個一定是你的平方根，而且而且平方根還不能有其他因數，因此平方根必須是質數。2跟4是唯二的特例，例外處理，其他的偶數不必處理。先建立質數表，然後用二分搜尋法查找他平方根在的那格是不是質數就可以了。\n\n![A](A.PNG)\n![B](B.PNG)\n![C](C.PNG)\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/6fdd04e43ec13a0d17c5164bca48fefb.js\"></script>\n\n","tags":["math","CodeForces","普通","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 474B","url":"/Worms/","content":"# Codeforces 474B - Worms\n[Worms](https://codeforces.com/problemset/problem/474/B)\n\nIt is lunch time for Mole. His friend, Marmot, prepared him a nice game for lunch.\n<!-- more -->\nMarmot brought Mole n ordered piles of worms such that i-th pile contains ai worms. He labeled all these worms with consecutive integers: worms in first pile are labeled with numbers 1 to a<sub>1</sub>, worms in second pile are labeled with numbers a<sub>1</sub> + 1 to a<sub>1</sub> + a<sub>2</sub> and so on. See the example for a better understanding.\n\nMole can't eat all the worms (Marmot brought a lot) and, as we all know, Mole is blind, so Marmot tells him the labels of the best juicy worms. Marmot will only give Mole a worm if Mole says correctly in which pile this worm is contained.\n\nPoor Mole asks for your help. For all juicy worms said by Marmot, tell Mole the correct answers.\n\n#### Input:\nThe first line contains a single integer n (1 ≤ n ≤ 10<sup>5</sup>), the number of piles.\n\nThe second line contains n integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ 10<sup>3</sup>, a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>n</sub> ≤ 10<sup>6</sup>), where ai is the number of worms in the i-th pile.\n\nThe third line contains single integer m (1 ≤ m ≤ 10<sup>5</sup>), the number of juicy worms said by Marmot.\n\nThe fourth line contains m integers q<sub>1</sub>, q<sub>2</sub>, ..., qm (1 ≤ q<sub>i</sub> ≤ a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>n</sub>), the labels of the juicy worms.\n\n#### Output:\nPrint m lines to the standard output. The i-th line should contain an integer, representing the number of the pile where the worm labeled with the number q<sub>i</sub> is.\n\n#### 範例:\n\ninput:\n```\n5\n2 7 3 4 9\n3\n1 25 11\n```\noutput:\n```\n1\n5\n3\n```\n#### Note:\nFor the sample input:\n\n● The worms with labels from [1, 2] are in the first pile.\n● The worms with labels from [3, 9] are in the second pile.\n● The worms with labels from [10, 12] are in the third pile.\n● The worms with labels from [13, 16] are in the fourth pile.\n● The worms with labels from [17, 25] are in the fifth pile.\n\n#### 題意:\n有隻鼴鼠正準備吃午餐，有另一隻鼴鼠幫他將N隻蟲，照編號頭尾相連的排成了一列，座標從第一隻蟲的最左邊為1開始延續，然後跟他講M次他該吃座標多少的蟲。現在問你他每一次吃的蟲是編號幾號的蟲？\n\n#### 思路:\n建一個陣列，將蟲的長度累加，陣列中的第i格存的是編號i的蟲的尾巴座標是多少。接著將每次輸入的座標用二分搜尋法查找蟲的編號。\n![A](A.PNG)\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b3c379b0cf5a291cb9f2a117b6a6c1a2.js\"></script>\n","tags":["CodeForces","普通","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 653A","url":"/Bear-and-Three-Balls/","content":"# Codeforces 653A - Bear and Three Balls\n[Bear and Three Balls](https://codeforces.com/problemset/problem/653/A)\n\nLimak is a little polar bear. He has n balls, the i-th ball has size t<sub>i</sub>.\n<!-- more -->\nLimak wants to give one ball to each of his three friends. Giving gifts isn't easy — there are two rules Limak must obey to make friends happy:\n\n● No two friends can get balls of the same size.\n● No two friends can get balls of sizes that differ by more than 2.\nFor example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can't choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can't choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).\n\nYour task is to check whether Limak can choose three balls that satisfy conditions above.\n\n#### Input:\nThe first line of the input contains one integer n (3 ≤ n ≤ 50) — the number of balls Limak has.\n\nThe second line contains n integers t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>n</sub> (1 ≤ t<sub>i</sub> ≤ 1000) where ti denotes the size of the i-th ball.\n\n#### Output:\nPrint \"YES\" (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print \"NO\" (without quotes).\n\n#### 範例:\n\ninput:\n```\n4\n18 55 16 17\n```\noutput:\n```\nYES\n```\ninput:\n```\n6\n40 41 43 44 44 44\n```\noutput:\n```\nNO\n```\ninput:\n```\n8\n5 972 3 4 1 4 970 971\n```\noutput:\n```\nYES\n```\n#### Note:\nIn the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.\n\nIn the second sample, there is no way to give gifts to three friends without breaking the rules.\n\nIn the third sample, there is even more than one way to choose balls:\n\n>>1. Choose balls with sizes 3, 4 and 5.\n>>2. Choose balls with sizes 972, 970, 971.\n\n#### 題意:\n一隻熊要送他的三個朋友各一顆球，有兩個條件，(a)不能一樣大，(b)不能有兩個人的球的大小差距超過2。給你一些球，問你能不能挑出符合條件的三顆球？\n\n#### 思路:\n綜合兩個條件，唯一能符合的球的大小就是N，N+1，N+2，因此先小到大排序，然後從小的開始找有沒有出現三個連續大小的球。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/20b935d0b2db96a90f0c8265f25e0cfb.js\"></script>\n\n","tags":["sortings","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 263B","url":"/Squares/","content":"# Codeforces 263B - Squares\n[Squares](https://codeforces.com/problemset/problem/263/B)\n\nVasya has found a piece of paper with a coordinate system written on it. There are n distinct squares drawn in this coordinate system. Let's number the squares with integers from 1 to n. It turned out that points with coordinates (0, 0) and (ai, ai) are the opposite corners of the i-th square.\n<!-- more -->\nVasya wants to find such integer point (with integer coordinates) of the plane, that belongs to exactly k drawn squares. We'll say that a point belongs to a square, if the point is located either inside the square, or on its boundary.\n\nHelp Vasya find a point that would meet the described limits.\n\n\n#### Input:\nThe first line contains two space-separated integers n, k (1 ≤ n, k ≤ 50). The second line contains space-separated integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (1 ≤ a<sub>i</sub>≤ 10<sup>9</sup>).\n#### Output:\nIn a single line print two space-separated integers x and y (0 ≤ x, y ≤ 10<sup>9</sup>) — the coordinates of the point that belongs to exactly k squares. If there are multiple answers, you are allowed to print any of them.\n\nIf there is no answer, print \"-1\" (without the quotes).\n\n#### 範例:\n\ninput:\n``` \n4 3\n5 1 3 4\n```\noutput:\n```\n2 1\n```\ninput:\n```\n3 1\n2 4 1\n```\noutput:\n```\n4 0\n```\ninput:\n```\n4 50\n5 1 10 2\n```\noutput:\n```\n-1\n```\n#### 題意:\n在平面上有N個正方形，左下點都對齊(0, 0)，請你找一個點，這個點剛好在K個正方形內，邊長保證都不會重複。\n\n#### 思路:\n因為左下角都對齊了，而且是正方型又不會重複，所以只要從大的開始往小的找K個，假設他的邊長為L，則(L, 0)就是答案。\n![A](A.PNG)\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/a765b492ae4bf0e41cceabef430761ea.js\"></script>\n\n","tags":["sortings","math","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"CodeForces 133A","url":"/HQ9/","content":"# CodeForces 133A - HQ9+\n[HQ9+](https://codeforces.com/problemset/problem/133/A)\n\nHQ9+ is a joke programming language which has only four one-character instructions:\n<!-- more -->\n● \"H\" prints \"Hello, World!\",\n● \"Q\" prints the source code of the program itself,\n● \"9\" prints the lyrics of \"99 Bottles of Beer\" song,\n● \"+\" increments the value stored in the internal accumulator.\n\nInstructions \"H\" and \"Q\" are case-sensitive and must be uppercase. The characters of the program which are not instructions are ignored.\n\nYou are given a program written in HQ9+. You have to figure out whether executing this program will produce any output.\n\n\n#### Input:\nThe input will consist of a single line p which will give a program in HQ9+. String p will contain between 1 and 100 characters, inclusive. ASCII-code of each character of p will be between 33 (exclamation mark) and 126 (tilde), inclusive.\n\n#### Output:\nOutput \"YES\", if executing the program will produce any output, and \"NO\" otherwise.\n\n#### 範例:\ninput:\n```\nHi!\n```\noutput:\n```\nYES\n```\ninput:\n```\nCodeforces\n```\noutput:\n```\nNO\n```\n#### Note:\nIn the first case the program contains only one instruction — \"H\", which prints \"Hello, World!\".\n\nIn the second case none of the program characters are language instructions.\n\n#### 題意:\n字串中有H、Q、9時印出指定的內容，+增加內部數值。給你一串字串，問你這串字串會不會讓你印出東西？\n\n#### 思路:\n因為只有HQ9會印出東西，所以把字串全部跑一次，有HQ9其中一個字出現就是YES，否則就是NO。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/8f84f817c66175e00695130cfced0619.js\"></script>\n\n","tags":["implementation","math","CodeForces","新手"],"categories":["Codeforces"]},{"title":"Codeforces 617A","url":"/Elephant/","content":"# Codeforces 617A - Elephant\n[Elephant](https://codeforces.com/problemset/problem/617/A)\n\nAn elephant decided to visit his friend. It turned out that the elephant's house is located at point 0 and his friend's house is located at point x(x > 0) of the coordinate line. In one step the elephant can move 1, 2, 3, 4 or 5 positions forward. Determine, what is the minimum number of steps he need to make in order to get to his friend's house.\n<!-- more -->\n#### Input:\nThe first line of the input contains an integer x (1 ≤ x ≤ 1 000 000) — The coordinate of the friend's house.\n\n#### Output:\nPrint the minimum number of steps that elephant needs to make to get from point 0 to point x.\n\n#### 範例:\ninput:\n```\n5\n```\noutput:\n```\n1\n```\ninput:\n```\n12\n```\noutput:\n```\n3\n```\n\n#### Note:\nIn the first sample the elephant needs to make one step of length 5 to reach the point x.\n\nIn the second sample the elephant can get to point x if he moves by 3, 5 and 4. There are other ways to get the optimal answer but the elephant cannot reach x in less than three moves.\n\n#### 題意:\n字串中有H、Q、9時印出指定的內容，+增加內部數值。給你一串字串，問你這串字串會不會讓你印出東西？\n\n#### 思路:\n因為只有HQ9會印出東西，所以把字串全部跑一次，有HQ9其中一個字出現就是YES，否則就是NO。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/a3c788a465878f6d9badc51d1728422a.js\"></script>\n","tags":["implementation","CodeForces","新手"],"categories":["Codeforces"]},{"title":"Codeforces 965B","url":"/Battleship/","content":"# Codeforces 965B - Battleship\n[Battleship](https://codeforces.com/problemset/problem/965/B)\n\nArkady is playing Battleship. The rules of this game aren't really important.\n<!-- more -->\nThere is a field of n×n cells. There should be exactly one k-decker on the field, i. e. a ship that is k cells long oriented either horizontally or vertically. However, Arkady doesn't know where it is located. For each cell Arkady knows if it is definitely empty or can contain a part of the ship.\n\nConsider all possible locations of the ship. Find such a cell that belongs to the maximum possible number of different locations of the ship.\n\n#### Input:\nThe first line contains two integers n and k (1≤k≤n≤100) — the size of the field and the size of the ship.\n\nThe next n lines contain the field. Each line contains n characters, each of which is either '#' (denotes a definitely empty cell) or '.' (denotes a cell that can belong to the ship).\n\n#### Output:\nOutput two integers — the row and the column of a cell that belongs to the maximum possible number of different locations of the ship.\n\nIf there are multiple answers, output any of them. In particular, if no ship can be placed on the field, you can output any cell.\n\n#### 範例:\n\ninput:\n```\n4 3\n#..#\n#.#.\n....\n.###\n```\noutput:\n```\n3 2\n```\ninput:\n```\n10 4\n#....##...\n.#...#....\n..#..#..#.\n...#.#....\n.#..##.#..\n.....#...#\n...#.##...\n.#...#.#..\n.....#..#.\n...#.#...#\n```\noutput:\n```\n6 1\n```\ninput:\n```\n19 6\n##..............###\n#......#####.....##\n.....#########.....\n....###########....\n...#############...\n..###############..\n.#################.\n.#################.\n.#################.\n.#################.\n#####....##....####\n####............###\n####............###\n#####...####...####\n.#####..####..#####\n...###........###..\n....###########....\n.........##........\n#.................#\n```\noutput:\n```\n1 8\n```\n#### Note:\nThe picture below shows the three possible locations of the ship that contain the cell (3,2) in the first sample.\n![A](A.PNG)\n\n#### 題意:\n他給你一個海域圖，井號是礁石('#')，點點是海('.')，輸入N(海域大小N x N) K(船的長度 1 x K)，問你船出現機率最高的是哪個點(可參考範例一的圖)。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b068dc00eaa347c4818011b1a8912375.js\"></script>\n\n","tags":["implementation","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 701C","url":"/They-Are-Everywhere/","content":"# Codeforces 701C - They Are Everywhere\n[They Are Everywhere](https://codeforces.com/problemset/problem/701/C)\n\nSergei B., the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1.\n<!-- more -->\nThere is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once.\n\nSergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit.\n\n\n#### Input:\nThe first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats in the house.\n\nThe second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i-th letter equals the type of Pokemon, which is in the flat number i.\n\n#### Output:\nPrint the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house.\n\n#### 範例:\ninput:\n```\n3\nAaA\n```\noutput:\n```\n2\n```\ninput:\n```\n7\nbcAAcbc\n```\noutput:\n```\n3\n```\ninput:\n```\n6\naaBCCe\n```\noutput:\n```\n5\n```\n#### Note:\nIn the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.\n\nIn the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6.\n\nIn the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.\n\n#### 題意:\n本題題意是給你ㄧ串字母(只包含a-zA-Z)，你要選一段子字串\"包含所有出現過的字母\"，問你最短的子字串是多長，也就是最短且出現過母字串所有的字母。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/d78d6145cc18240f8586230ea46b906c.js\"></script>\n\n","tags":["CodeForces","普通","two pointers","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 990B","url":"/Micro-World/","content":"# Codeforces 990B - Micro-World\n[Micro-World](https://codeforces.com/problemset/problem/990/B)\n\nYou have a Petri dish with bacteria and you are preparing to dive into the harsh micro-world. But, unfortunately, you don't have any microscope nearby, so you can't watch them.\n<!-- more -->\nYou know that you have n bacteria in the Petri dish and size of the i-th bacteria is a<sub>i</sub>. Also you know intergalactic positive integer constant K.\n\nThe i-th bacteria can swallow the j-th bacteria if and only if a<sub>i</sub>>a<sub>j</sub> and a<sub>i</sub>≤a<sub>j</sub>+K. The j-th bacteria disappear, but the i-th bacteria doesn't change its size. The bacteria can perform multiple swallows. On each swallow operation any bacteria i can swallow any bacteria j if a<sub>i</sub>a<sub>j</sub> and a<sub>i</sub>≤a<sub>j</sub>+K. The swallow operations go one after another.\n\nFor example, the sequence of bacteria sizes a=[101,53,42,102,101,55,54] and K=1. The one of possible sequences of swallows is: [101,53,42,102,(101),55,54] → [101,(53),42,102,55,54] → [(101),42,102,55,54] → [42,102,55,(54)] → [42,102,55]. In total there are 3 bacteria remained in the Petri dish.\n\nSince you don't have a microscope, you can only guess, what the minimal possible number of bacteria can remain in your Petri dish when you finally will find any microscope.\n\n\n#### Input:\nThe first line contains two space separated positive integers n and K (1≤n≤2⋅10<sup>5</sup>, 1≤K≤10<sup>6</sup>) — number of bacteria and intergalactic constant K.\n\nThe second line contains n space separated integers a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (1≤a<sub>i</sub>≤10<sup>6</sup>) — sizes of bacteria you have.\n\n#### Output:\nPrint the only integer — minimal possible number of bacteria can remain.\n\n#### 範例:\ninput:\n```\n7 1\n101 53 42 102 101 55 54\n```\noutput:\n```\n3\n```\ninput:\n```\n6 5\n20 15 10 15 20 25\n```\noutput:\n```\n1\n```\ninput:\n```\n7 1000000\n1 1 1 1 1 1 1\n```\noutput:\n```\n7\n```\n#### Note:\nThe first example is clarified in the problem statement.\n\nIn the second example an optimal possible sequence of swallows is: [20,15,10,15,(20),25] → [20,15,10,(15),25] → [20,15,(10),25] → [20,(15),25] → [(20),25] → [25].\n\nIn the third example no bacteria can swallow any other bacteria.\n\n#### 題意:\n這題再說有N個細菌，每個細菌大小為ai，細菌ai可以吃其他細菌aj不過只有兩個規則，一個規則是ai > aj 而且 ai <= aj + k 才可以吃掉。\n\n#### 思路:\n我們就先存好同樣尺寸的細菌，然後把全部細菌排序，之後符合規則的細菌我就一次吃掉。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/ea7da7267654c3a79516b4bb44aac686.js\"></script>\n\n","tags":["sortings","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 122A","url":"/Lucky-Division/","content":"# Codeforces 122A - Lucky Division\n[Lucky Division](https://codeforces.com/problemset/problem/122/A)\n\nPetya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.\n<!-- more -->\nPetya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.\n\n#### Input:\nThe single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.\n\n#### Output:\nIn the only line print \"YES\" (without the quotes), if number n is almost lucky. Otherwise, print \"NO\" (without the quotes).\n\n#### 範例:\ninput:\n```\n47\n```\noutput:\n```\nYES\n```\ninput:\n```\n16\n```\noutput:\n```\nYES\n```\ninput:\n```\n78\n```\noutput:\n```\nNO\n```\n#### Note:\nNote that all lucky numbers are almost lucky as any number is evenly divisible by itself.\n\nIn the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.\n\n#### 題意:\n找出信幸運數字。\n\n#### 思路:\n這題再找一個幸運的數字，因為N小於1000所以我們直接把1000以內幸運數字存在陣列裡面，題目也說道如果有數字可以被幸運數字整除，那麼它也是幸運數字。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/79c825a14fee509b9061b7d4fae97c74.js\"></script>\n\n\n","tags":["implementation","math","CodeForces","新手"],"categories":["Codeforces"]},{"title":"Codeforces 721A","url":"/One-dimensional-Japanese-Crossword/","content":"# Codeforces 721A - One-dimensional Japanese Crossword\n[One-dimensional Japanese Crossword](https://codeforces.com/problemset/problem/721/A)\n\nRecently Adaltik discovered japanese crosswords. Japanese crossword is a picture, represented as a table sized a × b squares, and each square is colored white or black. There are integers to the left of the rows and to the top of the columns, encrypting the corresponding row or column. The number of integers represents how many groups of black squares there are in corresponding row or column, and the integers themselves represents the number of consecutive black squares in corresponding group (you can find more detailed explanation in Wikipedia https://en.wikipedia.org/wiki/Japanese_crossword).\n<!-- more -->\nAdaltik decided that the general case of japanese crossword is too complicated and drew a row consisting of n squares (e.g. japanese crossword sized 1 × n), which he wants to encrypt in the same way as in japanese crossword.\n![A](A.PNG)\nHelp Adaltik find the numbers encrypting the row he drew.\n\n#### Input:\nThe first line of the input contains a single integer n (1 ≤ n ≤ 100) — the length of the row. The second line of the input contains a single string consisting of n characters 'B' or 'W', ('B' corresponds to black square, 'W' — to white square in the row that Adaltik drew).\n\n#### Output:\nThe first line should contain a single integer k — the number of integers encrypting the row, e.g. the number of groups of black squares in the row.\n\nThe second line should contain k integers, encrypting the row, e.g. corresponding to sizes of groups of consecutive black squares in the order from left to right.\n\n#### 範例:\ninput:\n```\n3\nBBW\n```\noutput:\n```\n1\n2 \n```\ninput:\n```\n5\nBWBWB\n```\noutput:\n```\n3\n1 1 1 \n```\ninput:\n```\n4\nWWWW\n```\noutput:\n```\n0\n```\ninput:\n```\n4\nBBBB\n```\noutput:\n```\n1\n4 \n```\ninput:\n```\n13\nWBBBBWWBWBBBW\n```\noutput:\n```\n3\n4 1 3 \n```\n\n#### Note:\nThe last sample case correspond to the picture in the statement.\n\n#### 題意:\n這題簡單來說呢就是找出有多少個連續'B'的區間，第一行輸出總共這條字串有幾組連續'B'的區間，第二行則輸出每組區間'B'得數量。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/b18a15fe05325da585fab6348f062d1c.js\"></script>\n\n","tags":["implementation","CodeForces","新手"],"categories":["Codeforces"]},{"title":"CodeForces 148A","url":"/Insomnia-cure/","content":"# CodeForces 148A - Insomnia cure\n[Insomnia cure](https://codeforces.com/problemset/problem/148/A)\n\n«One dragon. Two dragon. Three dragon», — the princess was counting. She had trouble falling asleep, and she got bored of counting lambs when she was nine.\n<!-- more -->\nHowever, just counting dragons was boring as well, so she entertained herself at best she could. Tonight she imagined that all dragons were here to steal her, and she was fighting them off. Every k-th dragon got punched in the face with a frying pan. Every l-th dragon got his tail shut into the balcony door. Every m-th dragon got his paws trampled with sharp heels. Finally, she threatened every n-th dragon to call her mom, and he withdrew in panic.\n\nHow many imaginary dragons suffered moral or physical damage tonight, if the princess counted a total of d dragons?\n\n#### Input:\nInput data contains integer numbers k, l, m, n and d, each number in a separate line (1 ≤ k, l, m, n ≤ 10, 1 ≤ d ≤ 10<sup>5</sup>).\n\n#### Output:\nOutput the number of damaged dragons.\n\n#### 範例:\ninput:\n```\n1\n2\n3\n4\n12\n```\noutput:\n```\n12\n```\ninput:\n```\n2\n3\n4\n5\n24\n```\noutput:\n```\n17\n```\n#### Note:\nIn the first case every first dragon got punched with a frying pan. Some of the dragons suffered from other reasons as well, but the pan alone would be enough.\n\nIn the second case dragons 1, 7, 11, 13, 17, 19 and 23 escaped unharmed.\n\n#### 題意:\n計算龍的攻擊。\n\n#### 思路:\nEvery k-th dragon got punched in the face with a frying pan: 每K隻龍就攻擊一遍\nEvery l-th dragon got his tail shut into the balcony door. \nEvery m-th dragon got his paws trampled with sharp heels. \nFinally, she threatened every n-th dragon to call her mom, and he withdrew in panic.\n\n依此類推每??隻龍就攻擊(k ,l ,m ,n)\n解法是開一個陣列去紀錄哪一些龍被攻擊了，最後再用一個for迴圈去統計有多少隻龍受到傷害\n```\n\tex:\n\t\t Every k-th dragon got punched in the face with a frying pan ,k = 2 (有12隻龍)\n\t\t \n\t\t 開一個陣列: □ □ □ □ □ □ □ □ □ □ □ □ (12個) \n\t\t \n\t\t 因為是每兩隻龍就攻擊一次所以陣列每數到2就標記一次:\n\t\t \n\t\t 1 2 1 2 1 2 1 2 1 2 1 2\n\t\t □ ■ □ ■ □ ■ □ ■ □ ■ □ ■\n\t\t \n\t\t 最後做統計，有標記的就是被攻擊過的:\n\t\t \n\t\t   1   2   3   4   5   6\n\t\t □ ■ □ ■ □ ■ □ ■ □ ■ □ ■\n\t\t \n\t\t 所以被攻擊過的龍就是6隻。\n```\n題目有 k ,l ,m ,n依此類推都是這樣去標記，最後在做一次統計\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/0cd0e5027094ec5738df365d8f2b38cc.js\"></script>\n\n","tags":["sortings","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 118B","url":"/Present-from-Lena/","content":"# Codeforces 118B - Present from Lena\n[Present from Lena](https://codeforces.com/problemset/problem/118/B)\n\nVasya's birthday is approaching and Lena decided to sew a patterned handkerchief to him as a present. Lena chose digits from 0 to n as the pattern. The digits will form a rhombus. The largest digit n should be located in the centre. The digits should decrease as they approach the edges. For example, for n = 5 the handkerchief pattern should look like that:\n<!-- more -->\n\n          0\n        0 1 0\n      0 1 2 1 0\n    0 1 2 3 2 1 0\n  0 1 2 3 4 3 2 1 0\n0 1 2 3 4 5 4 3 2 1 0\n  0 1 2 3 4 3 2 1 0\n    0 1 2 3 2 1 0\n      0 1 2 1 0\n        0 1 0\n          0\nYour task is to determine the way the handkerchief will look like by the given n.\n\n#### Input:\nThe first line contains the single integer n (2 ≤ n ≤ 9).\n\n#### Output:\nPrint a picture for the given n. You should strictly observe the number of spaces before the first digit on each line. Every two adjacent digits in the same line should be separated by exactly one space. There should be no spaces after the last digit at the end of each line.\n\n#### 範例:\ninput:\n```\n2\n```\noutput:\n```\n    0\n  0 1 0\n0 1 2 1 0\n  0 1 0\n    0\n```\ninput:\n```\n3\n```\noutput:\n```\n      0\n    0 1 0\n  0 1 2 1 0\n0 1 2 3 2 1 0\n  0 1 2 1 0\n    0 1 0\n      0\n```\n\n#### 題意:\n印出一個按照他的規則的菱形。\n每個數字後面必須要有空白，但最後一個字後面不能有空白!\n\n#### 思路:\n```\n    0 1 2 3 4 5 6 7 8 9 10  \nA             0\nB           0 1 0\nC         0 1 2 1 0\nD       0 1 2 3 2 1 0\nE     0 1 2 3 4 3 2 1 0\nF   0 1 2 3 4 5 4 3 2 1 0\nG     0 1 2 3 4 3 2 1 0\nH       0 1 2 3 2 1 0\nI         0 1 2 1 0\nJ           0 1 0\nK             0\n```\n\n要印菱形要先決定起始的位置，這一題菱形的第一列的起始位置是第六行(編號5)。\n第二列(編號B)的起始位置則是上一列減1，依此類推直到第五列。\n第六列(編號F)開始起始位置正好相反，是上一列加1。\n菱形的第一列印的結束位置也是是第六行(編號5)，也就是印完就換下一行。\n每一行的結束位置的流程則和開始位置相反，先加後減。\n\t \n*這樣會印出緊湊的菱形，這一題菱形的數字之間\"要加空白，但每一列最後一行不可以有空白\"。\n\n中間沒空白的菱形:\n```\n     *\n    ***\n   *****\n  *******\n *********\n***********\n *********\n  *******\n   *****\n    ***\n     *\n```\n中間有空白的菱形:\n```\n          *\n        * * *\n      * * * * *\n    * * * * * * *\n  * * * * * * * * *\n* * * * * * * * * * *\n  * * * * * * * * *\n    * * * * * * *\n      * * * * *\n        * * *\n          *\n```\n這樣菱形就完成了，剩下就是印出數字!\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/9465b85756422ea5cf249d925c518520.js\"></script>\n\n","tags":["implementation","簡單","CodeForces"],"categories":["Codeforces"]},{"title":"Codeforces 977A","url":"/Simple-Game/","content":"# Codeforces 977A - Simple Game\n[Simple Game](https://codeforces.com/problemset/problem/977/A)\n\n\nOne day Misha and Andrew were playing a very simple game. First, each player chooses an integer in the range from 1 to n. Let's assume that Misha chose number m, and Andrew chose number a.\n<!-- more -->\nThen, by using a random generator they choose a random integer c in the range between 1 and n (any integer from 1 to n is chosen with the same probability), after which the winner is the player, whose number was closer to c. The boys agreed that if m and a are located on the same distance from c, Misha wins.\n\nAndrew wants to win very much, so he asks you to help him. You know the number selected by Misha, and number n. You need to determine which value of a Andrew must choose, so that the probability of his victory is the highest possible.\n\nMore formally, you need to find such integer a (1 ≤ a ≤ n), that the probability that  is maximal, where c is the equiprobably chosen integer from 1 to n (inclusive).\n\n#### Input:\nThe first line contains two integers n and m (1 ≤ m ≤ n ≤ 10<sup>9</sup>) — the range of numbers in the game, and the number selected by Misha respectively.\n\n#### Output:\nPrint a single number — such value a, that probability that Andrew wins is the highest. If there are multiple such values, print the minimum of them.\n\n#### 範例:\ninput:\n```\n3 1\n```\noutput:\n```\n2\n```\ninput:\n```\n4 3\n```\noutput:\n```\n2\n```\n\n#### Note:\nIn the first sample test: Andrew wins if c is equal to 2 or 3. The probability that Andrew wins is 2 / 3. If Andrew chooses a = 3, the probability of winning will be 1 / 3. If a = 1, the probability of winning is 0.\n\nIn the second sample test: Andrew wins if c is equal to 1 and 2. The probability that Andrew wins is 1 / 2. For other choices of a the probability of winning is less.\n\n#### 題意:\n這題再說如何讓自己贏的機率最大。\n#### 思路:\n我們就先找出中間的位置然後看電腦在左邊還是右邊，如果在右邊我們就往左邊一格，這麼一來我們贏的機率就比較大，相反的在右邊我們就往左邊一格。\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/50785ac588a8620607b0cee5f52a358f.js\"></script>\n\n","tags":["CodeForces","普通","two pointers","binary search"],"categories":["Codeforces"]},{"title":"Codeforces 263A","url":"/Beautiful-Matrix/","content":"# Codeforces 263A - Beautiful Matrix\n[Beautiful Matrix](https://codeforces.com/problemset/problem/263/A)\n\nYou've got a 5 × 5 matrix, consisting of 24 zeroes and a single number one. Let's index the matrix rows by numbers from 1 to 5 from top to bottom, let's index the matrix columns by numbers from 1 to 5 from left to right. In one move, you are allowed to apply one of the two following transformations to the matrix:\n<!-- more -->\n>>1.Swap two neighboring matrix rows, that is, rows with indexes i and i + 1 for some integer i (1 ≤ i < 5).\n>>2.Swap two neighboring matrix columns, that is, columns with indexes j and j + 1 for some integer j (1 ≤ j < 5).\n\nYou think that a matrix looks beautiful, if the single number one of the matrix is located in its middle (in the cell that is on the intersection of the third row and the third column). Count the minimum number of moves needed to make the matrix beautiful.\n\n\n#### Input:\nThe input consists of five lines, each line contains five integers: the j-th integer in the i-th line of the input represents the element of the matrix that is located on the intersection of the i-th row and the j-th column. It is guaranteed that the matrix consists of 24 zeroes and a single number one.\n\n#### Output:\nPrint a single integer — the minimum number of moves needed to make the matrix beautiful.\n\n#### 範例:\n\ninput:\n```\n0 0 0 0 0\n0 0 0 0 1\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n```\noutput:\n```\n3\n```\ninput:\n```\n0 0 0 0 0\n0 0 0 0 0\n0 1 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n```\noutput:\n```\n1\n```\n\n#### 題意:\n計算需要幾步才能把數字移動到中間。\n\n#### 程式碼:\n<script src=\"https://gist.github.com/Daviswww/4926be670df9b7c761c5cae8d0e29a0f.js\"></script>\n\n","tags":["implementation","math","CodeForces","新手"],"categories":["Codeforces"]},{"title":"Codeforces 977A","url":"/Wrong-Subtraction/","content":"# Codeforces 977A - Wrong Subtraction\n[Wrong Subtraction](https://codeforces.com/problemset/problem/977/A)\n\nLittle girl Tanya is learning how to decrease a number by one, but she does it wrong with a number consisting of two or more digits. Tanya subtracts one from a number by the following algorithm:\n<!-- more -->\n● if the last digit of the number is non-zero, she decreases the number by one;\n● if the last digit of the number is zero, she divides the number by 10 (i.e. removes the last digit).\n\nYou are given an integer number n. Tanya will subtract one from it k times. Your task is to print the result after all k subtractions.\n\nIt is guaranteed that the result will be positive integer number.\n\n#### Input:\nThe first line of the input contains two integer numbers n and k (2≤n≤10<sup>9</sup>, 1≤k≤50) — the number from which Tanya will subtract and the number of subtractions correspondingly.\n\n#### Output:\nPrint one integer number — the result of the decreasing n by one k times.\n\nIt is guaranteed that the result will be positive integer number.\n\n#### 範例:\ninput:\n```\n512 4\n```\noutput:\n```\n50\n```\ninput:\n```\n1000000000 9\n```\noutput:\n```\n1\n```\n#### Note:\nThe first example corresponds to the following sequence: 512→511→510→51→50.\n#### 題意:\nN為一個整數，K為減少的次數。\n這題的規則是:\n  1.如果該數字的最後一位數字不為零，則將該數字減少一個。\n  2.如果數字的最後一位為零，則將數字除以10（即刪除最後一位數字）。\n#### 思路:\n按照規則走。\n\n#### 程式碼:\n\n<script src=\"https://gist.github.com/Daviswww/4d41d72d84689b5e9c0a91dd551393fe.js\"></script>\n\n","tags":["implementation","CodeForces","新手"],"categories":["Codeforces"]},{"title":"我是留言板","url":"/ct/","content":"安安我是留言板!\n![A](A.PNG)\n[題目網址](https://chucs.github.io/site/)\n<!-- more -->\n\n#### 題意:\n\n#### 思路:\n\n#### 程式碼:\n\n\n\n\n","tags":["留言板"]}]